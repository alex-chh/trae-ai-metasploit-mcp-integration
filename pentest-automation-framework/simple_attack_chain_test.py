#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ç°¡åŒ–çš„æ»²é€æ¸¬è©¦æ”»æ“Šéˆæ¸¬è©¦
Simplified Penetration Testing Attack Chain Test

ç”¨æ–¼å¿«é€Ÿæ¸¬è©¦å’Œæ¼”ç¤ºæ”»æ“Šéˆçš„æ ¸å¿ƒåŠŸèƒ½
"""

import asyncio
import sys
import time
import json
from pathlib import Path
from datetime import datetime

# æ·»åŠ é …ç›®æ ¹ç›®éŒ„åˆ° Python è·¯å¾‘
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from src.core.logger import setup_logger


class SimpleAttackChainTest:
    """
    ç°¡åŒ–çš„æ”»æ“Šéˆæ¸¬è©¦é¡
    
    æ¼”ç¤ºæ»²é€æ¸¬è©¦çš„åŸºæœ¬æµç¨‹ï¼Œä¸ä¾è³´å¤–éƒ¨æœå‹™
    """
    
    def __init__(self, target: str = "127.0.0.1"):
        """
        åˆå§‹åŒ–æ¸¬è©¦
        
        Args:
            target: æ¸¬è©¦ç›®æ¨™
        """
        self.target = target
        self.output_dir = Path("./test_results")
        self.output_dir.mkdir(exist_ok=True)
        
        # è¨­ç½®æ—¥èªŒ
        self.logger = setup_logger(
            name="simple_attack_chain_test",
            log_file=str(self.output_dir / "test.log")
        )
        
        # æ¸¬è©¦çµæœ
        self.test_results = {
            "target": target,
            "start_time": time.time(),
            "phases": {},
            "summary": {}
        }
    
    async def run_test(self):
        """
        åŸ·è¡Œç°¡åŒ–çš„æ”»æ“Šéˆæ¸¬è©¦
        """
        self.logger.info(f"ğŸš€ é–‹å§‹ç°¡åŒ–æ”»æ“Šéˆæ¸¬è©¦ - ç›®æ¨™: {self.target}")
        
        try:
            # éšæ®µ 1: ç›®æ¨™é©—è­‰
            await self._test_target_validation()
            
            # éšæ®µ 2: åŸºæœ¬æƒææ¨¡æ“¬
            await self._test_basic_scanning()
            
            # éšæ®µ 3: æ¼æ´è­˜åˆ¥æ¨¡æ“¬
            await self._test_vulnerability_identification()
            
            # éšæ®µ 4: æ”»æ“Šæ¨¡æ“¬
            await self._test_attack_simulation()
            
            # éšæ®µ 5: å ±å‘Šç”Ÿæˆ
            await self._test_report_generation()
            
            # å®Œæˆæ¸¬è©¦
            self.test_results["end_time"] = time.time()
            self.test_results["duration"] = (
                self.test_results["end_time"] - self.test_results["start_time"]
            )
            
            self.logger.info("âœ… æ”»æ“Šéˆæ¸¬è©¦å®Œæˆ")
            
        except Exception as e:
            self.logger.error(f"âŒ æ¸¬è©¦å¤±æ•—: {e}")
            raise
    
    async def _test_target_validation(self):
        """
        æ¸¬è©¦ç›®æ¨™é©—è­‰
        """
        phase_name = "target_validation"
        self.logger.info("ğŸ¯ éšæ®µ 1: ç›®æ¨™é©—è­‰")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "é©—è­‰ç›®æ¨™å¯é”æ€§",
            "start_time": phase_start
        }
        
        try:
            # æ¨¡æ“¬ ping æ¸¬è©¦
            import subprocess
            import platform
            
            if platform.system().lower() == "windows":
                cmd = ["ping", "-n", "1", self.target]
            else:
                cmd = ["ping", "-c", "1", self.target]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            phase_results["target_reachable"] = result.returncode == 0
            phase_results["ping_output"] = result.stdout[:200]  # é™åˆ¶è¼¸å‡ºé•·åº¦
            
            if phase_results["target_reachable"]:
                self.logger.info(f"  âœ… ç›®æ¨™ {self.target} å¯é”")
            else:
                self.logger.warning(f"  âš ï¸  ç›®æ¨™ {self.target} ä¸å¯é”")
            
        except Exception as e:
            self.logger.error(f"  âŒ ç›®æ¨™é©—è­‰å¤±æ•—: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_basic_scanning(self):
        """
        æ¸¬è©¦åŸºæœ¬æƒæåŠŸèƒ½
        """
        phase_name = "basic_scanning"
        self.logger.info("ğŸ” éšæ®µ 2: åŸºæœ¬æƒæ")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "åŸºæœ¬ç«¯å£æƒæ",
            "start_time": phase_start,
            "scanned_ports": []
        }
        
        try:
            # æ¨¡æ“¬ç«¯å£æƒæ
            common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 443, 445, 993, 995, 3389]
            
            self.logger.info(f"  ğŸ” æƒæå¸¸è¦‹ç«¯å£...")
            
            import socket
            open_ports = []
            
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((self.target, port))
                    sock.close()
                    
                    if result == 0:
                        open_ports.append(port)
                        self.logger.info(f"    âœ… ç«¯å£ {port} é–‹æ”¾")
                    
                    phase_results["scanned_ports"].append({
                        "port": port,
                        "status": "open" if result == 0 else "closed"
                    })
                    
                except Exception as e:
                    phase_results["scanned_ports"].append({
                        "port": port,
                        "status": "error",
                        "error": str(e)
                    })
            
            phase_results["open_ports"] = open_ports
            phase_results["open_port_count"] = len(open_ports)
            
            self.logger.info(f"  ğŸ“Š ç™¼ç¾ {len(open_ports)} å€‹é–‹æ”¾ç«¯å£")
            
        except Exception as e:
            self.logger.error(f"  âŒ æƒæå¤±æ•—: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_vulnerability_identification(self):
        """
        æ¸¬è©¦æ¼æ´è­˜åˆ¥
        """
        phase_name = "vulnerability_identification"
        self.logger.info("ğŸ” éšæ®µ 3: æ¼æ´è­˜åˆ¥")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "æ¼æ´è­˜åˆ¥å’Œè©•ä¼°",
            "start_time": phase_start,
            "identified_vulnerabilities": []
        }
        
        try:
            # æ¨¡æ“¬æ¼æ´è­˜åˆ¥
            scanning_phase = self.test_results["phases"].get("basic_scanning", {})
            open_ports = scanning_phase.get("open_ports", [])
            
            # åŸºæ–¼é–‹æ”¾ç«¯å£çš„ç°¡å–®æ¼æ´è­˜åˆ¥
            vulnerability_map = {
                21: {"service": "FTP", "potential_vulns": ["åŒ¿åç™»éŒ„", "å¼±å¯†ç¢¼"]},
                22: {"service": "SSH", "potential_vulns": ["å¼±å¯†ç¢¼", "å¯†é‘°æ´©éœ²"]},
                23: {"service": "Telnet", "potential_vulns": ["æ˜æ–‡å‚³è¼¸", "å¼±èªè­‰"]},
                80: {"service": "HTTP", "potential_vulns": ["Webæ‡‰ç”¨æ¼æ´", "ç›®éŒ„éæ­·"]},
                135: {"service": "RPC", "potential_vulns": ["RPCæ¼æ´", "æ¬Šé™æå‡"]},
                139: {"service": "NetBIOS", "potential_vulns": ["ä¿¡æ¯æ´©éœ²", "å…±äº«è¨ªå•"]},
                443: {"service": "HTTPS", "potential_vulns": ["SSL/TLSæ¼æ´", "è­‰æ›¸å•é¡Œ"]},
                445: {"service": "SMB", "potential_vulns": ["EternalBlue", "SMBæ¼æ´"]},
                3389: {"service": "RDP", "potential_vulns": ["å¼±å¯†ç¢¼", "BlueKeep"]}
            }
            
            for port in open_ports:
                if port in vulnerability_map:
                    vuln_info = vulnerability_map[port]
                    
                    for vuln in vuln_info["potential_vulns"]:
                        vulnerability = {
                            "port": port,
                            "service": vuln_info["service"],
                            "vulnerability": vuln,
                            "severity": self._get_mock_severity(vuln),
                            "description": f"{vuln_info['service']} æœå‹™å¯èƒ½å­˜åœ¨ {vuln} æ¼æ´"
                        }
                        
                        phase_results["identified_vulnerabilities"].append(vulnerability)
                        
                        severity_icon = self._get_severity_icon(vulnerability["severity"])
                        self.logger.info(f"  {severity_icon} ç™¼ç¾æ¼æ´: {vuln} (ç«¯å£ {port})")
            
            # çµ±è¨ˆæ¼æ´
            vuln_count = len(phase_results["identified_vulnerabilities"])
            severity_stats = {}
            
            for vuln in phase_results["identified_vulnerabilities"]:
                severity = vuln["severity"]
                severity_stats[severity] = severity_stats.get(severity, 0) + 1
            
            phase_results["vulnerability_count"] = vuln_count
            phase_results["severity_statistics"] = severity_stats
            
            self.logger.info(f"  ğŸ“Š è­˜åˆ¥å‡º {vuln_count} å€‹æ½›åœ¨æ¼æ´")
            
        except Exception as e:
            self.logger.error(f"  âŒ æ¼æ´è­˜åˆ¥å¤±æ•—: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_attack_simulation(self):
        """
        æ¸¬è©¦æ”»æ“Šæ¨¡æ“¬
        """
        phase_name = "attack_simulation"
        self.logger.info("ğŸ’¥ éšæ®µ 4: æ”»æ“Šæ¨¡æ“¬")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "æ”»æ“Šæ¨¡æ“¬å’Œæ¸¬è©¦",
            "start_time": phase_start,
            "attack_attempts": []
        }
        
        try:
            # æ¨¡æ“¬æ”»æ“Šå˜—è©¦
            vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
            vulnerabilities = vuln_phase.get("identified_vulnerabilities", [])
            
            # å°æ¯å€‹é«˜å±å’Œåš´é‡æ¼æ´é€²è¡Œæ¨¡æ“¬æ”»æ“Š
            high_risk_vulns = [v for v in vulnerabilities if v["severity"] in ["critical", "high"]]
            
            for vuln in high_risk_vulns[:3]:  # é™åˆ¶æ”»æ“Šå˜—è©¦æ•¸é‡
                attack_attempt = {
                    "target_port": vuln["port"],
                    "target_service": vuln["service"],
                    "vulnerability": vuln["vulnerability"],
                    "attack_type": self._get_attack_type(vuln["vulnerability"]),
                    "timestamp": time.time()
                }
                
                # æ¨¡æ“¬æ”»æ“Šçµæœï¼ˆéš¨æ©ŸæˆåŠŸ/å¤±æ•—ï¼‰
                import random
                success_rate = 0.3 if vuln["severity"] == "critical" else 0.1
                attack_success = random.random() < success_rate
                
                attack_attempt["success"] = attack_success
                attack_attempt["result"] = "æ”»æ“ŠæˆåŠŸ" if attack_success else "æ”»æ“Šå¤±æ•—"
                
                if attack_success:
                    attack_attempt["impact"] = self._get_attack_impact(vuln["vulnerability"])
                    self.logger.info(f"  âœ… æ”»æ“ŠæˆåŠŸ: {vuln['vulnerability']} (ç«¯å£ {vuln['port']})")
                else:
                    self.logger.info(f"  âŒ æ”»æ“Šå¤±æ•—: {vuln['vulnerability']} (ç«¯å£ {vuln['port']})")
                
                phase_results["attack_attempts"].append(attack_attempt)
                
                # æ¨¡æ“¬æ”»æ“Šé–“éš”
                await asyncio.sleep(0.1)
            
            # çµ±è¨ˆæ”»æ“Šçµæœ
            successful_attacks = [a for a in phase_results["attack_attempts"] if a["success"]]
            phase_results["successful_attacks"] = len(successful_attacks)
            phase_results["total_attempts"] = len(phase_results["attack_attempts"])
            
            self.logger.info(f"  ğŸ“Š æ”»æ“Šçµ±è¨ˆ: {len(successful_attacks)}/{len(phase_results['attack_attempts'])} æˆåŠŸ")
            
        except Exception as e:
            self.logger.error(f"  âŒ æ”»æ“Šæ¨¡æ“¬å¤±æ•—: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_report_generation(self):
        """
        æ¸¬è©¦å ±å‘Šç”Ÿæˆ
        """
        phase_name = "report_generation"
        self.logger.info("ğŸ“Š éšæ®µ 5: å ±å‘Šç”Ÿæˆ")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "ç”Ÿæˆæ¸¬è©¦å ±å‘Š",
            "start_time": phase_start,
            "generated_reports": []
        }
        
        try:
            # ç”Ÿæˆ JSON å ±å‘Š
            json_report_path = self.output_dir / "test_report.json"
            with open(json_report_path, 'w', encoding='utf-8') as f:
                json.dump(self.test_results, f, indent=2, ensure_ascii=False, default=str)
            
            phase_results["generated_reports"].append({
                "format": "json",
                "path": str(json_report_path)
            })
            
            # ç”Ÿæˆç°¡å–®çš„ HTML å ±å‘Š
            html_report_path = self.output_dir / "test_report.html"
            html_content = self._generate_html_report()
            
            with open(html_report_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            phase_results["generated_reports"].append({
                "format": "html",
                "path": str(html_report_path)
            })
            
            self.logger.info(f"  ğŸ“„ ç”Ÿæˆ JSON å ±å‘Š: {json_report_path}")
            self.logger.info(f"  ğŸ“„ ç”Ÿæˆ HTML å ±å‘Š: {html_report_path}")
            
        except Exception as e:
            self.logger.error(f"  âŒ å ±å‘Šç”Ÿæˆå¤±æ•—: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    def _get_mock_severity(self, vulnerability: str) -> str:
        """
        ç²å–æ¨¡æ“¬æ¼æ´åš´é‡ç¨‹åº¦
        
        Args:
            vulnerability: æ¼æ´åç¨±
            
        Returns:
            åš´é‡ç¨‹åº¦
        """
        high_risk = ["EternalBlue", "BlueKeep", "æ˜æ–‡å‚³è¼¸"]
        medium_risk = ["å¼±å¯†ç¢¼", "ç›®éŒ„éæ­·", "ä¿¡æ¯æ´©éœ²"]
        
        if any(risk in vulnerability for risk in high_risk):
            return "critical"
        elif any(risk in vulnerability for risk in medium_risk):
            return "high"
        else:
            return "medium"
    
    def _get_severity_icon(self, severity: str) -> str:
        """
        ç²å–åš´é‡ç¨‹åº¦åœ–æ¨™
        
        Args:
            severity: åš´é‡ç¨‹åº¦
            
        Returns:
            åœ–æ¨™
        """
        icons = {
            "critical": "ğŸš¨",
            "high": "âš ï¸",
            "medium": "âš¡",
            "low": "â„¹ï¸"
        }
        return icons.get(severity, "â“")
    
    def _get_attack_type(self, vulnerability: str) -> str:
        """
        ç²å–æ”»æ“Šé¡å‹
        
        Args:
            vulnerability: æ¼æ´åç¨±
            
        Returns:
            æ”»æ“Šé¡å‹
        """
        if "å¯†ç¢¼" in vulnerability:
            return "æš´åŠ›ç ´è§£"
        elif "EternalBlue" in vulnerability:
            return "é ç¨‹ä»£ç¢¼åŸ·è¡Œ"
        elif "ç›®éŒ„éæ­·" in vulnerability:
            return "è·¯å¾‘éæ­·"
        else:
            return "é€šç”¨æ”»æ“Š"
    
    def _get_attack_impact(self, vulnerability: str) -> str:
        """
        ç²å–æ”»æ“Šå½±éŸ¿
        
        Args:
            vulnerability: æ¼æ´åç¨±
            
        Returns:
            æ”»æ“Šå½±éŸ¿
        """
        if "EternalBlue" in vulnerability:
            return "ç²å¾—ç³»çµ±æ¬Šé™"
        elif "å¯†ç¢¼" in vulnerability:
            return "ç²å¾—æœå‹™è¨ªå•æ¬Šé™"
        elif "ç›®éŒ„éæ­·" in vulnerability:
            return "ç²å¾—æ–‡ä»¶è¨ªå•æ¬Šé™"
        else:
            return "ç²å¾—æœ‰é™è¨ªå•æ¬Šé™"
    
    def _generate_html_report(self) -> str:
        """
        ç”Ÿæˆ HTML å ±å‘Š
        
        Returns:
            HTML å…§å®¹
        """
        html_template = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ»²é€æ¸¬è©¦æ”»æ“Šéˆæ¸¬è©¦å ±å‘Š</title>
    <style>
        body {{
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }}
        .summary {{
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }}
        .phase {{
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
        }}
        .phase.success {{
            border-left: 4px solid #27ae60;
        }}
        .phase.error {{
            border-left: 4px solid #e74c3c;
        }}
        .vulnerability {{
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }}
        .vulnerability.critical {{
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }}
        .vulnerability.high {{
            background-color: #fff3cd;
            border-color: #ffeaa7;
        }}
        .attack {{
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }}
        .attack.success {{
            background-color: #d4edda;
            border-color: #c3e6cb;
        }}
        .stats {{
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }}
        .stat-item {{
            text-align: center;
            padding: 15px;
            background-color: #3498db;
            color: white;
            border-radius: 5px;
            min-width: 120px;
        }}
        .stat-value {{
            font-size: 24px;
            font-weight: bold;
        }}
        .stat-label {{
            font-size: 12px;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ æ»²é€æ¸¬è©¦æ”»æ“Šéˆæ¸¬è©¦å ±å‘Š</h1>
        
        <div class="summary">
            <h2>ğŸ“‹ æ¸¬è©¦æ‘˜è¦</h2>
            <p><strong>ç›®æ¨™:</strong> {self.target}</p>
            <p><strong>é–‹å§‹æ™‚é–“:</strong> {datetime.fromtimestamp(self.test_results['start_time']).strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>çµæŸæ™‚é–“:</strong> {datetime.fromtimestamp(self.test_results.get('end_time', time.time())).strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>ç¸½è€—æ™‚:</strong> {self.test_results.get('duration', 0):.2f} ç§’</p>
        </div>
        
        <div class="stats">
            {self._generate_stats_html()}
        </div>
        
        <h2>ğŸ“Š æ¸¬è©¦éšæ®µ</h2>
        {self._generate_phases_html()}
        
        <h2>ğŸ” ç™¼ç¾çš„æ¼æ´</h2>
        {self._generate_vulnerabilities_html()}
        
        <h2>ğŸ’¥ æ”»æ“Šå˜—è©¦</h2>
        {self._generate_attacks_html()}
        
        <div class="summary">
            <h2>ğŸ“ çµè«–</h2>
            <p>æœ¬æ¬¡æ”»æ“Šéˆæ¸¬è©¦æˆåŠŸæ¼”ç¤ºäº†æ»²é€æ¸¬è©¦çš„å®Œæ•´æµç¨‹ï¼ŒåŒ…æ‹¬ç›®æ¨™é©—è­‰ã€æƒæã€æ¼æ´è­˜åˆ¥ã€æ”»æ“Šæ¨¡æ“¬å’Œå ±å‘Šç”Ÿæˆã€‚</p>
            <p>æ¸¬è©¦çµæœåƒ…ä¾›å­¸ç¿’å’Œæ¼”ç¤ºä½¿ç”¨ï¼Œå¯¦éš›æ»²é€æ¸¬è©¦éœ€è¦æ›´å°ˆæ¥­çš„å·¥å…·å’ŒæŠ€è¡“ã€‚</p>
        </div>
    </div>
</body>
</html>
        """
        return html_template
    
    def _generate_stats_html(self) -> str:
        """
        ç”Ÿæˆçµ±è¨ˆä¿¡æ¯ HTML
        
        Returns:
            çµ±è¨ˆä¿¡æ¯ HTML
        """
        stats_html = ""
        
        # é–‹æ”¾ç«¯å£çµ±è¨ˆ
        scan_phase = self.test_results["phases"].get("basic_scanning", {})
        open_port_count = scan_phase.get("open_port_count", 0)
        
        stats_html += f"""
        <div class="stat-item">
            <div class="stat-value">{open_port_count}</div>
            <div class="stat-label">é–‹æ”¾ç«¯å£</div>
        </div>
        """
        
        # æ¼æ´çµ±è¨ˆ
        vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
        vuln_count = vuln_phase.get("vulnerability_count", 0)
        
        stats_html += f"""
        <div class="stat-item">
            <div class="stat-value">{vuln_count}</div>
            <div class="stat-label">ç™¼ç¾æ¼æ´</div>
        </div>
        """
        
        # æ”»æ“Šçµ±è¨ˆ
        attack_phase = self.test_results["phases"].get("attack_simulation", {})
        successful_attacks = attack_phase.get("successful_attacks", 0)
        
        stats_html += f"""
        <div class="stat-item">
            <div class="stat-value">{successful_attacks}</div>
            <div class="stat-label">æˆåŠŸæ”»æ“Š</div>
        </div>
        """
        
        return stats_html
    
    def _generate_phases_html(self) -> str:
        """
        ç”Ÿæˆéšæ®µä¿¡æ¯ HTML
        
        Returns:
            éšæ®µä¿¡æ¯ HTML
        """
        phases_html = ""
        
        for phase_name, phase_data in self.test_results["phases"].items():
            status_class = "error" if "error" in phase_data else "success"
            status_icon = "âŒ" if "error" in phase_data else "âœ…"
            duration = phase_data.get("duration", 0)
            
            phases_html += f"""
            <div class="phase {status_class}">
                <h3>{status_icon} {phase_data['description']}</h3>
                <p><strong>è€—æ™‚:</strong> {duration:.2f} ç§’</p>
                {f'<p><strong>éŒ¯èª¤:</strong> {phase_data["error"]}</p>' if "error" in phase_data else ''}
            </div>
            """
        
        return phases_html
    
    def _generate_vulnerabilities_html(self) -> str:
        """
        ç”Ÿæˆæ¼æ´ä¿¡æ¯ HTML
        
        Returns:
            æ¼æ´ä¿¡æ¯ HTML
        """
        vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
        vulnerabilities = vuln_phase.get("identified_vulnerabilities", [])
        
        if not vulnerabilities:
            return "<p>æœªç™¼ç¾æ¼æ´</p>"
        
        vulns_html = ""
        for vuln in vulnerabilities:
            severity_icon = self._get_severity_icon(vuln["severity"])
            
            vulns_html += f"""
            <div class="vulnerability {vuln['severity']}">
                <h4>{severity_icon} {vuln['vulnerability']}</h4>
                <p><strong>ç«¯å£:</strong> {vuln['port']} ({vuln['service']})</p>
                <p><strong>åš´é‡ç¨‹åº¦:</strong> {vuln['severity']}</p>
                <p><strong>æè¿°:</strong> {vuln['description']}</p>
            </div>
            """
        
        return vulns_html
    
    def _generate_attacks_html(self) -> str:
        """
        ç”Ÿæˆæ”»æ“Šä¿¡æ¯ HTML
        
        Returns:
            æ”»æ“Šä¿¡æ¯ HTML
        """
        attack_phase = self.test_results["phases"].get("attack_simulation", {})
        attacks = attack_phase.get("attack_attempts", [])
        
        if not attacks:
            return "<p>æœªé€²è¡Œæ”»æ“Šå˜—è©¦</p>"
        
        attacks_html = ""
        for attack in attacks:
            status_class = "success" if attack["success"] else ""
            status_icon = "âœ…" if attack["success"] else "âŒ"
            
            attacks_html += f"""
            <div class="attack {status_class}">
                <h4>{status_icon} {attack['attack_type']}</h4>
                <p><strong>ç›®æ¨™:</strong> {attack['target_service']} (ç«¯å£ {attack['target_port']})</p>
                <p><strong>æ¼æ´:</strong> {attack['vulnerability']}</p>
                <p><strong>çµæœ:</strong> {attack['result']}</p>
                {f'<p><strong>å½±éŸ¿:</strong> {attack["impact"]}</p>' if attack.get('impact') else ''}
            </div>
            """
        
        return attacks_html
    
    def print_summary(self):
        """
        æ‰“å°æ¸¬è©¦æ‘˜è¦
        """
        print("\n" + "="*80)
        print("ğŸ¯ æ»²é€æ¸¬è©¦æ”»æ“Šéˆæ¸¬è©¦æ‘˜è¦")
        print("="*80)
        
        print(f"ç›®æ¨™: {self.target}")
        print(f"é–‹å§‹æ™‚é–“: {datetime.fromtimestamp(self.test_results['start_time'])}")
        
        if "end_time" in self.test_results:
            print(f"çµæŸæ™‚é–“: {datetime.fromtimestamp(self.test_results['end_time'])}")
            print(f"ç¸½è€—æ™‚: {self.test_results['duration']:.2f} ç§’")
        
        print("\nğŸ“‹ æ¸¬è©¦éšæ®µ:")
        for phase_name, phase_data in self.test_results["phases"].items():
            status = "âœ…" if "error" not in phase_data else "âŒ"
            duration = phase_data.get("duration", 0)
            print(f"  {status} {phase_data['description']} ({duration:.2f}s)")
        
        # çµ±è¨ˆä¿¡æ¯
        print("\nğŸ“Š æ¸¬è©¦çµæœ:")
        
        # æƒæçµ±è¨ˆ
        scan_phase = self.test_results["phases"].get("basic_scanning", {})
        if "open_port_count" in scan_phase:
            print(f"  ğŸ”Œ é–‹æ”¾ç«¯å£: {scan_phase['open_port_count']}")
        
        # æ¼æ´çµ±è¨ˆ
        vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
        if "vulnerability_count" in vuln_phase:
            print(f"  ğŸ” ç™¼ç¾æ¼æ´: {vuln_phase['vulnerability_count']}")
            
            severity_stats = vuln_phase.get("severity_statistics", {})
            for severity, count in severity_stats.items():
                icon = self._get_severity_icon(severity)
                print(f"    {icon} {severity}: {count}")
        
        # æ”»æ“Šçµ±è¨ˆ
        attack_phase = self.test_results["phases"].get("attack_simulation", {})
        if "successful_attacks" in attack_phase:
            successful = attack_phase["successful_attacks"]
            total = attack_phase["total_attempts"]
            print(f"  ğŸ’¥ æ”»æ“ŠæˆåŠŸ: {successful}/{total}")
        
        # å ±å‘Šæ–‡ä»¶
        report_phase = self.test_results["phases"].get("report_generation", {})
        reports = report_phase.get("generated_reports", [])
        if reports:
            print(f"\nğŸ“„ ç”Ÿæˆçš„å ±å‘Š:")
            for report in reports:
                print(f"  ğŸ“‹ {report['format'].upper()}: {report['path']}")
        
        print("\n" + "="*80)


async def main():
    """
    ä¸»å‡½æ•¸
    """
    import argparse
    
    parser = argparse.ArgumentParser(
        description="ç°¡åŒ–çš„æ»²é€æ¸¬è©¦æ”»æ“Šéˆæ¸¬è©¦",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        "-t", "--target",
        default="127.0.0.1",
        help="æ¸¬è©¦ç›®æ¨™ IP åœ°å€ (é»˜èª: 127.0.0.1)"
    )
    
    args = parser.parse_args()
    
    # å‰µå»ºæ¸¬è©¦å¯¦ä¾‹
    test = SimpleAttackChainTest(target=args.target)
    
    try:
        # åŸ·è¡Œæ¸¬è©¦
        await test.run_test()
        
        # æ‰“å°æ‘˜è¦
        test.print_summary()
        
        print(f"\nğŸ‰ æ”»æ“Šéˆæ¸¬è©¦å®Œæˆï¼çµæœä¿å­˜åœ¨: {test.output_dir}")
        
    except KeyboardInterrupt:
        print("\nâš ï¸  ç”¨æˆ¶ä¸­æ–·æ“ä½œ")
    except Exception as e:
        print(f"\nâŒ æ¸¬è©¦å¤±æ•—: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(main())