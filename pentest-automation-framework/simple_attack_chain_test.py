#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
簡化的滲透測試攻擊鏈測試
Simplified Penetration Testing Attack Chain Test

用於快速測試和演示攻擊鏈的核心功能
"""

import asyncio
import sys
import time
import json
from pathlib import Path
from datetime import datetime

# 添加項目根目錄到 Python 路徑
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from src.core.logger import setup_logger


class SimpleAttackChainTest:
    """
    簡化的攻擊鏈測試類
    
    演示滲透測試的基本流程，不依賴外部服務
    """
    
    def __init__(self, target: str = "127.0.0.1"):
        """
        初始化測試
        
        Args:
            target: 測試目標
        """
        self.target = target
        self.output_dir = Path("./test_results")
        self.output_dir.mkdir(exist_ok=True)
        
        # 設置日誌
        self.logger = setup_logger(
            name="simple_attack_chain_test",
            log_file=str(self.output_dir / "test.log")
        )
        
        # 測試結果
        self.test_results = {
            "target": target,
            "start_time": time.time(),
            "phases": {},
            "summary": {}
        }
    
    async def run_test(self):
        """
        執行簡化的攻擊鏈測試
        """
        self.logger.info(f"🚀 開始簡化攻擊鏈測試 - 目標: {self.target}")
        
        try:
            # 階段 1: 目標驗證
            await self._test_target_validation()
            
            # 階段 2: 基本掃描模擬
            await self._test_basic_scanning()
            
            # 階段 3: 漏洞識別模擬
            await self._test_vulnerability_identification()
            
            # 階段 4: 攻擊模擬
            await self._test_attack_simulation()
            
            # 階段 5: 報告生成
            await self._test_report_generation()
            
            # 完成測試
            self.test_results["end_time"] = time.time()
            self.test_results["duration"] = (
                self.test_results["end_time"] - self.test_results["start_time"]
            )
            
            self.logger.info("✅ 攻擊鏈測試完成")
            
        except Exception as e:
            self.logger.error(f"❌ 測試失敗: {e}")
            raise
    
    async def _test_target_validation(self):
        """
        測試目標驗證
        """
        phase_name = "target_validation"
        self.logger.info("🎯 階段 1: 目標驗證")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "驗證目標可達性",
            "start_time": phase_start
        }
        
        try:
            # 模擬 ping 測試
            import subprocess
            import platform
            
            if platform.system().lower() == "windows":
                cmd = ["ping", "-n", "1", self.target]
            else:
                cmd = ["ping", "-c", "1", self.target]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            phase_results["target_reachable"] = result.returncode == 0
            phase_results["ping_output"] = result.stdout[:200]  # 限制輸出長度
            
            if phase_results["target_reachable"]:
                self.logger.info(f"  ✅ 目標 {self.target} 可達")
            else:
                self.logger.warning(f"  ⚠️  目標 {self.target} 不可達")
            
        except Exception as e:
            self.logger.error(f"  ❌ 目標驗證失敗: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_basic_scanning(self):
        """
        測試基本掃描功能
        """
        phase_name = "basic_scanning"
        self.logger.info("🔍 階段 2: 基本掃描")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "基本端口掃描",
            "start_time": phase_start,
            "scanned_ports": []
        }
        
        try:
            # 模擬端口掃描
            common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 443, 445, 993, 995, 3389]
            
            self.logger.info(f"  🔎 掃描常見端口...")
            
            import socket
            open_ports = []
            
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((self.target, port))
                    sock.close()
                    
                    if result == 0:
                        open_ports.append(port)
                        self.logger.info(f"    ✅ 端口 {port} 開放")
                    
                    phase_results["scanned_ports"].append({
                        "port": port,
                        "status": "open" if result == 0 else "closed"
                    })
                    
                except Exception as e:
                    phase_results["scanned_ports"].append({
                        "port": port,
                        "status": "error",
                        "error": str(e)
                    })
            
            phase_results["open_ports"] = open_ports
            phase_results["open_port_count"] = len(open_ports)
            
            self.logger.info(f"  📊 發現 {len(open_ports)} 個開放端口")
            
        except Exception as e:
            self.logger.error(f"  ❌ 掃描失敗: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_vulnerability_identification(self):
        """
        測試漏洞識別
        """
        phase_name = "vulnerability_identification"
        self.logger.info("🔍 階段 3: 漏洞識別")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "漏洞識別和評估",
            "start_time": phase_start,
            "identified_vulnerabilities": []
        }
        
        try:
            # 模擬漏洞識別
            scanning_phase = self.test_results["phases"].get("basic_scanning", {})
            open_ports = scanning_phase.get("open_ports", [])
            
            # 基於開放端口的簡單漏洞識別
            vulnerability_map = {
                21: {"service": "FTP", "potential_vulns": ["匿名登錄", "弱密碼"]},
                22: {"service": "SSH", "potential_vulns": ["弱密碼", "密鑰洩露"]},
                23: {"service": "Telnet", "potential_vulns": ["明文傳輸", "弱認證"]},
                80: {"service": "HTTP", "potential_vulns": ["Web應用漏洞", "目錄遍歷"]},
                135: {"service": "RPC", "potential_vulns": ["RPC漏洞", "權限提升"]},
                139: {"service": "NetBIOS", "potential_vulns": ["信息洩露", "共享訪問"]},
                443: {"service": "HTTPS", "potential_vulns": ["SSL/TLS漏洞", "證書問題"]},
                445: {"service": "SMB", "potential_vulns": ["EternalBlue", "SMB漏洞"]},
                3389: {"service": "RDP", "potential_vulns": ["弱密碼", "BlueKeep"]}
            }
            
            for port in open_ports:
                if port in vulnerability_map:
                    vuln_info = vulnerability_map[port]
                    
                    for vuln in vuln_info["potential_vulns"]:
                        vulnerability = {
                            "port": port,
                            "service": vuln_info["service"],
                            "vulnerability": vuln,
                            "severity": self._get_mock_severity(vuln),
                            "description": f"{vuln_info['service']} 服務可能存在 {vuln} 漏洞"
                        }
                        
                        phase_results["identified_vulnerabilities"].append(vulnerability)
                        
                        severity_icon = self._get_severity_icon(vulnerability["severity"])
                        self.logger.info(f"  {severity_icon} 發現漏洞: {vuln} (端口 {port})")
            
            # 統計漏洞
            vuln_count = len(phase_results["identified_vulnerabilities"])
            severity_stats = {}
            
            for vuln in phase_results["identified_vulnerabilities"]:
                severity = vuln["severity"]
                severity_stats[severity] = severity_stats.get(severity, 0) + 1
            
            phase_results["vulnerability_count"] = vuln_count
            phase_results["severity_statistics"] = severity_stats
            
            self.logger.info(f"  📊 識別出 {vuln_count} 個潛在漏洞")
            
        except Exception as e:
            self.logger.error(f"  ❌ 漏洞識別失敗: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_attack_simulation(self):
        """
        測試攻擊模擬
        """
        phase_name = "attack_simulation"
        self.logger.info("💥 階段 4: 攻擊模擬")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "攻擊模擬和測試",
            "start_time": phase_start,
            "attack_attempts": []
        }
        
        try:
            # 模擬攻擊嘗試
            vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
            vulnerabilities = vuln_phase.get("identified_vulnerabilities", [])
            
            # 對每個高危和嚴重漏洞進行模擬攻擊
            high_risk_vulns = [v for v in vulnerabilities if v["severity"] in ["critical", "high"]]
            
            for vuln in high_risk_vulns[:3]:  # 限制攻擊嘗試數量
                attack_attempt = {
                    "target_port": vuln["port"],
                    "target_service": vuln["service"],
                    "vulnerability": vuln["vulnerability"],
                    "attack_type": self._get_attack_type(vuln["vulnerability"]),
                    "timestamp": time.time()
                }
                
                # 模擬攻擊結果（隨機成功/失敗）
                import random
                success_rate = 0.3 if vuln["severity"] == "critical" else 0.1
                attack_success = random.random() < success_rate
                
                attack_attempt["success"] = attack_success
                attack_attempt["result"] = "攻擊成功" if attack_success else "攻擊失敗"
                
                if attack_success:
                    attack_attempt["impact"] = self._get_attack_impact(vuln["vulnerability"])
                    self.logger.info(f"  ✅ 攻擊成功: {vuln['vulnerability']} (端口 {vuln['port']})")
                else:
                    self.logger.info(f"  ❌ 攻擊失敗: {vuln['vulnerability']} (端口 {vuln['port']})")
                
                phase_results["attack_attempts"].append(attack_attempt)
                
                # 模擬攻擊間隔
                await asyncio.sleep(0.1)
            
            # 統計攻擊結果
            successful_attacks = [a for a in phase_results["attack_attempts"] if a["success"]]
            phase_results["successful_attacks"] = len(successful_attacks)
            phase_results["total_attempts"] = len(phase_results["attack_attempts"])
            
            self.logger.info(f"  📊 攻擊統計: {len(successful_attacks)}/{len(phase_results['attack_attempts'])} 成功")
            
        except Exception as e:
            self.logger.error(f"  ❌ 攻擊模擬失敗: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    async def _test_report_generation(self):
        """
        測試報告生成
        """
        phase_name = "report_generation"
        self.logger.info("📊 階段 5: 報告生成")
        
        phase_start = time.time()
        phase_results = {
            "phase": phase_name,
            "description": "生成測試報告",
            "start_time": phase_start,
            "generated_reports": []
        }
        
        try:
            # 生成 JSON 報告
            json_report_path = self.output_dir / "test_report.json"
            with open(json_report_path, 'w', encoding='utf-8') as f:
                json.dump(self.test_results, f, indent=2, ensure_ascii=False, default=str)
            
            phase_results["generated_reports"].append({
                "format": "json",
                "path": str(json_report_path)
            })
            
            # 生成簡單的 HTML 報告
            html_report_path = self.output_dir / "test_report.html"
            html_content = self._generate_html_report()
            
            with open(html_report_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            phase_results["generated_reports"].append({
                "format": "html",
                "path": str(html_report_path)
            })
            
            self.logger.info(f"  📄 生成 JSON 報告: {json_report_path}")
            self.logger.info(f"  📄 生成 HTML 報告: {html_report_path}")
            
        except Exception as e:
            self.logger.error(f"  ❌ 報告生成失敗: {e}")
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = time.time()
        phase_results["duration"] = phase_results["end_time"] - phase_start
        
        self.test_results["phases"][phase_name] = phase_results
    
    def _get_mock_severity(self, vulnerability: str) -> str:
        """
        獲取模擬漏洞嚴重程度
        
        Args:
            vulnerability: 漏洞名稱
            
        Returns:
            嚴重程度
        """
        high_risk = ["EternalBlue", "BlueKeep", "明文傳輸"]
        medium_risk = ["弱密碼", "目錄遍歷", "信息洩露"]
        
        if any(risk in vulnerability for risk in high_risk):
            return "critical"
        elif any(risk in vulnerability for risk in medium_risk):
            return "high"
        else:
            return "medium"
    
    def _get_severity_icon(self, severity: str) -> str:
        """
        獲取嚴重程度圖標
        
        Args:
            severity: 嚴重程度
            
        Returns:
            圖標
        """
        icons = {
            "critical": "🚨",
            "high": "⚠️",
            "medium": "⚡",
            "low": "ℹ️"
        }
        return icons.get(severity, "❓")
    
    def _get_attack_type(self, vulnerability: str) -> str:
        """
        獲取攻擊類型
        
        Args:
            vulnerability: 漏洞名稱
            
        Returns:
            攻擊類型
        """
        if "密碼" in vulnerability:
            return "暴力破解"
        elif "EternalBlue" in vulnerability:
            return "遠程代碼執行"
        elif "目錄遍歷" in vulnerability:
            return "路徑遍歷"
        else:
            return "通用攻擊"
    
    def _get_attack_impact(self, vulnerability: str) -> str:
        """
        獲取攻擊影響
        
        Args:
            vulnerability: 漏洞名稱
            
        Returns:
            攻擊影響
        """
        if "EternalBlue" in vulnerability:
            return "獲得系統權限"
        elif "密碼" in vulnerability:
            return "獲得服務訪問權限"
        elif "目錄遍歷" in vulnerability:
            return "獲得文件訪問權限"
        else:
            return "獲得有限訪問權限"
    
    def _generate_html_report(self) -> str:
        """
        生成 HTML 報告
        
        Returns:
            HTML 內容
        """
        html_template = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>滲透測試攻擊鏈測試報告</title>
    <style>
        body {{
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }}
        .summary {{
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }}
        .phase {{
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
        }}
        .phase.success {{
            border-left: 4px solid #27ae60;
        }}
        .phase.error {{
            border-left: 4px solid #e74c3c;
        }}
        .vulnerability {{
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }}
        .vulnerability.critical {{
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }}
        .vulnerability.high {{
            background-color: #fff3cd;
            border-color: #ffeaa7;
        }}
        .attack {{
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }}
        .attack.success {{
            background-color: #d4edda;
            border-color: #c3e6cb;
        }}
        .stats {{
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }}
        .stat-item {{
            text-align: center;
            padding: 15px;
            background-color: #3498db;
            color: white;
            border-radius: 5px;
            min-width: 120px;
        }}
        .stat-value {{
            font-size: 24px;
            font-weight: bold;
        }}
        .stat-label {{
            font-size: 12px;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>🎯 滲透測試攻擊鏈測試報告</h1>
        
        <div class="summary">
            <h2>📋 測試摘要</h2>
            <p><strong>目標:</strong> {self.target}</p>
            <p><strong>開始時間:</strong> {datetime.fromtimestamp(self.test_results['start_time']).strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>結束時間:</strong> {datetime.fromtimestamp(self.test_results.get('end_time', time.time())).strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>總耗時:</strong> {self.test_results.get('duration', 0):.2f} 秒</p>
        </div>
        
        <div class="stats">
            {self._generate_stats_html()}
        </div>
        
        <h2>📊 測試階段</h2>
        {self._generate_phases_html()}
        
        <h2>🔍 發現的漏洞</h2>
        {self._generate_vulnerabilities_html()}
        
        <h2>💥 攻擊嘗試</h2>
        {self._generate_attacks_html()}
        
        <div class="summary">
            <h2>📝 結論</h2>
            <p>本次攻擊鏈測試成功演示了滲透測試的完整流程，包括目標驗證、掃描、漏洞識別、攻擊模擬和報告生成。</p>
            <p>測試結果僅供學習和演示使用，實際滲透測試需要更專業的工具和技術。</p>
        </div>
    </div>
</body>
</html>
        """
        return html_template
    
    def _generate_stats_html(self) -> str:
        """
        生成統計信息 HTML
        
        Returns:
            統計信息 HTML
        """
        stats_html = ""
        
        # 開放端口統計
        scan_phase = self.test_results["phases"].get("basic_scanning", {})
        open_port_count = scan_phase.get("open_port_count", 0)
        
        stats_html += f"""
        <div class="stat-item">
            <div class="stat-value">{open_port_count}</div>
            <div class="stat-label">開放端口</div>
        </div>
        """
        
        # 漏洞統計
        vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
        vuln_count = vuln_phase.get("vulnerability_count", 0)
        
        stats_html += f"""
        <div class="stat-item">
            <div class="stat-value">{vuln_count}</div>
            <div class="stat-label">發現漏洞</div>
        </div>
        """
        
        # 攻擊統計
        attack_phase = self.test_results["phases"].get("attack_simulation", {})
        successful_attacks = attack_phase.get("successful_attacks", 0)
        
        stats_html += f"""
        <div class="stat-item">
            <div class="stat-value">{successful_attacks}</div>
            <div class="stat-label">成功攻擊</div>
        </div>
        """
        
        return stats_html
    
    def _generate_phases_html(self) -> str:
        """
        生成階段信息 HTML
        
        Returns:
            階段信息 HTML
        """
        phases_html = ""
        
        for phase_name, phase_data in self.test_results["phases"].items():
            status_class = "error" if "error" in phase_data else "success"
            status_icon = "❌" if "error" in phase_data else "✅"
            duration = phase_data.get("duration", 0)
            
            phases_html += f"""
            <div class="phase {status_class}">
                <h3>{status_icon} {phase_data['description']}</h3>
                <p><strong>耗時:</strong> {duration:.2f} 秒</p>
                {f'<p><strong>錯誤:</strong> {phase_data["error"]}</p>' if "error" in phase_data else ''}
            </div>
            """
        
        return phases_html
    
    def _generate_vulnerabilities_html(self) -> str:
        """
        生成漏洞信息 HTML
        
        Returns:
            漏洞信息 HTML
        """
        vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
        vulnerabilities = vuln_phase.get("identified_vulnerabilities", [])
        
        if not vulnerabilities:
            return "<p>未發現漏洞</p>"
        
        vulns_html = ""
        for vuln in vulnerabilities:
            severity_icon = self._get_severity_icon(vuln["severity"])
            
            vulns_html += f"""
            <div class="vulnerability {vuln['severity']}">
                <h4>{severity_icon} {vuln['vulnerability']}</h4>
                <p><strong>端口:</strong> {vuln['port']} ({vuln['service']})</p>
                <p><strong>嚴重程度:</strong> {vuln['severity']}</p>
                <p><strong>描述:</strong> {vuln['description']}</p>
            </div>
            """
        
        return vulns_html
    
    def _generate_attacks_html(self) -> str:
        """
        生成攻擊信息 HTML
        
        Returns:
            攻擊信息 HTML
        """
        attack_phase = self.test_results["phases"].get("attack_simulation", {})
        attacks = attack_phase.get("attack_attempts", [])
        
        if not attacks:
            return "<p>未進行攻擊嘗試</p>"
        
        attacks_html = ""
        for attack in attacks:
            status_class = "success" if attack["success"] else ""
            status_icon = "✅" if attack["success"] else "❌"
            
            attacks_html += f"""
            <div class="attack {status_class}">
                <h4>{status_icon} {attack['attack_type']}</h4>
                <p><strong>目標:</strong> {attack['target_service']} (端口 {attack['target_port']})</p>
                <p><strong>漏洞:</strong> {attack['vulnerability']}</p>
                <p><strong>結果:</strong> {attack['result']}</p>
                {f'<p><strong>影響:</strong> {attack["impact"]}</p>' if attack.get('impact') else ''}
            </div>
            """
        
        return attacks_html
    
    def print_summary(self):
        """
        打印測試摘要
        """
        print("\n" + "="*80)
        print("🎯 滲透測試攻擊鏈測試摘要")
        print("="*80)
        
        print(f"目標: {self.target}")
        print(f"開始時間: {datetime.fromtimestamp(self.test_results['start_time'])}")
        
        if "end_time" in self.test_results:
            print(f"結束時間: {datetime.fromtimestamp(self.test_results['end_time'])}")
            print(f"總耗時: {self.test_results['duration']:.2f} 秒")
        
        print("\n📋 測試階段:")
        for phase_name, phase_data in self.test_results["phases"].items():
            status = "✅" if "error" not in phase_data else "❌"
            duration = phase_data.get("duration", 0)
            print(f"  {status} {phase_data['description']} ({duration:.2f}s)")
        
        # 統計信息
        print("\n📊 測試結果:")
        
        # 掃描統計
        scan_phase = self.test_results["phases"].get("basic_scanning", {})
        if "open_port_count" in scan_phase:
            print(f"  🔌 開放端口: {scan_phase['open_port_count']}")
        
        # 漏洞統計
        vuln_phase = self.test_results["phases"].get("vulnerability_identification", {})
        if "vulnerability_count" in vuln_phase:
            print(f"  🔍 發現漏洞: {vuln_phase['vulnerability_count']}")
            
            severity_stats = vuln_phase.get("severity_statistics", {})
            for severity, count in severity_stats.items():
                icon = self._get_severity_icon(severity)
                print(f"    {icon} {severity}: {count}")
        
        # 攻擊統計
        attack_phase = self.test_results["phases"].get("attack_simulation", {})
        if "successful_attacks" in attack_phase:
            successful = attack_phase["successful_attacks"]
            total = attack_phase["total_attempts"]
            print(f"  💥 攻擊成功: {successful}/{total}")
        
        # 報告文件
        report_phase = self.test_results["phases"].get("report_generation", {})
        reports = report_phase.get("generated_reports", [])
        if reports:
            print(f"\n📄 生成的報告:")
            for report in reports:
                print(f"  📋 {report['format'].upper()}: {report['path']}")
        
        print("\n" + "="*80)


async def main():
    """
    主函數
    """
    import argparse
    
    parser = argparse.ArgumentParser(
        description="簡化的滲透測試攻擊鏈測試",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        "-t", "--target",
        default="127.0.0.1",
        help="測試目標 IP 地址 (默認: 127.0.0.1)"
    )
    
    args = parser.parse_args()
    
    # 創建測試實例
    test = SimpleAttackChainTest(target=args.target)
    
    try:
        # 執行測試
        await test.run_test()
        
        # 打印摘要
        test.print_summary()
        
        print(f"\n🎉 攻擊鏈測試完成！結果保存在: {test.output_dir}")
        
    except KeyboardInterrupt:
        print("\n⚠️  用戶中斷操作")
    except Exception as e:
        print(f"\n❌ 測試失敗: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(main())