#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
完整攻擊鏈演示
Complete Attack Chain Demo

演示完整的滲透測試攻擊鏈流程：偵察 -> 掃描 -> 漏洞識別 -> 利用 -> 後滲透 -> 報告
"""

import asyncio
import argparse
import json
import sys
import time
from pathlib import Path
from typing import List, Optional

# 添加src目錄到Python路徑
sys.path.insert(0, str(Path(__file__).parent / "src"))

from src.core.framework import PentestFramework
from src.core.attack_chain_orchestrator import (
    AttackChainOrchestrator, 
    AttackChainConfig, 
    AttackPhase,
    AttackChainStatus
)
from src.post_exploit.post_exploit import PostExploitTaskType
from src.core.logger import get_logger
from src.core.config import Config


class AttackChainDemo:
    """
    攻擊鏈演示類
    """
    
    def __init__(self):
        self.logger = get_logger()
        self.framework = None
        self.orchestrator = None
    
    async def initialize(self, config_path: Optional[str] = None):
        """
        初始化演示環境
        
        Args:
            config_path: 配置文件路徑
        """
        try:
            self.logger.info("正在初始化滲透測試框架...")
            
            # 初始化框架
            if config_path and Path(config_path).exists():
                self.framework = PentestFramework(config_path=config_path)
            else:
                # 使用默認配置
                config = Config()
                self.framework = PentestFramework(
                    metasploit_config=config.metasploit,
                    github_config=config.github,
                    database_config=config.database,
                    scan_config=config.scan,
                    report_config=config.report,
                    security_config=config.security
                )
            
            await self.framework.initialize()
            
            # 創建攻擊鏈配置
            attack_config = AttackChainConfig(
                enable_reconnaissance=True,
                recon_depth="intermediate",
                scan_type="comprehensive",
                vulnerability_scan=True,
                min_severity="medium",
                auto_exploit=True,
                max_exploit_attempts=3,
                safe_mode=True,
                post_exploit_tasks=[
                    PostExploitTaskType.SYSTEM_INFO,
                    PostExploitTaskType.CREDENTIAL_HARVESTING,
                    PostExploitTaskType.NETWORK_DISCOVERY,
                    PostExploitTaskType.DATA_COLLECTION
                ],
                report_format=["html", "json", "pdf"],
                cleanup_on_completion=True
            )
            
            # 初始化攻擊鏈協調器
            self.orchestrator = AttackChainOrchestrator(self.framework, attack_config)
            
            self.logger.info("框架初始化完成")
            
        except Exception as e:
            self.logger.error(f"初始化失敗: {e}")
            raise
    
    async def run_single_target_demo(self, target_ip: str):
        """
        運行單目標攻擊鏈演示
        
        Args:
            target_ip: 目標IP地址
        """
        self.logger.info(f"開始單目標攻擊鏈演示: {target_ip}")
        
        try:
            # 執行攻擊鏈
            result = await self.orchestrator.execute_attack_chain(target_ip)
            
            # 顯示結果摘要
            self._display_attack_chain_summary(result)
            
            return result
            
        except Exception as e:
            self.logger.error(f"攻擊鏈執行失敗: {e}")
            raise
    
    async def run_multi_target_demo(self, target_ips: List[str]):
        """
        運行多目標攻擊鏈演示
        
        Args:
            target_ips: 目標IP地址列表
        """
        self.logger.info(f"開始多目標攻擊鏈演示: {len(target_ips)} 個目標")
        
        results = []
        
        try:
            # 並發執行攻擊鏈
            tasks = []
            for target_ip in target_ips:
                task = asyncio.create_task(
                    self.orchestrator.execute_attack_chain(target_ip)
                )
                tasks.append(task)
            
            # 等待所有任務完成
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 顯示結果摘要
            self._display_multi_target_summary(results)
            
            return results
            
        except Exception as e:
            self.logger.error(f"多目標攻擊鏈執行失敗: {e}")
            raise
    
    async def run_interactive_demo(self):
        """
        運行交互式演示
        """
        self.logger.info("開始交互式攻擊鏈演示")
        
        while True:
            try:
                print("\n=== 滲透測試攻擊鏈演示 ===")
                print("1. 單目標攻擊鏈")
                print("2. 多目標攻擊鏈")
                print("3. 查看活躍攻擊鏈")
                print("4. 查看已完成攻擊鏈")
                print("5. 取消攻擊鏈")
                print("6. 退出")
                
                choice = input("\n請選擇操作 (1-6): ").strip()
                
                if choice == "1":
                    target_ip = input("請輸入目標IP地址: ").strip()
                    if target_ip:
                        await self.run_single_target_demo(target_ip)
                
                elif choice == "2":
                    targets_input = input("請輸入目標IP地址 (用逗號分隔): ").strip()
                    if targets_input:
                        target_ips = [ip.strip() for ip in targets_input.split(",")]
                        await self.run_multi_target_demo(target_ips)
                
                elif choice == "3":
                    self._display_active_chains()
                
                elif choice == "4":
                    self._display_completed_chains()
                
                elif choice == "5":
                    chain_id = input("請輸入要取消的攻擊鏈ID: ").strip()
                    if chain_id:
                        success = await self.orchestrator.cancel_attack_chain(chain_id)
                        if success:
                            print(f"攻擊鏈 {chain_id} 已取消")
                        else:
                            print(f"未找到攻擊鏈 {chain_id}")
                
                elif choice == "6":
                    print("退出演示")
                    break
                
                else:
                    print("無效選擇，請重新輸入")
                    
            except KeyboardInterrupt:
                print("\n演示被中斷")
                break
            except Exception as e:
                self.logger.error(f"交互式演示錯誤: {e}")
    
    def _display_attack_chain_summary(self, result):
        """
        顯示攻擊鏈結果摘要
        """
        print(f"\n=== 攻擊鏈結果摘要 ===")
        print(f"攻擊鏈ID: {result.chain_id}")
        print(f"目標: {result.target.ip_address}")
        print(f"狀態: {result.status.value}")
        print(f"當前階段: {result.current_phase.value}")
        print(f"持續時間: {result.duration:.2f} 秒" if result.duration else "持續時間: 進行中")
        
        print(f"\n=== 統計信息 ===")
        print(f"偵察結果: {len(result.recon_results)}")
        print(f"掃描結果: {len(result.scan_results)}")
        print(f"發現漏洞: {result.total_vulnerabilities}")
        print(f"成功利用: {result.exploited_vulnerabilities}")
        print(f"活躍會話: {result.active_sessions}")
        print(f"收集數據: {result.collected_data_count}")
        print(f"生成報告: {len(result.report_paths)}")
        
        if result.errors:
            print(f"\n=== 錯誤信息 ===")
            for error in result.errors:
                print(f"- {error}")
        
        if result.report_paths:
            print(f"\n=== 生成的報告 ===")
            for report_path in result.report_paths:
                print(f"- {report_path}")
    
    def _display_multi_target_summary(self, results):
        """
        顯示多目標攻擊鏈結果摘要
        """
        print(f"\n=== 多目標攻擊鏈結果摘要 ===")
        
        successful = 0
        failed = 0
        total_vulns = 0
        total_exploited = 0
        total_sessions = 0
        
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                print(f"目標 {i+1}: 執行失敗 - {result}")
                failed += 1
            else:
                print(f"目標 {i+1} ({result.target.ip_address}): {result.status.value}")
                if result.status == AttackChainStatus.COMPLETED:
                    successful += 1
                    total_vulns += result.total_vulnerabilities
                    total_exploited += result.exploited_vulnerabilities
                    total_sessions += result.active_sessions
                else:
                    failed += 1
        
        print(f"\n=== 總體統計 ===")
        print(f"成功: {successful}")
        print(f"失敗: {failed}")
        print(f"總漏洞: {total_vulns}")
        print(f"總利用: {total_exploited}")
        print(f"總會話: {total_sessions}")
    
    def _display_active_chains(self):
        """
        顯示活躍攻擊鏈
        """
        active_chains = self.orchestrator.get_active_chains()
        
        if not active_chains:
            print("\n沒有活躍的攻擊鏈")
            return
        
        print(f"\n=== 活躍攻擊鏈 ({len(active_chains)}) ===")
        for chain in active_chains:
            elapsed = time.time() - chain.start_time
            print(f"ID: {chain.chain_id[:8]}... | 目標: {chain.target.ip_address} | "
                  f"階段: {chain.current_phase.value} | 運行時間: {elapsed:.1f}s")
    
    def _display_completed_chains(self):
        """
        顯示已完成攻擊鏈
        """
        completed_chains = self.orchestrator.get_completed_chains()
        
        if not completed_chains:
            print("\n沒有已完成的攻擊鏈")
            return
        
        print(f"\n=== 已完成攻擊鏈 ({len(completed_chains)}) ===")
        for chain in completed_chains:
            print(f"ID: {chain.chain_id[:8]}... | 目標: {chain.target.ip_address} | "
                  f"狀態: {chain.status.value} | 持續時間: {chain.duration:.1f}s")
    
    async def cleanup(self):
        """
        清理資源
        """
        try:
            if self.framework:
                await self.framework.cleanup()
            self.logger.info("資源清理完成")
        except Exception as e:
            self.logger.error(f"清理失敗: {e}")


async def main():
    """
    主函數
    """
    parser = argparse.ArgumentParser(description="滲透測試攻擊鏈演示")
    parser.add_argument("-t", "--target", help="目標IP地址")
    parser.add_argument("-f", "--targets-file", help="目標列表文件")
    parser.add_argument("-c", "--config", help="配置文件路徑")
    parser.add_argument("-i", "--interactive", action="store_true", help="交互式模式")
    parser.add_argument("--demo-mode", action="store_true", help="演示模式（使用模擬數據）")
    
    args = parser.parse_args()
    
    demo = AttackChainDemo()
    
    try:
        # 初始化
        await demo.initialize(args.config)
        
        if args.interactive:
            # 交互式模式
            await demo.run_interactive_demo()
        
        elif args.target:
            # 單目標模式
            await demo.run_single_target_demo(args.target)
        
        elif args.targets_file:
            # 多目標模式
            if Path(args.targets_file).exists():
                with open(args.targets_file, 'r') as f:
                    targets = [line.strip() for line in f if line.strip()]
                await demo.run_multi_target_demo(targets)
            else:
                print(f"目標文件不存在: {args.targets_file}")
        
        elif args.demo_mode:
            # 演示模式
            print("運行演示模式...")
            demo_targets = ["192.168.1.100", "10.0.0.50"]
            await demo.run_multi_target_demo(demo_targets)
        
        else:
            # 默認交互式模式
            await demo.run_interactive_demo()
    
    except KeyboardInterrupt:
        print("\n程序被中斷")
    except Exception as e:
        print(f"程序執行失敗: {e}")
    finally:
        await demo.cleanup()


if __name__ == "__main__":
    # 創建報告目錄
    Path("./reports").mkdir(exist_ok=True)
    
    # 運行演示
    asyncio.run(main())