#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
滲透測試自動化框架 - 主程序
Penetration Testing Automation Framework - Main Entry Point

作者: AI Assistant
版本: 1.0.0
描述: 集成 Metasploit 和 GitHub MCP 的滲透測試自動化框架
"""

import os
import sys
import asyncio
import argparse
import json
from pathlib import Path
from typing import Dict, List, Any, Optional

# 添加項目根目錄到 Python 路徑
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from src.core.framework import PentestFramework
from src.core.config import (
    MetasploitConfig, GitHubConfig, DatabaseConfig, 
    ScanConfig, ReportConfig, SecurityConfig
)
from src.core.logger import setup_logger, get_logger
from src.database.database import DatabaseManager
from src.utils.tools import get_tool_manager, is_valid_ip, is_valid_cidr
from src.utils.progress_display import get_progress_manager


def setup_argument_parser() -> argparse.ArgumentParser:
    """
    設置命令行參數解析器
    
    Returns:
        參數解析器
    """
    parser = argparse.ArgumentParser(
        description="滲透測試自動化框架",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例用法:
  %(prog)s scan -t 192.168.1.0/24 --scan-type quick
  %(prog)s exploit -t 192.168.1.100 --auto
  %(prog)s full -t 192.168.1.0/24 --output-dir ./results
  %(prog)s report --target 192.168.1.100 --format html
        """
    )
    
    # 全局參數
    parser.add_argument(
        "-v", "--verbose",
        action="count",
        default=0,
        help="增加輸出詳細程度 (-v, -vv, -vvv)"
    )
    
    parser.add_argument(
        "--config",
        type=str,
        help="配置文件路徑"
    )
    
    parser.add_argument(
        "--log-file",
        type=str,
        help="日誌文件路徑"
    )
    
    # 子命令
    subparsers = parser.add_subparsers(dest="command", help="可用命令")
    
    # 掃描命令
    scan_parser = subparsers.add_parser("scan", help="執行網絡和漏洞掃描")
    scan_parser.add_argument("-t", "--target", required=True, help="目標 IP 或 CIDR")
    scan_parser.add_argument(
        "--scan-type", 
        choices=["quick", "comprehensive", "stealth"],
        default="quick",
        help="掃描類型"
    )
    scan_parser.add_argument("--ports", help="端口範圍 (例如: 80,443,8000-8080)")
    scan_parser.add_argument("--output-dir", help="輸出目錄")
    scan_parser.add_argument("--save-db", action="store_true", help="保存到數據庫")
    
    # 漏洞利用命令
    exploit_parser = subparsers.add_parser("exploit", help="執行漏洞利用")
    exploit_parser.add_argument("-t", "--target", required=True, help="目標 IP")
    exploit_parser.add_argument("--auto", action="store_true", help="自動選擇漏洞利用")
    exploit_parser.add_argument("--module", help="指定漏洞利用模組")
    exploit_parser.add_argument("--payload", help="指定載荷")
    exploit_parser.add_argument("--lhost", help="本地監聽地址")
    exploit_parser.add_argument("--lport", type=int, help="本地監聽端口")
    exploit_parser.add_argument("--output-dir", help="輸出目錄")
    
    # 後滲透命令
    post_parser = subparsers.add_parser("post", help="執行後滲透操作")
    post_parser.add_argument("--session-id", type=int, required=True, help="會話 ID")
    post_parser.add_argument(
        "--tasks",
        nargs="+",
        choices=["sysinfo", "privesc", "persistence", "lateral", "exfiltration"],
        default=["sysinfo"],
        help="後滲透任務"
    )
    post_parser.add_argument("--output-dir", help="輸出目錄")
    
    # 完整測試命令
    full_parser = subparsers.add_parser("full", help="執行完整滲透測試")
    full_parser.add_argument("-t", "--target", required=True, help="目標 IP 或 CIDR")
    full_parser.add_argument(
        "--scan-type", 
        choices=["quick", "comprehensive", "stealth"],
        default="comprehensive",
        help="掃描類型"
    )
    full_parser.add_argument("--auto-exploit", action="store_true", help="自動漏洞利用")
    full_parser.add_argument("--auto-post", action="store_true", help="自動後滲透")
    full_parser.add_argument("--output-dir", help="輸出目錄")
    full_parser.add_argument("--report-format", choices=["html", "pdf", "json"], default="html", help="報告格式")
    
    # 報告命令
    report_parser = subparsers.add_parser("report", help="生成報告")
    report_parser.add_argument("--target", help="目標過濾")
    report_parser.add_argument("--report-id", help="報告 ID")
    report_parser.add_argument(
        "--format", 
        choices=["html", "pdf", "json", "csv"],
        default="html",
        help="報告格式"
    )
    report_parser.add_argument("--output-dir", help="輸出目錄")
    report_parser.add_argument("--upload-github", action="store_true", help="上傳到 GitHub")
    
    # 數據庫命令
    db_parser = subparsers.add_parser("db", help="數據庫操作")
    db_subparsers = db_parser.add_subparsers(dest="db_command", help="數據庫子命令")
    
    # 數據庫統計
    db_subparsers.add_parser("stats", help="顯示數據庫統計")
    
    # 數據庫查詢
    query_parser = db_subparsers.add_parser("query", help="查詢數據")
    query_parser.add_argument("--table", choices=["scans", "vulns", "exploits", "sessions", "reports"], required=True)
    query_parser.add_argument("--target", help="目標過濾")
    query_parser.add_argument("--limit", type=int, default=10, help="限制結果數量")
    
    # 數據庫清理
    cleanup_parser = db_subparsers.add_parser("cleanup", help="清理舊數據")
    cleanup_parser.add_argument("--days", type=int, default=90, help="保留天數")
    
    # 數據庫備份
    backup_parser = db_subparsers.add_parser("backup", help="備份數據庫")
    backup_parser.add_argument("--output", required=True, help="備份文件路徑")
    
    # 工具命令
    tools_parser = subparsers.add_parser("tools", help="工具管理")
    tools_parser.add_argument("--list", action="store_true", help="列出可用工具")
    tools_parser.add_argument("--check", help="檢查特定工具")
    tools_parser.add_argument("--suggest", help="根據任務建議工具")
    
    # 配置命令
    config_parser = subparsers.add_parser("config", help="配置管理")
    config_parser.add_argument("--init", action="store_true", help="初始化配置文件")
    config_parser.add_argument("--show", action="store_true", help="顯示當前配置")
    config_parser.add_argument("--validate", action="store_true", help="驗證配置")
    
    return parser


def load_config(config_path: Optional[str] = None) -> Dict[str, Any]:
    """
    加載配置
    
    Args:
        config_path: 配置文件路徑
        
    Returns:
        配置字典
    """
    if config_path and Path(config_path).exists():
        with open(config_path, 'r', encoding='utf-8') as f:
            if config_path.endswith('.json'):
                return json.load(f)
            else:
                import yaml
                return yaml.safe_load(f)
    
    # 返回默認配置
    return {
        "metasploit": {
            "host": "localhost",
            "port": 55553,
            "username": "msf",
            "password": "msf"
        },
        "github": {
            "token": "",
            "repo": "",
            "branch": "main"
        },
        "database": {
            "type": "sqlite",
            "database": "./data/pentest.db"
        },
        "scan": {
            "default_scan_type": "quick",
            "scan_timeout": 300
        },
        "report": {
            "formats": ["html"],
            "template_dir": "./templates",
            "output_dir": "./reports"
        },
        "security": {
            "log_level": "INFO",
            "session_timeout": 3600
        }
    }


def create_configs(config_data: Dict[str, Any]) -> tuple:
    """
    創建配置對象
    
    Args:
        config_data: 配置數據
        
    Returns:
        配置對象元組
    """
    metasploit_config = MetasploitConfig(**config_data.get("metasploit", {}))
    
    # GitHub 配置參數映射
    github_data = config_data.get("github", {})
    if "repository" in github_data:
        github_data["repo"] = github_data.pop("repository")
    github_config = GitHubConfig(**github_data)
    
    # 數據庫配置參數映射
    database_data = config_data.get("database", {})
    if "db_type" in database_data:
        database_data["type"] = database_data.pop("db_type")
    if "database_url" in database_data:
        database_data["database"] = database_data.pop("database_url")
    database_config = DatabaseConfig(**database_data)
    
    # 掃描配置參數映射
    scan_data = config_data.get("scan", {})
    if "scan_type" in scan_data:
        scan_data["default_scan_type"] = scan_data.pop("scan_type")
    if "timeout" in scan_data:
        scan_data["scan_timeout"] = scan_data.pop("timeout")
    scan_config = ScanConfig(**scan_data)
    
    # 報告配置參數映射
    report_data = config_data.get("report", {})
    if "output_format" in report_data:
        report_data["formats"] = [report_data.pop("output_format")]
    report_config = ReportConfig(**report_data)
    
    security_config = SecurityConfig(**config_data.get("security", {}))
    
    return (
        metasploit_config, github_config, database_config,
        scan_config, report_config, security_config
    )


async def handle_scan_command(args, framework: PentestFramework):
    """
    處理掃描命令
    
    Args:
        args: 命令行參數
        framework: 框架實例
    """
    logger = get_logger()
    progress_manager = get_progress_manager()
    
    # 驗證目標
    if not (is_valid_ip(args.target) or is_valid_cidr(args.target)):
        logger.error(f"無效的目標: {args.target}")
        return
    
    logger.info(f"開始掃描目標: {args.target}")
    
    # 創建總體進度條
    progress_bar = progress_manager.create_progress_bar(
        "main_scan", 
        total=5, 
        prefix="掃描進度",
        show_time=True
    )
    
    try:
        # 初始化掃描
        progress_bar.update(1, "初始化掃描...")
        
        # 執行網絡掃描
        progress_bar.update(2, "執行網絡掃描...")
        scan_result = await framework.network_scan(
            target=args.target,
            scan_type=args.scan_type,
            ports=args.ports
        )
        
        if scan_result:
            logger.info(f"網絡掃描完成，發現 {len(scan_result.hosts)} 個主機")
            
            # 執行漏洞掃描
            progress_bar.update(3, "執行漏洞掃描...")
            vuln_result = await framework.vulnerability_scan(args.target)
            
            if vuln_result:
                logger.info(f"漏洞掃描完成，發現 {vuln_result.total_vulnerabilities} 個漏洞")
            
            # 保存到數據庫
            progress_bar.update(4, "保存掃描結果...")
            if args.save_db:
                framework.database.save_scan_result(scan_result)
                if vuln_result:
                    framework.database.save_vulnerability_result(vuln_result)
            
            # 保存結果文件
            progress_bar.update(5, "生成報告文件...")
            if args.output_dir:
                output_dir = Path(args.output_dir)
                output_dir.mkdir(parents=True, exist_ok=True)
                
                # 保存掃描結果
                scan_file = output_dir / f"scan_{args.target.replace('/', '_')}.json"
                with open(scan_file, 'w', encoding='utf-8') as f:
                    json.dump(scan_result.__dict__, f, indent=2, default=str)
                
                # 保存漏洞結果
                if vuln_result:
                    vuln_file = output_dir / f"vulns_{args.target.replace('/', '_')}.json"
                    with open(vuln_file, 'w', encoding='utf-8') as f:
                        json.dump(vuln_result.__dict__, f, indent=2, default=str)
                
                logger.info(f"結果已保存到: {output_dir}")
            
            progress_bar.finish("掃描完成")
        else:
            progress_bar.finish("掃描失敗")
            logger.error("掃描失敗")
    
    except Exception as e:
        # 確保進度條正確結束
        progress_bar = progress_manager.get_progress_bar("main_scan")
        if progress_bar:
            progress_bar.finish(f"掃描失敗: {str(e)}")
        logger.error(f"掃描執行失敗: {str(e)}")
    finally:
        # 清理進度顯示器
        progress_manager.cleanup()


async def handle_exploit_command(args, framework: PentestFramework):
    """
    處理漏洞利用命令
    
    Args:
        args: 命令行參數
        framework: 框架實例
    """
    logger = get_logger()
    
    # 驗證目標
    if not is_valid_ip(args.target):
        logger.error(f"無效的目標 IP: {args.target}")
        return
    
    logger.info(f"開始漏洞利用目標: {args.target}")
    
    # 準備漏洞利用選項
    exploit_options = {}
    if args.lhost:
        exploit_options["LHOST"] = args.lhost
    if args.lport:
        exploit_options["LPORT"] = args.lport
    
    if args.auto:
        # 自動漏洞利用
        # 首先執行漏洞掃描
        vuln_result = await framework.vulnerability_scan(args.target)
        if vuln_result and vuln_result.results:
            exploit_result = await framework.exploit_vulnerabilities(
                target=args.target,
                vulnerabilities=vuln_result.results
            )
            
            if exploit_result:
                successful = sum(1 for attempt in exploit_result.attempts if attempt.success)
                logger.info(f"漏洞利用完成，成功 {successful}/{len(exploit_result.attempts)} 次嘗試")
                
                # 保存結果
                if args.output_dir:
                    output_dir = Path(args.output_dir)
                    output_dir.mkdir(parents=True, exist_ok=True)
                    
                    exploit_file = output_dir / f"exploit_{args.target}.json"
                    with open(exploit_file, 'w', encoding='utf-8') as f:
                        json.dump(exploit_result.__dict__, f, indent=2, default=str)
                    
                    logger.info(f"漏洞利用結果已保存到: {exploit_file}")
            else:
                logger.error("漏洞利用失敗")
        else:
            logger.warning("未發現可利用的漏洞")
    else:
        # 手動指定漏洞利用
        if not args.module:
            logger.error("請指定漏洞利用模組 (--module)")
            return
        
        # 這裡可以實現手動漏洞利用邏輯
        logger.info(f"手動漏洞利用功能待實現: {args.module}")


async def handle_post_command(args, framework: PentestFramework):
    """
    處理後滲透命令
    
    Args:
        args: 命令行參數
        framework: 框架實例
    """
    logger = get_logger()
    
    logger.info(f"開始後滲透操作，會話 ID: {args.session_id}")
    
    # 執行後滲透任務
    post_result = await framework.post_exploitation(
        session_id=args.session_id,
        tasks=args.tasks
    )
    
    if post_result:
        completed_tasks = [task for task in post_result if task.status.value == "completed"]
        logger.info(f"後滲透操作完成，成功執行 {len(completed_tasks)}/{len(post_result)} 個任務")
        
        # 保存結果
        if args.output_dir:
            output_dir = Path(args.output_dir)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            post_file = output_dir / f"post_exploit_session_{args.session_id}.json"
            with open(post_file, 'w', encoding='utf-8') as f:
                json.dump([task.__dict__ for task in post_result], f, indent=2, default=str)
            
            logger.info(f"後滲透結果已保存到: {post_file}")
    else:
        logger.error("後滲透操作失敗")


async def handle_full_command(args, framework: PentestFramework):
    """
    處理完整測試命令
    
    Args:
        args: 命令行參數
        framework: 框架實例
    """
    logger = get_logger()
    progress_manager = get_progress_manager()
    
    # 驗證目標
    if not (is_valid_ip(args.target) or is_valid_cidr(args.target)):
        logger.error(f"無效的目標: {args.target}")
        return
    
    logger.info(f"開始完整滲透測試: {args.target}")
    
    # 創建總體進度條
    progress_bar = progress_manager.create_progress_bar(
        "full_pentest", 
        total=3, 
        prefix="完整測試進度",
        show_time=True
    )
    
    try:
        # 初始化測試
        progress_bar.update(1, "初始化完整滲透測試...")
        
        # 執行完整測試
        progress_bar.update(2, "執行滲透測試...")
        report = await framework.full_pentest(
            target=args.target,
            scan_type=args.scan_type,
            auto_exploit=args.auto_exploit,
            auto_post_exploit=args.auto_post
        )
        
        if report:
            logger.info(f"完整滲透測試完成，報告 ID: {report.report_id}")
            
            # 生成報告文件
            progress_bar.update(3, "生成測試報告...")
            if args.output_dir:
                output_dir = Path(args.output_dir)
                output_dir.mkdir(parents=True, exist_ok=True)
                
                report_file = await framework.generate_report(
                    report=report,
                    output_format=args.report_format,
                    output_dir=str(output_dir)
                )
                
                if report_file:
                    logger.info(f"報告已生成: {report_file}")
            
            progress_bar.finish("完整滲透測試完成")
        else:
            progress_bar.finish("完整滲透測試失敗")
            logger.error("完整滲透測試失敗")
    
    except Exception as e:
        # 確保進度條正確結束
        progress_bar = progress_manager.get_progress_bar("full_pentest")
        if progress_bar:
            progress_bar.finish(f"測試失敗: {str(e)}")
        logger.error(f"完整滲透測試失敗: {str(e)}")
    finally:
        # 清理進度顯示器
        progress_manager.cleanup()


def handle_db_command(args, database: DatabaseManager):
    """
    處理數據庫命令
    
    Args:
        args: 命令行參數
        database: 數據庫管理器
    """
    logger = get_logger()
    
    if args.db_command == "stats":
        stats = database.get_statistics()
        print("\n=== 數據庫統計 ===")
        print(f"總掃描次數: {stats.total_scans}")
        print(f"總漏洞數量: {stats.total_vulnerabilities}")
        print(f"總利用次數: {stats.total_exploits}")
        print(f"活躍會話數: {stats.total_sessions}")
        print(f"總報告數量: {stats.total_reports}")
        print(f"數據庫大小: {stats.database_size / 1024 / 1024:.2f} MB")
        
    elif args.db_command == "query":
        if args.table == "scans":
            results = database.get_scan_results(target=args.target, limit=args.limit)
        elif args.table == "vulns":
            results = database.get_vulnerability_results(target=args.target, limit=args.limit)
        elif args.table == "exploits":
            results = database.get_exploit_reports(target=args.target, limit=args.limit)
        elif args.table == "sessions":
            results = database.get_active_sessions()
        elif args.table == "reports":
            results = database.get_pentest_reports(target=args.target, limit=args.limit)
        else:
            logger.error(f"未知的表: {args.table}")
            return
        
        print(f"\n=== {args.table.upper()} 查詢結果 ===")
        for i, result in enumerate(results, 1):
            print(f"{i}. {json.dumps(result, indent=2, default=str)}")
            if i >= args.limit:
                break
    
    elif args.db_command == "cleanup":
        database.cleanup_old_data(days=args.days)
        logger.info(f"已清理 {args.days} 天前的舊數據")
    
    elif args.db_command == "backup":
        success = database.backup_database(args.output)
        if success:
            logger.info(f"數據庫備份完成: {args.output}")
        else:
            logger.error("數據庫備份失敗")


def handle_tools_command(args):
    """
    處理工具命令
    
    Args:
        args: 命令行參數
    """
    tool_manager = get_tool_manager()
    
    if args.list:
        print("\n=== 可用工具 ===")
        for tool in tool_manager.get_available_tools():
            print(f"- {tool.name} ({tool.version}) - {tool.description}")
    
    elif args.check:
        tool = tool_manager.get_tool(args.check)
        if tool:
            status = "可用" if tool.available else "不可用"
            print(f"工具: {tool.name}")
            print(f"版本: {tool.version}")
            print(f"路徑: {tool.path}")
            print(f"狀態: {status}")
            print(f"描述: {tool.description}")
        else:
            print(f"未找到工具: {args.check}")
    
    elif args.suggest:
        suggestions = tool_manager.get_tool_suggestions(args.suggest)
        print(f"\n=== 任務 '{args.suggest}' 的工具建議 ===")
        for tool_name in suggestions:
            tool = tool_manager.get_tool(tool_name)
            if tool:
                print(f"- {tool.name} - {tool.description}")


def handle_config_command(args, config_data: Dict[str, Any]):
    """
    處理配置命令
    
    Args:
        args: 命令行參數
        config_data: 配置數據
    """
    if args.init:
        config_file = Path("config.yaml")
        if config_file.exists():
            print(f"配置文件已存在: {config_file}")
        else:
            import yaml
            with open(config_file, 'w', encoding='utf-8') as f:
                yaml.dump(config_data, f, default_flow_style=False, allow_unicode=True)
            print(f"配置文件已創建: {config_file}")
    
    elif args.show:
        print("\n=== 當前配置 ===")
        print(json.dumps(config_data, indent=2, ensure_ascii=False))
    
    elif args.validate:
        # 驗證配置
        try:
            create_configs(config_data)
            print("配置驗證通過")
        except Exception as e:
            print(f"配置驗證失敗: {e}")


async def main():
    """
    主函數
    """
    # 解析命令行參數
    parser = setup_argument_parser()
    args = parser.parse_args()
    
    # 設置日誌級別
    log_level = "DEBUG" if args.verbose >= 2 else "INFO" if args.verbose >= 1 else "WARNING"
    config = {'level': log_level}
    if args.log_file:
        config['log_file'] = args.log_file
    setup_logger(config=config)
    
    logger = get_logger()
    logger.info("滲透測試自動化框架啟動")
    
    # 加載配置
    config_data = load_config(args.config)
    
    # 處理配置命令
    if args.command == "config":
        handle_config_command(args, config_data)
        return
    
    # 處理工具命令
    if args.command == "tools":
        handle_tools_command(args)
        return
    
    # 創建配置對象
    try:
        configs = create_configs(config_data)
        metasploit_config, github_config, database_config, scan_config, report_config, security_config = configs
    except Exception as e:
        logger.error(f"配置創建失敗: {e}")
        return
    
    # 創建數據庫管理器
    database = DatabaseManager(database_config)
    
    # 處理數據庫命令
    if args.command == "db":
        handle_db_command(args, database)
        return
    
    # 創建框架實例
    try:
        framework = PentestFramework(
            metasploit_config=metasploit_config,
            github_config=github_config,
            database_config=database_config,
            scan_config=scan_config,
            report_config=report_config,
            security_config=security_config
        )
        
        # 初始化框架
        await framework.initialize()
        
        # 處理不同命令
        if args.command == "scan":
            await handle_scan_command(args, framework)
        elif args.command == "exploit":
            await handle_exploit_command(args, framework)
        elif args.command == "post":
            await handle_post_command(args, framework)
        elif args.command == "full":
            await handle_full_command(args, framework)
        elif args.command == "report":
            # 處理報告生成
            logger.info("報告生成功能待實現")
        else:
            parser.print_help()
        
        # 清理資源
        await framework.cleanup()
        
    except Exception as e:
        logger.error(f"框架運行失敗: {e}")
        if args.verbose >= 2:
            import traceback
            traceback.print_exc()
    finally:
        database.close()
        logger.info("滲透測試自動化框架結束")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n用戶中斷操作")
    except Exception as e:
        print(f"程序異常退出: {e}")
        sys.exit(1)