#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
滲透測試自動化框架核心模組
Pentest Automation Framework Core Module

整合 Metasploit MCP 和 GitHub MCP 的主要框架類
"""

import asyncio
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

from ..integrations.metasploit_mcp import MetasploitMCP
from ..integrations.github_mcp import GitHubMCP
from ..utils.report_generator import ReportGenerator
from ..utils.target_manager import TargetManager
from ..utils.progress_display import get_progress_manager, ProgressBar, SpinnerDisplay
from ..scanners.vulnerability_scanner import VulnerabilityScanner
from ..scanners.network_scanner import NetworkScanner
from ..database.database import DatabaseManager
from .config import Config
from .logger import setup_logger


class PentestFramework:
    """
    滲透測試自動化框架主類
    
    整合 Metasploit 和 GitHub MCP，提供完整的滲透測試自動化流程
    """
    
    def __init__(self, 
                 config_path: Optional[str] = None,
                 metasploit_config=None,
                 github_config=None,
                 database_config=None,
                 scan_config=None,
                 report_config=None,
                 security_config=None):
        """
        初始化框架
        
        Args:
            config_path: 配置文件路徑
            metasploit_config: Metasploit 配置對象
            github_config: GitHub 配置對象
            database_config: 數據庫配置對象
            scan_config: 掃描配置對象
            report_config: 報告配置對象
            security_config: 安全配置對象
        """
        # 如果提供了配置對象，使用它們；否則從配置文件加載
        if all([metasploit_config, github_config, database_config, scan_config, report_config, security_config]):
            # 創建一個簡化的配置對象來存儲各個配置
            class SimpleConfig:
                def __init__(self, metasploit_config, github_config, database_config, scan_config, report_config, security_config):
                    self.metasploit_config = metasploit_config
                    self.github_config = github_config
                    self.database_config = database_config
                    self.scan_config = scan_config
                    self.report_config = report_config
                    self.security_config = security_config
                    
                    # 創建一個字典來支持 'in' 操作符和字典式訪問
                    self._config_dict = {
                        'metasploit': metasploit_config,
                        'github': github_config,
                        'database': database_config,
                        'scan': scan_config,
                        'report': report_config,
                        'security': security_config
                    }
                
                def __contains__(self, key):
                    """支持 'in' 操作符"""
                    return key in self._config_dict
                
                def __getitem__(self, key):
                    """支持字典式訪問"""
                    return self._config_dict[key]
                
                def __setitem__(self, key, value):
                    """支持字典式設置"""
                    self._config_dict[key] = value
                
                def get(self, key, default=None):
                    """支持 get 方法"""
                    return self._config_dict.get(key, default)
                
                def items(self):
                    """支持 items 方法"""
                    return self._config_dict.items()
                
                def keys(self):
                    """支持 keys 方法"""
                    return self._config_dict.keys()
                
                def values(self):
                    """支持 values 方法"""
                    return self._config_dict.values()
            
            self.config = SimpleConfig(metasploit_config, github_config, database_config, scan_config, report_config, security_config)
        else:
            self.config = Config(config_path)
        
        self.logger = setup_logger("PentestFramework")
        
        # 初始化 MCP 整合
        # 安全地獲取配置對象
        metasploit_config = getattr(self.config, 'metasploit_config', None)
        if metasploit_config is None:
            metasploit_config = self.config.get('metasploit', {})
        
        github_config = getattr(self.config, 'github_config', None)
        if github_config is None:
            github_config = self.config.get('github', {})
            
        self.metasploit = MetasploitMCP(metasploit_config)
        self.github = GitHubMCP(github_config)
        
        # 初始化工具模組
        # 確保傳遞字典而不是配置對象給 ReportGenerator
        report_config = self.config.get('report', {})
        if hasattr(report_config, '__dict__'):
            # 如果是配置對象，轉換為字典
            report_config = report_config.__dict__
        self.report_generator = ReportGenerator(report_config)
        
        # 確保傳遞字典而不是配置對象給 TargetManager
        target_config = {}
        if hasattr(self.config, '__dict__'):
            # 如果是配置對象，提取相關配置
            target_config = getattr(self.config, 'scan_config', {})
            if hasattr(target_config, '__dict__'):
                target_config = target_config.__dict__
        self.target_manager = TargetManager(target_config)
        
        # 確保傳遞字典而不是配置對象給 VulnerabilityScanner
        scan_config = self.config.get('scan', {})
        if hasattr(scan_config, '__dict__'):
            # 如果是配置對象，轉換為字典
            scan_config = scan_config.__dict__
        self.vulnerability_scanner = VulnerabilityScanner(scan_config)
        
        # 初始化網絡掃描器
        self.network_scanner = NetworkScanner(scan_config)
        
        # 確保傳遞正確的 DatabaseConfig 對象給 DatabaseManager
        db_config = self.config.get('database', {})
        if hasattr(db_config, '__dict__'):
            # 如果已經是配置對象，直接使用
            self.database = DatabaseManager(db_config)
        else:
            # 如果是字典，創建 DatabaseConfig 對象
            from .config import DatabaseConfig
            database_config = DatabaseConfig(
                type=db_config.get('type', 'sqlite'),
                host=db_config.get('host', 'localhost'),
                port=db_config.get('port', 5432),
                name=db_config.get('name', 'pentest.db'),
                username=db_config.get('username', ''),
                password=db_config.get('password', ''),
                pool_size=db_config.get('pool_size', 10),
                timeout=db_config.get('timeout', 30)
            )
            self.database = DatabaseManager(database_config)
        
        # 測試結果存儲
        self.results = {
            'scan_results': [],
            'vulnerabilities': [],
            'exploits': [],
            'sessions': [],
            'reports': []
        }
        
        self.logger.info("滲透測試自動化框架初始化完成")
    
    async def initialize(self):
        """
        異步初始化框架組件
        """
        try:
            # 初始化 MCP 連接
            await self.metasploit.initialize()
            
            # 初始化其他組件
            self.logger.info("框架組件初始化完成")
            
        except Exception as e:
            self.logger.error(f"框架初始化失敗: {e}")
            raise
    
    async def cleanup(self):
        """
        清理框架資源
        """
        try:
            # 清理 MCP 連接
            if hasattr(self.metasploit, 'cleanup'):
                await self.metasploit.cleanup()
            
            self.logger.info("框架資源清理完成")
            
        except Exception as e:
            self.logger.error(f"框架清理失敗: {e}")
    
    async def run_automated_pentest(
        self,
        targets: List[str],
        scan_type: str = 'comprehensive',
        generate_report: bool = True,
        upload_to_github: bool = False
    ) -> Dict[str, Any]:
        """
        執行自動化滲透測試
        
        Args:
            targets: 目標列表
            scan_type: 掃描類型 ('quick', 'comprehensive', 'stealth')
            generate_report: 是否生成報告
            upload_to_github: 是否上傳到 GitHub
            
        Returns:
            測試結果字典
        """
        progress_manager = get_progress_manager()
        progress_bar = None
        
        self.logger.info(f"開始自動化滲透測試，目標: {targets}")
        
        try:
            # 創建總體進度條
            total_steps = 6 + (1 if generate_report else 0) + (1 if upload_to_github and generate_report else 0)
            progress_bar = progress_manager.create_progress_bar(
                "automated_pentest", 
                total=total_steps, 
                prefix="滲透測試進度",
                show_time=True
            )
            
            # 1. 目標驗證和準備
            progress_bar.update(1, "驗證目標...")
            validated_targets = await self._validate_targets(targets)
            
            # 2. 網絡掃描
            progress_bar.update(2, "執行網絡掃描...")
            scan_results = await self._perform_network_scan(
                validated_targets, scan_type
            )
            
            # 3. 漏洞掃描
            progress_bar.update(3, "執行漏洞掃描...")
            vulnerabilities = await self._perform_vulnerability_scan(
                scan_results
            )
            
            # 4. 漏洞利用
            progress_bar.update(4, "執行漏洞利用...")
            exploit_results = await self._perform_exploitation(
                vulnerabilities
            )
            
            # 5. 後滲透
            progress_bar.update(5, "執行後滲透測試...")
            post_exploit_results = await self._perform_post_exploitation(
                exploit_results
            )
            
            # 6. 結果整理
            progress_bar.update(6, "整理測試結果...")
            final_results = self._compile_results(
                scan_results,
                vulnerabilities,
                exploit_results,
                post_exploit_results
            )
            
            current_step = 6
            
            # 7. 報告生成
            if generate_report:
                current_step += 1
                progress_bar.update(current_step, "生成測試報告...")
                report_path = await self._generate_report(final_results)
                final_results['report_path'] = report_path
            
            # 8. GitHub 上傳
            if upload_to_github and generate_report:
                current_step += 1
                progress_bar.update(current_step, "上傳到 GitHub...")
                github_url = await self._upload_to_github(
                    final_results, report_path
                )
                final_results['github_url'] = github_url
            
            progress_bar.finish("滲透測試完成")
            
            self.logger.info("自動化滲透測試完成")
            return final_results
            
        except Exception as e:
            if progress_bar:
                progress_bar.finish(f"測試失敗: {str(e)}")
            
            self.logger.error(f"滲透測試執行失敗: {str(e)}")
            raise
    
    async def _validate_targets(self, targets: List[str]) -> List[Dict]:
        """
        驗證和準備目標
        """
        self.logger.info("驗證目標列表")
        return await self.target_manager.validate_targets(targets)
    
    async def _perform_network_scan(
        self, targets: List[Dict], scan_type: str
    ) -> List[Dict]:
        """
        執行網絡掃描
        """
        self.logger.info(f"執行 {scan_type} 網絡掃描")
        
        scan_results = []
        for target in targets:
            # 使用 Metasploit 輔助模組進行掃描
            result = await self.metasploit.run_auxiliary_scan(
                target['ip'], scan_type
            )
            scan_results.append(result)
        
        self.results['scan_results'] = scan_results
        return scan_results
    
    async def _perform_vulnerability_scan(
        self, scan_results: List[Dict]
    ) -> List[Dict]:
        """
        執行漏洞掃描
        """
        self.logger.info("執行漏洞掃描")
        
        vulnerabilities = []
        for scan_result in scan_results:
            # 基於掃描結果識別潛在漏洞
            vulns = await self.metasploit.identify_vulnerabilities(
                scan_result
            )
            vulnerabilities.extend(vulns)
        
        self.results['vulnerabilities'] = vulnerabilities
        return vulnerabilities
    
    async def _perform_exploitation(
        self, vulnerabilities: List[Dict]
    ) -> List[Dict]:
        """
        執行漏洞利用
        """
        self.logger.info("執行漏洞利用")
        
        exploit_results = []
        for vuln in vulnerabilities:
            if vuln.get('exploitable', False):
                result = await self.metasploit.exploit_vulnerability(vuln)
                exploit_results.append(result)
        
        self.results['exploits'] = exploit_results
        return exploit_results
    
    async def _perform_post_exploitation(
        self, exploit_results: List[Dict]
    ) -> List[Dict]:
        """
        執行後滲透操作
        """
        self.logger.info("執行後滲透操作")
        
        post_exploit_results = []
        for exploit in exploit_results:
            if exploit.get('session_id'):
                result = await self.metasploit.run_post_exploitation(
                    exploit['session_id']
                )
                post_exploit_results.append(result)
        
        return post_exploit_results
    
    def _compile_results(
        self,
        scan_results: List[Dict],
        vulnerabilities: List[Dict],
        exploit_results: List[Dict],
        post_exploit_results: List[Dict]
    ) -> Dict[str, Any]:
        """
        整理測試結果
        """
        return {
            'timestamp': datetime.now().isoformat(),
            'scan_results': scan_results,
            'vulnerabilities': vulnerabilities,
            'exploit_results': exploit_results,
            'post_exploit_results': post_exploit_results,
            'summary': {
                'targets_scanned': len(scan_results),
                'vulnerabilities_found': len(vulnerabilities),
                'successful_exploits': len([
                    e for e in exploit_results if e.get('success')
                ]),
                'sessions_created': len([
                    e for e in exploit_results if e.get('session_id')
                ])
            }
        }
    
    async def _generate_report(self, results: Dict[str, Any]) -> str:
        """
        生成測試報告
        """
        self.logger.info("生成滲透測試報告")
        return await self.report_generator.generate_report(results)
    
    async def _upload_to_github(
        self, results: Dict[str, Any], report_path: str
    ) -> str:
        """
        上傳結果到 GitHub
        """
        self.logger.info("上傳結果到 GitHub")
        return await self.github.upload_pentest_results(
            results, report_path
        )
    
    def get_active_sessions(self) -> List[Dict]:
        """
        獲取活躍會話列表
        """
        return self.metasploit.get_active_sessions()
    
    async def network_scan(self, target: str, scan_type: str = "comprehensive", 
                          ports: Optional[str] = None, **kwargs) -> Any:
        """
        執行網絡掃描
        
        Args:
            target: 目標 IP、域名或 CIDR
            scan_type: 掃描類型 ('quick', 'comprehensive', 'stealth')
            ports: 端口範圍
            **kwargs: 其他參數
            
        Returns:
            掃描結果
        """
        progress_manager = get_progress_manager()
        spinner = None
        
        self.logger.info(f"開始網絡掃描目標: {target}")
        
        try:
            # 創建旋轉器顯示掃描進度
            spinner = progress_manager.create_spinner(
                "network_scan",
                message=f"掃描 {target}..."
            )
            
            # 使用網絡掃描器執行掃描
            scan_result = await self.network_scanner.scan_network(
                target=target,
                scan_type=scan_type,
                ports=ports,
                **kwargs
            )
            
            spinner.stop(f"網絡掃描完成，發現 {len(scan_result.hosts)} 個主機")
            
            self.logger.info(f"網絡掃描完成，發現 {len(scan_result.hosts)} 個主機")
            return scan_result
            
        except Exception as e:
            if spinner:
                spinner.stop(f"網絡掃描失敗: {e}")
            
            self.logger.error(f"網絡掃描失敗: {e}")
            raise
    
    async def vulnerability_scan(self, target: str, scan_profile: str = "comprehensive") -> Any:
        """
        執行漏洞掃描
        
        Args:
            target: 目標 IP 或域名
            scan_profile: 掃描配置文件 ('quick', 'comprehensive', 'web', 'database')
            
        Returns:
            漏洞掃描報告
        """
        progress_manager = get_progress_manager()
        spinner = None
        
        self.logger.info(f"開始漏洞掃描目標: {target}")
        
        try:
            # 創建旋轉器顯示掃描進度
            spinner = progress_manager.create_spinner(
                "vulnerability_scan",
                message=f"掃描 {target} 漏洞..."
            )
            
            # 使用漏洞掃描器執行掃描
            scan_result = await self.vulnerability_scanner.scan_vulnerabilities(
                target=target,
                scan_profile=scan_profile
            )
            
            spinner.stop(f"漏洞掃描完成，發現 {scan_result.total_vulnerabilities} 個漏洞")
            
            self.logger.info(f"漏洞掃描完成，發現 {scan_result.total_vulnerabilities} 個漏洞")
            return scan_result
            
        except Exception as e:
            if spinner:
                spinner.stop(f"漏洞掃描失敗: {e}")
            
            self.logger.error(f"漏洞掃描失敗: {e}")
            raise
    
    async def exploit_vulnerabilities(self, target: str, vulnerabilities: List[Any]) -> Any:
        """
        利用發現的漏洞
        
        Args:
            target: 目標 IP 或域名
            vulnerabilities: 漏洞列表
            
        Returns:
            利用結果
        """
        self.logger.info(f"開始利用 {len(vulnerabilities)} 個漏洞")
        
        try:
            # 這裡應該實現漏洞利用邏輯
            # 暫時返回一個基本結構
            from dataclasses import dataclass
            from typing import List as TypingList
            
            @dataclass
            class ExploitAttempt:
                vulnerability_id: str
                success: bool
                session_id: Optional[str] = None
                error: Optional[str] = None
            
            @dataclass
            class ExploitResult:
                target: str
                attempts: TypingList[ExploitAttempt]
            
            attempts = []
            for vuln in vulnerabilities:
                # 模擬利用嘗試
                attempt = ExploitAttempt(
                    vulnerability_id=getattr(vuln, 'vuln_id', 'unknown'),
                    success=False,  # 實際實現中應該嘗試利用
                    error="利用功能尚未完全實現"
                )
                attempts.append(attempt)
            
            result = ExploitResult(target=target, attempts=attempts)
            self.logger.info(f"漏洞利用完成")
            return result
            
        except Exception as e:
            self.logger.error(f"漏洞利用失敗: {e}")
            raise
    
    async def cleanup(self):
        """
        清理框架資源
        """
        self.logger.info("清理框架資源")
        await self.metasploit.cleanup()
        await self.github.cleanup()