#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
攻擊鏈協調器
Attack Chain Orchestrator

協調完整的滲透測試攻擊鏈流程
"""

import asyncio
import json
import time
import uuid
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum

from .logger import get_logger
from .framework import PentestFramework
from ..scanners.reconnaissance import ReconnaissanceScanner, ReconResult
from ..scanners.network_scanner import NetworkScanner, ScanResult
from ..scanners.vulnerability_scanner import VulnerabilityScanner, VulnerabilityResult
from ..exploits.exploit_manager import ExploitManager, ExploitReport
from ..post_exploit.post_exploit import PostExploitManager, PostExploitTask, PostExploitTaskType
from ..utils.report_generator import ReportGenerator, PentestReport
from ..integrations.mcp_client import MetasploitMCPClient


class AttackPhase(Enum):
    """
    攻擊階段
    """
    RECONNAISSANCE = "reconnaissance"
    SCANNING = "scanning"
    VULNERABILITY_ASSESSMENT = "vulnerability_assessment"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    REPORTING = "reporting"
    COMPLETED = "completed"
    FAILED = "failed"


class AttackChainStatus(Enum):
    """
    攻擊鏈狀態
    """
    INITIALIZED = "initialized"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class AttackTarget:
    """
    攻擊目標
    """
    target_id: str
    ip_address: str
    hostname: Optional[str] = None
    domain: Optional[str] = None
    ports: List[int] = field(default_factory=list)
    services: Dict[int, str] = field(default_factory=dict)
    os_info: Optional[str] = None
    vulnerabilities: List[VulnerabilityResult] = field(default_factory=list)
    exploited: bool = False
    sessions: List[int] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AttackChainConfig:
    """
    攻擊鏈配置
    """
    # 偵察配置
    enable_reconnaissance: bool = True
    recon_depth: str = "basic"  # basic, intermediate, deep
    
    # 掃描配置
    scan_type: str = "comprehensive"  # quick, standard, comprehensive
    port_range: str = "1-65535"
    scan_timeout: int = 300
    
    # 漏洞評估配置
    vulnerability_scan: bool = True
    min_severity: str = "medium"  # low, medium, high, critical
    
    # 利用配置
    auto_exploit: bool = True
    max_exploit_attempts: int = 3
    exploit_timeout: int = 180
    safe_mode: bool = True
    
    # 後滲透配置
    post_exploit_tasks: List[PostExploitTaskType] = field(default_factory=lambda: [
        PostExploitTaskType.SYSTEM_INFO,
        PostExploitTaskType.CREDENTIAL_HARVESTING,
        PostExploitTaskType.NETWORK_DISCOVERY
    ])
    
    # 報告配置
    report_format: List[str] = field(default_factory=lambda: ["html", "json"])
    include_screenshots: bool = True
    
    # 通用配置
    max_concurrent_operations: int = 5
    operation_timeout: int = 600
    cleanup_on_completion: bool = True


@dataclass
class AttackChainResult:
    """
    攻擊鏈結果
    """
    chain_id: str
    target: AttackTarget
    status: AttackChainStatus
    current_phase: AttackPhase
    start_time: float
    end_time: Optional[float] = None
    duration: Optional[float] = None
    
    # 各階段結果
    recon_results: List[ReconResult] = field(default_factory=list)
    scan_results: List[ScanResult] = field(default_factory=list)
    vulnerability_results: List[VulnerabilityResult] = field(default_factory=list)
    exploit_report: Optional[ExploitReport] = None
    post_exploit_tasks: List[PostExploitTask] = field(default_factory=list)
    
    # 統計信息
    total_vulnerabilities: int = 0
    exploited_vulnerabilities: int = 0
    active_sessions: int = 0
    collected_data_count: int = 0
    
    # 錯誤和警告
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    
    # 報告路徑
    report_paths: List[str] = field(default_factory=list)


class AttackChainOrchestrator:
    """
    攻擊鏈協調器
    
    協調完整的滲透測試攻擊鏈
    """
    
    def __init__(self, framework: PentestFramework, config: Optional[AttackChainConfig] = None):
        """
        初始化攻擊鏈協調器
        
        Args:
            framework: 滲透測試框架實例
            config: 攻擊鏈配置
        """
        self.framework = framework
        self.config = config or AttackChainConfig()
        self.logger = get_logger()
        
        # 初始化各個模組
        self.recon_scanner = ReconnaissanceScanner()
        self.network_scanner = NetworkScanner()
        self.vuln_scanner = VulnerabilityScanner()
        self.exploit_manager = ExploitManager(framework.mcp_client)
        self.post_exploit_manager = PostExploitManager(framework.mcp_client)
        self.report_generator = ReportGenerator()
        
        # 內部狀態
        self.active_chains: Dict[str, AttackChainResult] = {}
        self.completed_chains: List[AttackChainResult] = []
        
    async def execute_attack_chain(self, target_ip: str, **kwargs) -> AttackChainResult:
        """
        執行完整攻擊鏈
        
        Args:
            target_ip: 目標IP地址
            **kwargs: 額外參數
            
        Returns:
            攻擊鏈結果
        """
        chain_id = str(uuid.uuid4())
        target = AttackTarget(
            target_id=str(uuid.uuid4()),
            ip_address=target_ip
        )
        
        result = AttackChainResult(
            chain_id=chain_id,
            target=target,
            status=AttackChainStatus.INITIALIZED,
            current_phase=AttackPhase.RECONNAISSANCE,
            start_time=time.time()
        )
        
        self.active_chains[chain_id] = result
        
        try:
            self.logger.info(f"開始執行攻擊鏈: {chain_id} -> {target_ip}")
            result.status = AttackChainStatus.RUNNING
            
            # 階段1: 偵察
            if self.config.enable_reconnaissance:
                await self._execute_reconnaissance_phase(result)
            
            # 階段2: 掃描
            await self._execute_scanning_phase(result)
            
            # 階段3: 漏洞評估
            if self.config.vulnerability_scan:
                await self._execute_vulnerability_assessment_phase(result)
            
            # 階段4: 漏洞利用
            if self.config.auto_exploit and result.vulnerability_results:
                await self._execute_exploitation_phase(result)
            
            # 階段5: 後滲透
            if result.exploit_report and result.exploit_report.active_sessions > 0:
                await self._execute_post_exploitation_phase(result)
            
            # 階段6: 報告生成
            await self._execute_reporting_phase(result)
            
            result.status = AttackChainStatus.COMPLETED
            result.current_phase = AttackPhase.COMPLETED
            
        except Exception as e:
            self.logger.error(f"攻擊鏈執行失敗: {e}")
            result.status = AttackChainStatus.FAILED
            result.current_phase = AttackPhase.FAILED
            result.errors.append(str(e))
        
        finally:
            result.end_time = time.time()
            result.duration = result.end_time - result.start_time
            
            # 移動到完成列表
            if chain_id in self.active_chains:
                del self.active_chains[chain_id]
            self.completed_chains.append(result)
            
            # 清理
            if self.config.cleanup_on_completion:
                await self._cleanup_attack_chain(result)
        
        return result
    
    async def _execute_reconnaissance_phase(self, result: AttackChainResult):
        """
        執行偵察階段
        """
        self.logger.info(f"開始偵察階段: {result.target.ip_address}")
        result.current_phase = AttackPhase.RECONNAISSANCE
        
        try:
            # 執行偵察掃描
            recon_results = await self.recon_scanner.scan_target(
                result.target.ip_address,
                depth=self.config.recon_depth
            )
            
            result.recon_results = recon_results
            
            # 更新目標信息
            for recon_result in recon_results:
                if recon_result.target_type == "domain" and recon_result.domain_info:
                    result.target.domain = recon_result.domain_info.domain
                    result.target.hostname = recon_result.domain_info.hostname
            
            self.logger.info(f"偵察階段完成，發現 {len(recon_results)} 個結果")
            
        except Exception as e:
            self.logger.error(f"偵察階段失敗: {e}")
            result.errors.append(f"偵察階段失敗: {e}")
    
    async def _execute_scanning_phase(self, result: AttackChainResult):
        """
        執行掃描階段
        """
        self.logger.info(f"開始掃描階段: {result.target.ip_address}")
        result.current_phase = AttackPhase.SCANNING
        
        try:
            # 執行網路掃描
            scan_results = await self.network_scanner.scan_target(
                result.target.ip_address,
                scan_type=self.config.scan_type,
                port_range=self.config.port_range,
                timeout=self.config.scan_timeout
            )
            
            result.scan_results = scan_results
            
            # 更新目標信息
            for scan_result in scan_results:
                if scan_result.host_info:
                    result.target.ports.extend([port.port for port in scan_result.host_info.open_ports])
                    result.target.services.update({
                        port.port: port.service for port in scan_result.host_info.open_ports
                    })
                    if scan_result.host_info.os_info:
                        result.target.os_info = scan_result.host_info.os_info
            
            self.logger.info(f"掃描階段完成，發現 {len(result.target.ports)} 個開放端口")
            
        except Exception as e:
            self.logger.error(f"掃描階段失敗: {e}")
            result.errors.append(f"掃描階段失敗: {e}")
    
    async def _execute_vulnerability_assessment_phase(self, result: AttackChainResult):
        """
        執行漏洞評估階段
        """
        self.logger.info(f"開始漏洞評估階段: {result.target.ip_address}")
        result.current_phase = AttackPhase.VULNERABILITY_ASSESSMENT
        
        try:
            # 執行漏洞掃描
            vuln_results = await self.vuln_scanner.scan_vulnerabilities(
                result.target.ip_address,
                ports=result.target.ports,
                services=result.target.services
            )
            
            # 過濾漏洞嚴重程度
            filtered_vulns = self._filter_vulnerabilities_by_severity(
                vuln_results, self.config.min_severity
            )
            
            result.vulnerability_results = filtered_vulns
            result.total_vulnerabilities = len(filtered_vulns)
            result.target.vulnerabilities = filtered_vulns
            
            self.logger.info(f"漏洞評估完成，發現 {len(filtered_vulns)} 個漏洞")
            
        except Exception as e:
            self.logger.error(f"漏洞評估階段失敗: {e}")
            result.errors.append(f"漏洞評估階段失敗: {e}")
    
    async def _execute_exploitation_phase(self, result: AttackChainResult):
        """
        執行漏洞利用階段
        """
        self.logger.info(f"開始漏洞利用階段: {result.target.ip_address}")
        result.current_phase = AttackPhase.EXPLOITATION
        
        try:
            # 執行漏洞利用
            exploit_report = await self.exploit_manager.exploit_vulnerabilities(
                result.vulnerability_results,
                result.target.ip_address,
                max_attempts=self.config.max_exploit_attempts,
                timeout=self.config.exploit_timeout,
                safe_mode=self.config.safe_mode
            )
            
            result.exploit_report = exploit_report
            result.exploited_vulnerabilities = exploit_report.successful_attempts
            result.active_sessions = exploit_report.active_sessions
            
            # 更新目標信息
            if exploit_report.active_sessions > 0:
                result.target.exploited = True
                result.target.sessions = [session.session_id for session in exploit_report.sessions]
            
            self.logger.info(f"漏洞利用完成，成功利用 {exploit_report.successful_attempts} 個漏洞")
            
        except Exception as e:
            self.logger.error(f"漏洞利用階段失敗: {e}")
            result.errors.append(f"漏洞利用階段失敗: {e}")
    
    async def _execute_post_exploitation_phase(self, result: AttackChainResult):
        """
        執行後滲透階段
        """
        self.logger.info(f"開始後滲透階段: {result.target.ip_address}")
        result.current_phase = AttackPhase.POST_EXPLOITATION
        
        try:
            post_exploit_tasks = []
            
            # 對每個活躍會話執行後滲透任務
            for session in result.exploit_report.sessions:
                if session.is_active:
                    for task_type in self.config.post_exploit_tasks:
                        task = await self.post_exploit_manager.execute_post_exploit_task(
                            session, task_type
                        )
                        post_exploit_tasks.append(task)
            
            result.post_exploit_tasks = post_exploit_tasks
            
            # 統計收集的數據
            collected_data = self.post_exploit_manager.get_collected_data()
            result.collected_data_count = len(collected_data)
            
            self.logger.info(f"後滲透階段完成，執行了 {len(post_exploit_tasks)} 個任務")
            
        except Exception as e:
            self.logger.error(f"後滲透階段失敗: {e}")
            result.errors.append(f"後滲透階段失敗: {e}")
    
    async def _execute_reporting_phase(self, result: AttackChainResult):
        """
        執行報告生成階段
        """
        self.logger.info(f"開始報告生成階段: {result.target.ip_address}")
        result.current_phase = AttackPhase.REPORTING
        
        try:
            # 創建滲透測試報告
            report = PentestReport(
                report_id=str(uuid.uuid4()),
                target=result.target.ip_address,
                start_time=result.start_time,
                end_time=result.end_time or time.time(),
                scan_results=result.scan_results,
                vulnerability_results=result.vulnerability_results,
                exploit_report=result.exploit_report,
                post_exploit_tasks=result.post_exploit_tasks
            )
            
            # 生成不同格式的報告
            report_paths = []
            for format_type in self.config.report_format:
                output_path = f"./reports/attack_chain_{result.chain_id}_{int(time.time())}.{format_type}"
                self.report_generator.generate_report(report, output_path, format_type)
                report_paths.append(output_path)
            
            result.report_paths = report_paths
            
            self.logger.info(f"報告生成完成，生成了 {len(report_paths)} 個報告文件")
            
        except Exception as e:
            self.logger.error(f"報告生成階段失敗: {e}")
            result.errors.append(f"報告生成階段失敗: {e}")
    
    def _filter_vulnerabilities_by_severity(self, vulnerabilities: List[VulnerabilityResult], 
                                          min_severity: str) -> List[VulnerabilityResult]:
        """
        根據嚴重程度過濾漏洞
        """
        severity_levels = {"low": 1, "medium": 2, "high": 3, "critical": 4}
        min_level = severity_levels.get(min_severity.lower(), 2)
        
        filtered = []
        for vuln in vulnerabilities:
            vuln_level = severity_levels.get(vuln.severity.value.lower(), 1)
            if vuln_level >= min_level:
                filtered.append(vuln)
        
        return filtered
    
    async def _cleanup_attack_chain(self, result: AttackChainResult):
        """
        清理攻擊鏈資源
        """
        try:
            # 清理會話
            if result.exploit_report and result.exploit_report.sessions:
                session_ids = [session.session_id for session in result.exploit_report.sessions]
                await self.exploit_manager.cleanup_sessions(session_ids)
            
            self.logger.info(f"攻擊鏈清理完成: {result.chain_id}")
            
        except Exception as e:
            self.logger.error(f"攻擊鏈清理失敗: {e}")
    
    def get_active_chains(self) -> List[AttackChainResult]:
        """
        獲取活躍的攻擊鏈
        """
        return list(self.active_chains.values())
    
    def get_completed_chains(self) -> List[AttackChainResult]:
        """
        獲取已完成的攻擊鏈
        """
        return self.completed_chains
    
    def get_chain_status(self, chain_id: str) -> Optional[AttackChainResult]:
        """
        獲取攻擊鏈狀態
        """
        if chain_id in self.active_chains:
            return self.active_chains[chain_id]
        
        for chain in self.completed_chains:
            if chain.chain_id == chain_id:
                return chain
        
        return None
    
    async def cancel_attack_chain(self, chain_id: str) -> bool:
        """
        取消攻擊鏈
        """
        if chain_id in self.active_chains:
            result = self.active_chains[chain_id]
            result.status = AttackChainStatus.CANCELLED
            await self._cleanup_attack_chain(result)
            return True
        
        return False