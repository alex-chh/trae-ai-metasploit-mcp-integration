#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
數據庫模組
Database Module

提供數據持久化和查詢功能
"""

import sqlite3
import json
import time
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path
from datetime import datetime
from enum import Enum
import threading
from contextlib import contextmanager

from ..core.logger import get_logger
from ..core.config import DatabaseConfig
from ..scanners.network_scanner import ScanResult, HostInfo, PortInfo
from ..scanners.vulnerability_scanner import VulnerabilityResult, VulnerabilityInfo
from ..exploits.exploit_manager import ExploitReport, ExploitAttempt
from ..post_exploit.post_exploit import PostExploitTask
from ..utils.report_generator import PentestReport


class DatabaseType(Enum):
    """
    數據庫類型
    """
    SQLITE = "sqlite"
    POSTGRESQL = "postgresql"
    MYSQL = "mysql"


@dataclass
class DatabaseStats:
    """
    數據庫統計信息
    """
    total_scans: int = 0
    total_vulnerabilities: int = 0
    total_exploits: int = 0
    total_sessions: int = 0
    total_reports: int = 0
    database_size: int = 0
    last_updated: float = 0.0


class DatabaseManager:
    """
    數據庫管理器
    
    提供統一的數據庫操作接口
    """
    
    def __init__(self, config: Optional[DatabaseConfig] = None):
        """
        初始化數據庫管理器
        
        Args:
            config: 數據庫配置
        """
        self.config = config or DatabaseConfig()
        self.logger = get_logger()
        self._connection = None
        self._lock = threading.RLock()
        
        # 初始化數據庫
        self._initialize_database()
    
    def _initialize_database(self):
        """
        初始化數據庫
        """
        if self.config.type == DatabaseType.SQLITE.value:
            self._initialize_sqlite()
        elif self.config.type == DatabaseType.POSTGRESQL.value:
            self._initialize_postgresql()
        else:
            raise ValueError(f"不支持的數據庫類型: {self.config.type}")
        
        self.logger.info(f"數據庫初始化完成: {self.config.type}")
    
    def _initialize_sqlite(self):
        """
        初始化 SQLite 數據庫
        """
        # 確保數據庫目錄存在
        db_path = Path(self.config.database)
        db_path.parent.mkdir(parents=True, exist_ok=True)
        
        # 創建數據庫連接
        self._connection = sqlite3.connect(
            self.config.database,
            check_same_thread=False,
            timeout=30.0
        )
        self._connection.row_factory = sqlite3.Row
        
        # 創建表結構
        self._create_tables()
    
    def _initialize_postgresql(self):
        """
        初始化 PostgreSQL 數據庫
        """
        try:
            import psycopg2
            from psycopg2.extras import RealDictCursor
            
            self._connection = psycopg2.connect(
                self.config.database,
                cursor_factory=RealDictCursor
            )
            self._connection.autocommit = True
            
            # 創建表結構
            self._create_tables()
            
        except ImportError:
            raise ImportError("需要安裝 psycopg2 來支持 PostgreSQL")
    
    def _create_tables(self):
        """
        創建數據庫表結構
        """
        with self._get_cursor() as cursor:
            # 掃描結果表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS scan_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    target TEXT NOT NULL,
                    scan_type TEXT NOT NULL,
                    start_time REAL NOT NULL,
                    end_time REAL,
                    duration REAL,
                    hosts_count INTEGER DEFAULT 0,
                    data TEXT NOT NULL,
                    created_at REAL DEFAULT (strftime('%s', 'now'))
                )
            """)
            
            # 主機信息表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS hosts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    scan_result_id INTEGER,
                    ip_address TEXT NOT NULL,
                    hostname TEXT,
                    status TEXT,
                    os_info TEXT,
                    ports_count INTEGER DEFAULT 0,
                    created_at REAL DEFAULT (strftime('%s', 'now')),
                    FOREIGN KEY (scan_result_id) REFERENCES scan_results (id)
                )
            """)
            
            # 端口信息表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS ports (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    host_id INTEGER,
                    port INTEGER NOT NULL,
                    protocol TEXT NOT NULL,
                    state TEXT,
                    service TEXT,
                    version TEXT,
                    created_at REAL DEFAULT (strftime('%s', 'now')),
                    FOREIGN KEY (host_id) REFERENCES hosts (id)
                )
            """)
            
            # 漏洞結果表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS vulnerability_results (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    target TEXT NOT NULL,
                    scan_time REAL NOT NULL,
                    vulnerabilities_count INTEGER DEFAULT 0,
                    data TEXT NOT NULL,
                    created_at REAL DEFAULT (strftime('%s', 'now'))
                )
            """)
            
            # 漏洞信息表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    result_id INTEGER,
                    name TEXT NOT NULL,
                    severity TEXT NOT NULL,
                    cve_id TEXT,
                    description TEXT,
                    port INTEGER,
                    service TEXT,
                    status TEXT,
                    "references" TEXT,
                    created_at REAL DEFAULT (strftime('%s', 'now')),
                    FOREIGN KEY (result_id) REFERENCES vulnerability_results (id)
                )
            """)
            
            # 漏洞利用報告表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS exploit_reports (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    target TEXT NOT NULL,
                    start_time REAL NOT NULL,
                    end_time REAL,
                    attempts_count INTEGER DEFAULT 0,
                    successful_attempts INTEGER DEFAULT 0,
                    data TEXT NOT NULL,
                    created_at REAL DEFAULT (strftime('%s', 'now'))
                )
            """)
            
            # 漏洞利用嘗試表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS exploit_attempts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    report_id INTEGER,
                    module_name TEXT NOT NULL,
                    payload_name TEXT,
                    success BOOLEAN DEFAULT FALSE,
                    session_id INTEGER,
                    error_message TEXT,
                    timestamp REAL NOT NULL,
                    created_at REAL DEFAULT (strftime('%s', 'now')),
                    FOREIGN KEY (report_id) REFERENCES exploit_reports (id)
                )
            """)
            
            # 後滲透任務表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS post_exploit_tasks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id TEXT UNIQUE NOT NULL,
                    session_id INTEGER NOT NULL,
                    task_type TEXT NOT NULL,
                    status TEXT NOT NULL,
                    start_time REAL,
                    end_time REAL,
                    duration REAL,
                    progress REAL DEFAULT 0.0,
                    results TEXT,
                    metadata TEXT,
                    errors TEXT,
                    created_at REAL DEFAULT (strftime('%s', 'now'))
                )
            """)
            
            # 滲透測試報告表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS pentest_reports (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    report_id TEXT UNIQUE NOT NULL,
                    title TEXT NOT NULL,
                    target TEXT NOT NULL,
                    start_time REAL NOT NULL,
                    end_time REAL,
                    duration REAL,
                    tester TEXT,
                    version TEXT,
                    data TEXT NOT NULL,
                    created_at REAL DEFAULT (strftime('%s', 'now'))
                )
            """)
            
            # 會話表
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id INTEGER UNIQUE NOT NULL,
                    target TEXT NOT NULL,
                    session_type TEXT NOT NULL,
                    platform TEXT,
                    active BOOLEAN DEFAULT TRUE,
                    created_at REAL DEFAULT (strftime('%s', 'now')),
                    last_activity REAL DEFAULT (strftime('%s', 'now'))
                )
            """)
            
            # 創建索引
            self._create_indexes(cursor)
    
    def _create_indexes(self, cursor):
        """
        創建數據庫索引
        
        Args:
            cursor: 數據庫游標
        """
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_scan_results_target ON scan_results(target)",
            "CREATE INDEX IF NOT EXISTS idx_scan_results_start_time ON scan_results(start_time)",
            "CREATE INDEX IF NOT EXISTS idx_hosts_ip_address ON hosts(ip_address)",
            "CREATE INDEX IF NOT EXISTS idx_ports_port ON ports(port)",
            "CREATE INDEX IF NOT EXISTS idx_vulnerabilities_severity ON vulnerabilities(severity)",
            "CREATE INDEX IF NOT EXISTS idx_vulnerabilities_cve_id ON vulnerabilities(cve_id)",
            "CREATE INDEX IF NOT EXISTS idx_exploit_attempts_success ON exploit_attempts(success)",
            "CREATE INDEX IF NOT EXISTS idx_post_exploit_tasks_status ON post_exploit_tasks(status)",
            "CREATE INDEX IF NOT EXISTS idx_sessions_active ON sessions(active)",
            "CREATE INDEX IF NOT EXISTS idx_pentest_reports_target ON pentest_reports(target)"
        ]
        
        for index_sql in indexes:
            try:
                cursor.execute(index_sql)
            except Exception as e:
                self.logger.warning(f"創建索引失敗: {e}")
    
    @contextmanager
    def _get_cursor(self):
        """
        獲取數據庫游標（上下文管理器）
        
        Yields:
            數據庫游標
        """
        with self._lock:
            cursor = self._connection.cursor()
            try:
                yield cursor
                self._connection.commit()
            except Exception as e:
                self._connection.rollback()
                self.logger.error(f"數據庫操作失敗: {e}")
                raise
            finally:
                cursor.close()
    
    def save_scan_result(self, scan_result: ScanResult) -> int:
        """
        保存掃描結果
        
        Args:
            scan_result: 掃描結果
            
        Returns:
            掃描結果ID
        """
        with self._get_cursor() as cursor:
            # 保存掃描結果
            cursor.execute("""
                INSERT INTO scan_results (target, scan_type, start_time, end_time, duration, hosts_count, data)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (
                scan_result.target,
                scan_result.scan_type,
                scan_result.start_time,
                scan_result.end_time,
                scan_result.duration,
                len(scan_result.hosts),
                json.dumps(asdict(scan_result), default=str)
            ))
            
            scan_result_id = cursor.lastrowid
            
            # 保存主機信息
            for host in scan_result.hosts:
                cursor.execute("""
                    INSERT INTO hosts (scan_result_id, ip_address, hostname, status, os_info, ports_count)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (
                    scan_result_id,
                    host.ip_address,
                    host.hostname,
                    host.status,
                    host.os_info,
                    len(host.open_ports)
                ))
                
                host_id = cursor.lastrowid
                
                # 保存端口信息
                for port in host.open_ports:
                    cursor.execute("""
                        INSERT INTO ports (host_id, port, protocol, state, service, version)
                        VALUES (?, ?, ?, ?, ?, ?)
                    """, (
                        host_id,
                        port.port,
                        port.protocol,
                        port.state,
                        port.service,
                        port.version
                    ))
        
        self.logger.info(f"保存掃描結果: {scan_result_id}", {
            "target": scan_result.target,
            "hosts_count": len(scan_result.hosts)
        })
        
        return scan_result_id
    
    def save_vulnerability_result(self, vuln_result: VulnerabilityResult) -> int:
        """
        保存漏洞掃描結果
        
        Args:
            vuln_result: 漏洞掃描結果
            
        Returns:
            漏洞結果ID
        """
        with self._get_cursor() as cursor:
            # 保存漏洞結果
            cursor.execute("""
                INSERT INTO vulnerability_results (target, scan_time, vulnerabilities_count, data)
                VALUES (?, ?, ?, ?)
            """, (
                vuln_result.target,
                vuln_result.scan_time,
                len(vuln_result.results),
                json.dumps(asdict(vuln_result), default=str)
            ))
            
            result_id = cursor.lastrowid
            
            # 保存漏洞信息
            for vuln in vuln_result.results:
                cursor.execute("""
                    INSERT INTO vulnerabilities (result_id, name, severity, cve_id, description, port, service, status, "references")
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    result_id,
                    vuln.name,
                    vuln.severity.value,
                    vuln.cve_id,
                    vuln.description,
                    vuln.port,
                    vuln.service,
                    vuln.status.value,
                    json.dumps(vuln.references) if vuln.references else None
                ))
        
        self.logger.info(f"保存漏洞結果: {result_id}", {
            "target": vuln_result.target,
            "vulnerabilities_count": len(vuln_result.results)
        })
        
        return result_id
    
    def save_exploit_report(self, exploit_report: ExploitReport) -> int:
        """
        保存漏洞利用報告
        
        Args:
            exploit_report: 漏洞利用報告
            
        Returns:
            報告ID
        """
        with self._get_cursor() as cursor:
            successful_attempts = sum(1 for attempt in exploit_report.attempts if attempt.success)
            
            # 保存漏洞利用報告
            cursor.execute("""
                INSERT INTO exploit_reports (target, start_time, end_time, attempts_count, successful_attempts, data)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                exploit_report.target,
                exploit_report.start_time,
                exploit_report.end_time,
                len(exploit_report.attempts),
                successful_attempts,
                json.dumps(asdict(exploit_report), default=str)
            ))
            
            report_id = cursor.lastrowid
            
            # 保存漏洞利用嘗試
            for attempt in exploit_report.attempts:
                cursor.execute("""
                    INSERT INTO exploit_attempts (report_id, module_name, payload_name, success, session_id, error_message, timestamp)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (
                    report_id,
                    attempt.module_name,
                    attempt.payload_name,
                    attempt.success,
                    attempt.session.session_id if attempt.session else None,
                    attempt.error_message,
                    attempt.timestamp
                ))
        
        self.logger.info(f"保存漏洞利用報告: {report_id}", {
            "target": exploit_report.target,
            "attempts_count": len(exploit_report.attempts),
            "successful_attempts": successful_attempts
        })
        
        return report_id
    
    def save_post_exploit_task(self, task: PostExploitTask) -> int:
        """
        保存後滲透任務
        
        Args:
            task: 後滲透任務
            
        Returns:
            任務ID
        """
        with self._get_cursor() as cursor:
            cursor.execute("""
                INSERT OR REPLACE INTO post_exploit_tasks 
                (task_id, session_id, task_type, status, start_time, end_time, duration, progress, results, metadata, errors)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                task.task_id,
                task.session_id,
                task.task_type.value,
                task.status.value,
                task.start_time,
                task.end_time,
                task.duration,
                task.progress,
                json.dumps(task.results) if task.results else None,
                json.dumps(task.metadata) if task.metadata else None,
                json.dumps(task.errors) if task.errors else None
            ))
            
            task_id = cursor.lastrowid
        
        self.logger.debug(f"保存後滲透任務: {task.task_id}")
        return task_id
    
    def save_pentest_report(self, report: PentestReport) -> int:
        """
        保存滲透測試報告
        
        Args:
            report: 滲透測試報告
            
        Returns:
            報告ID
        """
        with self._get_cursor() as cursor:
            cursor.execute("""
                INSERT OR REPLACE INTO pentest_reports 
                (report_id, title, target, start_time, end_time, duration, tester, version, data)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                report.report_id,
                report.title,
                report.target,
                report.start_time,
                report.end_time,
                report.duration,
                report.tester,
                report.version,
                json.dumps(asdict(report), default=str)
            ))
            
            db_report_id = cursor.lastrowid
        
        self.logger.info(f"保存滲透測試報告: {report.report_id}")
        return db_report_id
    
    def save_session(self, session_id: int, target: str, session_type: str, 
                    platform: Optional[str] = None, active: bool = True) -> int:
        """
        保存會話信息
        
        Args:
            session_id: 會話ID
            target: 目標
            session_type: 會話類型
            platform: 平台
            active: 是否活躍
            
        Returns:
            數據庫記錄ID
        """
        with self._get_cursor() as cursor:
            cursor.execute("""
                INSERT OR REPLACE INTO sessions (session_id, target, session_type, platform, active, last_activity)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                session_id,
                target,
                session_type,
                platform,
                active,
                time.time()
            ))
            
            db_session_id = cursor.lastrowid
        
        self.logger.info(f"保存會話: {session_id}", {
            "target": target,
            "session_type": session_type,
            "active": active
        })
        
        return db_session_id
    
    def update_session_status(self, session_id: int, active: bool):
        """
        更新會話狀態
        
        Args:
            session_id: 會話ID
            active: 是否活躍
        """
        with self._get_cursor() as cursor:
            cursor.execute("""
                UPDATE sessions SET active = ?, last_activity = ? WHERE session_id = ?
            """, (active, time.time(), session_id))
        
        self.logger.debug(f"更新會話狀態: {session_id} -> {active}")
    
    def get_scan_results(self, target: Optional[str] = None, 
                        limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """
        獲取掃描結果
        
        Args:
            target: 目標過濾
            limit: 限制數量
            offset: 偏移量
            
        Returns:
            掃描結果列表
        """
        with self._get_cursor() as cursor:
            if target:
                cursor.execute("""
                    SELECT * FROM scan_results WHERE target LIKE ? 
                    ORDER BY start_time DESC LIMIT ? OFFSET ?
                """, (f"%{target}%", limit, offset))
            else:
                cursor.execute("""
                    SELECT * FROM scan_results ORDER BY start_time DESC LIMIT ? OFFSET ?
                """, (limit, offset))
            
            return [dict(row) for row in cursor.fetchall()]
    
    def get_vulnerability_results(self, target: Optional[str] = None, 
                                 severity: Optional[str] = None,
                                 limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """
        獲取漏洞掃描結果
        
        Args:
            target: 目標過濾
            severity: 嚴重程度過濾
            limit: 限制數量
            offset: 偏移量
            
        Returns:
            漏洞結果列表
        """
        with self._get_cursor() as cursor:
            query = "SELECT vr.*, COUNT(v.id) as vuln_count FROM vulnerability_results vr LEFT JOIN vulnerabilities v ON vr.id = v.result_id"
            params = []
            conditions = []
            
            if target:
                conditions.append("vr.target LIKE ?")
                params.append(f"%{target}%")
            
            if severity:
                conditions.append("v.severity = ?")
                params.append(severity)
            
            if conditions:
                query += " WHERE " + " AND ".join(conditions)
            
            query += " GROUP BY vr.id ORDER BY vr.scan_time DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])
            
            cursor.execute(query, params)
            return [dict(row) for row in cursor.fetchall()]
    
    def get_exploit_reports(self, target: Optional[str] = None, 
                           success_only: bool = False,
                           limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """
        獲取漏洞利用報告
        
        Args:
            target: 目標過濾
            success_only: 只返回成功的利用
            limit: 限制數量
            offset: 偏移量
            
        Returns:
            漏洞利用報告列表
        """
        with self._get_cursor() as cursor:
            query = "SELECT * FROM exploit_reports"
            params = []
            conditions = []
            
            if target:
                conditions.append("target LIKE ?")
                params.append(f"%{target}%")
            
            if success_only:
                conditions.append("successful_attempts > 0")
            
            if conditions:
                query += " WHERE " + " AND ".join(conditions)
            
            query += " ORDER BY start_time DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])
            
            cursor.execute(query, params)
            return [dict(row) for row in cursor.fetchall()]
    
    def get_active_sessions(self) -> List[Dict[str, Any]]:
        """
        獲取活躍會話
        
        Returns:
            活躍會話列表
        """
        with self._get_cursor() as cursor:
            cursor.execute("""
                SELECT * FROM sessions WHERE active = TRUE ORDER BY last_activity DESC
            """)
            return [dict(row) for row in cursor.fetchall()]
    
    def get_post_exploit_tasks(self, session_id: Optional[int] = None,
                              status: Optional[str] = None,
                              limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """
        獲取後滲透任務
        
        Args:
            session_id: 會話ID過濾
            status: 狀態過濾
            limit: 限制數量
            offset: 偏移量
            
        Returns:
            後滲透任務列表
        """
        with self._get_cursor() as cursor:
            query = "SELECT * FROM post_exploit_tasks"
            params = []
            conditions = []
            
            if session_id is not None:
                conditions.append("session_id = ?")
                params.append(session_id)
            
            if status:
                conditions.append("status = ?")
                params.append(status)
            
            if conditions:
                query += " WHERE " + " AND ".join(conditions)
            
            query += " ORDER BY start_time DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])
            
            cursor.execute(query, params)
            return [dict(row) for row in cursor.fetchall()]
    
    def get_pentest_reports(self, target: Optional[str] = None,
                           limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """
        獲取滲透測試報告
        
        Args:
            target: 目標過濾
            limit: 限制數量
            offset: 偏移量
            
        Returns:
            滲透測試報告列表
        """
        with self._get_cursor() as cursor:
            if target:
                cursor.execute("""
                    SELECT * FROM pentest_reports WHERE target LIKE ? 
                    ORDER BY start_time DESC LIMIT ? OFFSET ?
                """, (f"%{target}%", limit, offset))
            else:
                cursor.execute("""
                    SELECT * FROM pentest_reports ORDER BY start_time DESC LIMIT ? OFFSET ?
                """, (limit, offset))
            
            return [dict(row) for row in cursor.fetchall()]
    
    def get_statistics(self) -> DatabaseStats:
        """
        獲取數據庫統計信息
        
        Returns:
            數據庫統計信息
        """
        stats = DatabaseStats()
        
        with self._get_cursor() as cursor:
            # 統計掃描結果
            cursor.execute("SELECT COUNT(*) FROM scan_results")
            stats.total_scans = cursor.fetchone()[0]
            
            # 統計漏洞
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
            stats.total_vulnerabilities = cursor.fetchone()[0]
            
            # 統計漏洞利用
            cursor.execute("SELECT COUNT(*) FROM exploit_attempts WHERE success = TRUE")
            stats.total_exploits = cursor.fetchone()[0]
            
            # 統計會話
            cursor.execute("SELECT COUNT(*) FROM sessions WHERE active = TRUE")
            stats.total_sessions = cursor.fetchone()[0]
            
            # 統計報告
            cursor.execute("SELECT COUNT(*) FROM pentest_reports")
            stats.total_reports = cursor.fetchone()[0]
            
            # 數據庫大小（SQLite）
            if self.config.type == DatabaseType.SQLITE.value:
                db_path = Path(self.config.database)
                if db_path.exists():
                    stats.database_size = db_path.stat().st_size
            
            stats.last_updated = time.time()
        
        return stats
    
    def search_vulnerabilities(self, query: str, limit: int = 50) -> List[Dict[str, Any]]:
        """
        搜索漏洞
        
        Args:
            query: 搜索查詢
            limit: 限制數量
            
        Returns:
            漏洞列表
        """
        with self._get_cursor() as cursor:
            cursor.execute("""
                SELECT v.*, vr.target FROM vulnerabilities v
                JOIN vulnerability_results vr ON v.result_id = vr.id
                WHERE v.name LIKE ? OR v.description LIKE ? OR v.cve_id LIKE ?
                ORDER BY v.severity DESC, v.created_at DESC
                LIMIT ?
            """, (f"%{query}%", f"%{query}%", f"%{query}%", limit))
            
            return [dict(row) for row in cursor.fetchall()]
    
    def get_vulnerability_trends(self, days: int = 30) -> Dict[str, List[Tuple[str, int]]]:
        """
        獲取漏洞趨勢
        
        Args:
            days: 天數
            
        Returns:
            漏洞趨勢數據
        """
        with self._get_cursor() as cursor:
            start_time = time.time() - (days * 24 * 60 * 60)
            
            # 按嚴重程度統計
            cursor.execute("""
                SELECT v.severity, DATE(v.created_at, 'unixepoch') as date, COUNT(*) as count
                FROM vulnerabilities v
                WHERE v.created_at >= ?
                GROUP BY v.severity, date
                ORDER BY date
            """, (start_time,))
            
            trends = {}
            for row in cursor.fetchall():
                severity = row[0]
                date = row[1]
                count = row[2]
                
                if severity not in trends:
                    trends[severity] = []
                trends[severity].append((date, count))
            
            return trends
    
    def cleanup_old_data(self, days: int = 90):
        """
        清理舊數據
        
        Args:
            days: 保留天數
        """
        cutoff_time = time.time() - (days * 24 * 60 * 60)
        
        with self._get_cursor() as cursor:
            # 清理舊的掃描結果
            cursor.execute("DELETE FROM scan_results WHERE created_at < ?", (cutoff_time,))
            deleted_scans = cursor.rowcount
            
            # 清理舊的漏洞結果
            cursor.execute("DELETE FROM vulnerability_results WHERE created_at < ?", (cutoff_time,))
            deleted_vulns = cursor.rowcount
            
            # 清理舊的漏洞利用報告
            cursor.execute("DELETE FROM exploit_reports WHERE created_at < ?", (cutoff_time,))
            deleted_exploits = cursor.rowcount
            
            # 清理舊的後滲透任務
            cursor.execute("DELETE FROM post_exploit_tasks WHERE created_at < ?", (cutoff_time,))
            deleted_tasks = cursor.rowcount
        
        self.logger.info(f"清理舊數據完成", {
            "days": days,
            "deleted_scans": deleted_scans,
            "deleted_vulns": deleted_vulns,
            "deleted_exploits": deleted_exploits,
            "deleted_tasks": deleted_tasks
        })
    
    def backup_database(self, backup_path: str) -> bool:
        """
        備份數據庫
        
        Args:
            backup_path: 備份路徑
            
        Returns:
            是否成功
        """
        try:
            if self.config.type == DatabaseType.SQLITE.value:
                import shutil
                shutil.copy2(self.config.database, backup_path)
            else:
                # 對於其他數據庫類型，可以使用 pg_dump 等工具
                self.logger.warning(f"數據庫類型 {self.config.type} 的備份功能尚未實現")
                return False
            
            self.logger.info(f"數據庫備份完成: {backup_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"數據庫備份失敗: {e}")
            return False
    
    def close(self):
        """
        關閉數據庫連接
        """
        if self._connection:
            self._connection.close()
            self._connection = None
            self.logger.info("數據庫連接已關閉")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()