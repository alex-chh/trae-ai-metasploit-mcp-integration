#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
目標管理模組
Target Manager Module

提供目標驗證、解析和管理功能
"""

import ipaddress
import re
import socket
import asyncio
from typing import Dict, List, Optional, Any, Union, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum

from ..core.logger import get_logger


class TargetType(Enum):
    """
    目標類型
    """
    IP_ADDRESS = "ip_address"
    IP_RANGE = "ip_range"
    CIDR_NETWORK = "cidr_network"
    HOSTNAME = "hostname"
    DOMAIN = "domain"
    URL = "url"
    FILE = "file"


class TargetStatus(Enum):
    """
    目標狀態
    """
    UNKNOWN = "unknown"
    ONLINE = "online"
    OFFLINE = "offline"
    FILTERED = "filtered"
    ERROR = "error"


@dataclass
class Target:
    """
    目標對象
    """
    original: str
    ip: str
    hostname: Optional[str] = None
    target_type: TargetType = TargetType.IP_ADDRESS
    status: TargetStatus = TargetStatus.UNKNOWN
    ports: List[int] = field(default_factory=list)
    services: Dict[int, str] = field(default_factory=dict)
    os_info: Optional[str] = None
    response_time: Optional[float] = None
    last_scan: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


class TargetManager:
    """
    目標管理器
    
    負責目標的解析、驗證和管理
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        初始化目標管理器
        
        Args:
            config: 配置字典
        """
        self.config = config or {}
        self.logger = get_logger()
        
        # 默認配置
        self.default_config = {
            'max_targets': 1000,
            'dns_timeout': 5.0,
            'ping_timeout': 3.0,
            'max_concurrent_checks': 50,
            'resolve_hostnames': True,
            'validate_targets': True,
            'exclude_private': False,
            'exclude_localhost': True,
            'default_ports': [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1433, 3389, 5432, 8080]
        }
        
        # 合併配置
        for key, value in self.default_config.items():
            if key not in self.config:
                self.config[key] = value
        
        # 內部狀態
        self.targets: Dict[str, Target] = {}
        self.target_groups: Dict[str, List[str]] = {}
        
    async def validate_targets(self, targets: List[str]) -> List[Dict[str, Any]]:
        """
        驗證目標列表
        
        Args:
            targets: 目標字符串列表
            
        Returns:
            驗證後的目標字典列表
        """
        self.logger.info(f"開始驗證 {len(targets)} 個目標")
        
        validated_targets = []
        
        # 解析所有目標
        parsed_targets = []
        for target_str in targets:
            try:
                parsed = await self._parse_target(target_str)
                parsed_targets.extend(parsed)
            except Exception as e:
                self.logger.error(f"解析目標失敗 {target_str}: {e}")
                continue
        
        # 檢查目標數量限制
        if len(parsed_targets) > self.config['max_targets']:
            self.logger.warning(f"目標數量 ({len(parsed_targets)}) 超過限制 ({self.config['max_targets']})")
            parsed_targets = parsed_targets[:self.config['max_targets']]
        
        # 並發驗證目標
        if self.config['validate_targets']:
            semaphore = asyncio.Semaphore(self.config['max_concurrent_checks'])
            tasks = []
            
            for target in parsed_targets:
                task = asyncio.create_task(
                    self._validate_single_target(target, semaphore)
                )
                tasks.append(task)
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, Exception):
                    self.logger.error(f"目標驗證異常: {result}")
                elif result:
                    validated_targets.append(result)
        else:
            # 不驗證，直接返回解析結果
            for target in parsed_targets:
                validated_targets.append({
                    'ip': target.ip,
                    'hostname': target.hostname,
                    'type': target.target_type.value,
                    'status': 'unknown'
                })
        
        self.logger.info(f"目標驗證完成，有效目標: {len(validated_targets)}")
        return validated_targets
    
    async def _parse_target(self, target_str: str) -> List[Target]:
        """
        解析目標字符串
        
        Args:
            target_str: 目標字符串
            
        Returns:
            目標對象列表
        """
        target_str = target_str.strip()
        targets = []
        
        # 檢查是否為文件
        if target_str.startswith('@') or Path(target_str).exists():
            file_path = target_str.lstrip('@')
            targets.extend(await self._parse_target_file(file_path))
            return targets
        
        # 檢查是否為 IP 地址
        try:
            ip = ipaddress.ip_address(target_str)
            if self._is_valid_target_ip(str(ip)):
                target = Target(
                    original=target_str,
                    ip=str(ip),
                    target_type=TargetType.IP_ADDRESS
                )
                targets.append(target)
            return targets
        except ValueError:
            pass
        
        # 檢查是否為 CIDR 網段
        try:
            network = ipaddress.ip_network(target_str, strict=False)
            for ip in network.hosts():
                if self._is_valid_target_ip(str(ip)):
                    target = Target(
                        original=target_str,
                        ip=str(ip),
                        target_type=TargetType.CIDR_NETWORK
                    )
                    targets.append(target)
            return targets
        except ValueError:
            pass
        
        # 檢查是否為 IP 範圍
        if '-' in target_str:
            targets.extend(await self._parse_ip_range(target_str))
            return targets
        
        # 檢查是否為域名或主機名
        if self._is_valid_hostname(target_str):
            try:
                # 解析域名
                ip = socket.gethostbyname(target_str)
                if self._is_valid_target_ip(ip):
                    target = Target(
                        original=target_str,
                        ip=ip,
                        hostname=target_str,
                        target_type=TargetType.HOSTNAME
                    )
                    targets.append(target)
            except socket.gaierror:
                self.logger.warning(f"無法解析主機名: {target_str}")
            return targets
        
        # 檢查是否為 URL
        if target_str.startswith(('http://', 'https://')):
            targets.extend(await self._parse_url(target_str))
            return targets
        
        raise ValueError(f"無法解析目標: {target_str}")
    
    async def _parse_target_file(self, file_path: str) -> List[Target]:
        """
        從文件解析目標
        
        Args:
            file_path: 文件路徑
            
        Returns:
            目標對象列表
        """
        targets = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    
                    try:
                        parsed = await self._parse_target(line)
                        targets.extend(parsed)
                    except Exception as e:
                        self.logger.warning(f"文件 {file_path} 第 {line_num} 行解析失敗: {e}")
        
        except Exception as e:
            self.logger.error(f"讀取目標文件失敗 {file_path}: {e}")
            raise
        
        return targets
    
    async def _parse_ip_range(self, range_str: str) -> List[Target]:
        """
        解析 IP 範圍
        
        Args:
            range_str: IP 範圍字符串 (例如: 192.168.1.1-192.168.1.100)
            
        Returns:
            目標對象列表
        """
        targets = []
        
        try:
            start_ip, end_ip = range_str.split('-')
            start_ip = start_ip.strip()
            end_ip = end_ip.strip()
            
            # 如果結束 IP 只是數字，補全前綴
            if '.' not in end_ip:
                start_parts = start_ip.split('.')
                end_ip = '.'.join(start_parts[:-1]) + '.' + end_ip
            
            start = ipaddress.ip_address(start_ip)
            end = ipaddress.ip_address(end_ip)
            
            current = start
            while current <= end:
                if self._is_valid_target_ip(str(current)):
                    target = Target(
                        original=range_str,
                        ip=str(current),
                        target_type=TargetType.IP_RANGE
                    )
                    targets.append(target)
                current += 1
        
        except Exception as e:
            raise ValueError(f"無效的 IP 範圍: {range_str} - {e}")
        
        return targets
    
    async def _parse_url(self, url: str) -> List[Target]:
        """
        解析 URL
        
        Args:
            url: URL 字符串
            
        Returns:
            目標對象列表
        """
        import urllib.parse
        
        targets = []
        
        try:
            parsed = urllib.parse.urlparse(url)
            hostname = parsed.hostname
            
            if hostname:
                # 解析主機名
                try:
                    ip = socket.gethostbyname(hostname)
                    if self._is_valid_target_ip(ip):
                        target = Target(
                            original=url,
                            ip=ip,
                            hostname=hostname,
                            target_type=TargetType.URL
                        )
                        
                        # 添加端口信息
                        port = parsed.port
                        if port:
                            target.ports = [port]
                        elif parsed.scheme == 'https':
                            target.ports = [443]
                        elif parsed.scheme == 'http':
                            target.ports = [80]
                        
                        targets.append(target)
                
                except socket.gaierror:
                    self.logger.warning(f"無法解析 URL 主機名: {hostname}")
        
        except Exception as e:
            raise ValueError(f"無效的 URL: {url} - {e}")
        
        return targets
    
    def _is_valid_hostname(self, hostname: str) -> bool:
        """
        驗證主機名格式
        
        Args:
            hostname: 主機名
            
        Returns:
            是否有效
        """
        if len(hostname) > 253:
            return False
        
        # 檢查字符
        if not re.match(r'^[a-zA-Z0-9.-]+$', hostname):
            return False
        
        # 檢查每個部分
        parts = hostname.split('.')
        for part in parts:
            if not part or len(part) > 63:
                return False
            if part.startswith('-') or part.endswith('-'):
                return False
        
        return True
    
    def _is_valid_target_ip(self, ip_str: str) -> bool:
        """
        驗證 IP 地址是否為有效目標
        
        Args:
            ip_str: IP 地址字符串
            
        Returns:
            是否為有效目標
        """
        try:
            ip = ipaddress.ip_address(ip_str)
            
            # 排除本地地址
            if self.config['exclude_localhost']:
                if ip.is_loopback:
                    return False
            
            # 排除私有地址
            if self.config['exclude_private']:
                if ip.is_private:
                    return False
            
            # 排除其他特殊地址
            if ip.is_multicast or ip.is_reserved or ip.is_unspecified:
                return False
            
            return True
        
        except ValueError:
            return False
    
    async def _validate_single_target(self, target: Target, semaphore: asyncio.Semaphore) -> Optional[Dict[str, Any]]:
        """
        驗證單個目標
        
        Args:
            target: 目標對象
            semaphore: 並發控制信號量
            
        Returns:
            驗證結果字典
        """
        async with semaphore:
            try:
                # 執行 ping 測試
                is_online = await self._ping_target(target.ip)
                
                if is_online:
                    target.status = TargetStatus.ONLINE
                    
                    # 解析主機名（如果還沒有）
                    if not target.hostname and self.config['resolve_hostnames']:
                        try:
                            hostname = socket.gethostbyaddr(target.ip)[0]
                            target.hostname = hostname
                        except (socket.herror, socket.gaierror):
                            pass
                else:
                    target.status = TargetStatus.OFFLINE
                
                # 存儲目標
                self.targets[target.ip] = target
                
                return {
                    'ip': target.ip,
                    'hostname': target.hostname,
                    'type': target.target_type.value,
                    'status': target.status.value,
                    'response_time': target.response_time
                }
            
            except Exception as e:
                self.logger.error(f"驗證目標失敗 {target.ip}: {e}")
                return None
    
    async def _ping_target(self, ip: str) -> bool:
        """
        Ping 目標主機
        
        Args:
            ip: IP 地址
            
        Returns:
            是否在線
        """
        import platform
        import subprocess
        
        try:
            # 根據操作系統選擇 ping 命令
            system = platform.system().lower()
            if system == 'windows':
                cmd = ['ping', '-n', '1', '-w', str(int(self.config['ping_timeout'] * 1000)), ip]
            else:
                cmd = ['ping', '-c', '1', '-W', str(int(self.config['ping_timeout'])), ip]
            
            # 執行 ping
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=self.config['ping_timeout'] + 1
            )
            
            return process.returncode == 0
        
        except (asyncio.TimeoutError, subprocess.SubprocessError, OSError):
            return False
    
    def get_target(self, ip: str) -> Optional[Target]:
        """
        獲取目標對象
        
        Args:
            ip: IP 地址
            
        Returns:
            目標對象
        """
        return self.targets.get(ip)
    
    def get_all_targets(self) -> List[Target]:
        """
        獲取所有目標
        
        Returns:
            目標對象列表
        """
        return list(self.targets.values())
    
    def get_online_targets(self) -> List[Target]:
        """
        獲取在線目標
        
        Returns:
            在線目標列表
        """
        return [t for t in self.targets.values() if t.status == TargetStatus.ONLINE]
    
    def update_target_info(self, ip: str, **kwargs):
        """
        更新目標信息
        
        Args:
            ip: IP 地址
            **kwargs: 要更新的屬性
        """
        if ip in self.targets:
            target = self.targets[ip]
            for key, value in kwargs.items():
                if hasattr(target, key):
                    setattr(target, key, value)
    
    def create_target_group(self, group_name: str, targets: List[str]):
        """
        創建目標組
        
        Args:
            group_name: 組名
            targets: 目標 IP 列表
        """
        self.target_groups[group_name] = targets
        self.logger.info(f"創建目標組 '{group_name}'，包含 {len(targets)} 個目標")
    
    def get_target_group(self, group_name: str) -> List[str]:
        """
        獲取目標組
        
        Args:
            group_name: 組名
            
        Returns:
            目標 IP 列表
        """
        return self.target_groups.get(group_name, [])
    
    def export_targets(self, file_path: str, format: str = 'txt'):
        """
        導出目標列表
        
        Args:
            file_path: 輸出文件路徑
            format: 輸出格式 (txt, json, csv)
        """
        try:
            if format == 'json':
                import json
                data = {
                    'targets': [
                        {
                            'ip': t.ip,
                            'hostname': t.hostname,
                            'type': t.target_type.value,
                            'status': t.status.value,
                            'ports': t.ports,
                            'services': t.services,
                            'os_info': t.os_info
                        }
                        for t in self.targets.values()
                    ],
                    'groups': self.target_groups
                }
                
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, indent=2, ensure_ascii=False)
            
            elif format == 'csv':
                import csv
                with open(file_path, 'w', newline='', encoding='utf-8') as f:
                    writer = csv.writer(f)
                    writer.writerow(['IP', 'Hostname', 'Type', 'Status', 'Ports', 'OS'])
                    
                    for target in self.targets.values():
                        writer.writerow([
                            target.ip,
                            target.hostname or '',
                            target.target_type.value,
                            target.status.value,
                            ','.join(map(str, target.ports)),
                            target.os_info or ''
                        ])
            
            else:  # txt format
                with open(file_path, 'w', encoding='utf-8') as f:
                    for target in self.targets.values():
                        f.write(f"{target.ip}\n")
            
            self.logger.info(f"目標列表已導出到: {file_path}")
        
        except Exception as e:
            self.logger.error(f"導出目標列表失敗: {e}")
            raise
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        獲取目標統計信息
        
        Returns:
            統計信息字典
        """
        total = len(self.targets)
        online = len([t for t in self.targets.values() if t.status == TargetStatus.ONLINE])
        offline = len([t for t in self.targets.values() if t.status == TargetStatus.OFFLINE])
        unknown = len([t for t in self.targets.values() if t.status == TargetStatus.UNKNOWN])
        
        return {
            'total_targets': total,
            'online_targets': online,
            'offline_targets': offline,
            'unknown_targets': unknown,
            'target_groups': len(self.target_groups),
            'types': {
                target_type.value: len([
                    t for t in self.targets.values() 
                    if t.target_type == target_type
                ])
                for target_type in TargetType
            }
        }