#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Metasploit MCP 整合模組
Metasploit MCP Integration Module

提供與 Metasploit MCP 服務器的整合功能
"""

import asyncio
import json
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass

from .mcp_client import MetasploitMCPClient, MCPResponse
from ..core.logger import get_logger


class MetasploitMCP:
    """
    Metasploit MCP 整合類
    
    提供高級 Metasploit 操作接口
    """
    
    def __init__(self, config=None, timeout: int = 30):
        """
        初始化 Metasploit MCP 客戶端
        
        Args:
            config: Metasploit 配置對象
            timeout: 請求超時時間
        """
        # 如果提供了配置對象，使用其中的 timeout；否則使用默認值
        if config and hasattr(config, 'timeout'):
            timeout = config.timeout
        
        self.config = config
        self.client = MetasploitMCPClient(timeout)
        self.logger = get_logger()
        self._connected = False
    
    async def initialize(self):
        """
        初始化 MCP 連接
        """
        return await self.connect()
    
    async def cleanup(self):
        """
        清理 MCP 連接
        """
        if self._connected:
            await self.client.__aexit__(None, None, None)
            self._connected = False
            self.logger.info("Metasploit MCP 連接已關閉")
    
    async def __aenter__(self):
        """異步上下文管理器入口"""
        await self.client.__aenter__()
        self._connected = True
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """異步上下文管理器出口"""
        await self.client.__aexit__(exc_type, exc_val, exc_tb)
        self._connected = False
    
    async def connect(self) -> bool:
        """
        連接到 Metasploit MCP 服務器
        
        Returns:
            連接是否成功
        """
        try:
            await self.client.__aenter__()
            self._connected = True
            self.logger.info("Successfully connected to Metasploit MCP")
            return True
        except Exception as e:
            self.logger.error(f"Failed to connect to Metasploit MCP: {e}")
            return False
    
    async def disconnect(self):
        """斷開與 Metasploit MCP 服務器的連接"""
        if self._connected:
            await self.client.__aexit__(None, None, None)
            self._connected = False
            self.logger.info("Disconnected from Metasploit MCP")
    
    @property
    def is_connected(self) -> bool:
        """檢查是否已連接"""
        return self._connected
    
    # 漏洞利用相關方法
    async def list_exploits(self, search_term: str = "") -> List[str]:
        """
        列出可用的漏洞利用模組
        
        Args:
            search_term: 搜索關鍵詞
            
        Returns:
            漏洞利用模組列表
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.list_exploits(search_term)
        if response.success:
            return response.data.get('exploits', [])
        else:
            self.logger.error(f"Failed to list exploits: {response.error}")
            return []
    
    async def run_exploit(self, module_name: str, options: Dict[str, Any], 
                         payload_name: Optional[str] = None,
                         payload_options: Optional[Dict[str, Any]] = None,
                         run_as_job: bool = False) -> Dict[str, Any]:
        """
        執行漏洞利用模組
        
        Args:
            module_name: 模組名稱
            options: 模組選項
            payload_name: 載荷名稱
            payload_options: 載荷選項
            run_as_job: 是否作為後台任務運行
            
        Returns:
            執行結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.run_exploit(
            module_name=module_name,
            options=options,
            payload_name=payload_name,
            payload_options=payload_options,
            run_as_job=run_as_job
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to run exploit {module_name}: {response.error}")
            return {'success': False, 'error': response.error}
    
    # 載荷相關方法
    async def list_payloads(self, platform: str = "", arch: str = "") -> List[str]:
        """
        列出可用的載荷
        
        Args:
            platform: 平台過濾
            arch: 架構過濾
            
        Returns:
            載荷列表
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.list_payloads(platform, arch)
        if response.success:
            return response.data.get('payloads', [])
        else:
            self.logger.error(f"Failed to list payloads: {response.error}")
            return []
    
    async def generate_payload(self, payload_type: str, format_type: str,
                              options: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        """
        生成載荷
        
        Args:
            payload_type: 載荷類型
            format_type: 輸出格式
            options: 載荷選項
            **kwargs: 其他選項
            
        Returns:
            生成結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.generate_payload(
            payload_type=payload_type,
            format_type=format_type,
            options=options,
            **kwargs
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to generate payload: {response.error}")
            return {'success': False, 'error': response.error}
    
    # 會話管理方法
    async def list_sessions(self) -> List[Dict[str, Any]]:
        """
        列出活動會話
        
        Returns:
            會話列表
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.list_active_sessions()
        if response.success:
            return response.data.get('sessions', [])
        else:
            self.logger.error(f"Failed to list sessions: {response.error}")
            return []
    
    async def send_command(self, session_id: int, command: str, 
                          timeout: int = 60) -> Dict[str, Any]:
        """
        向會話發送命令
        
        Args:
            session_id: 會話ID
            command: 命令
            timeout: 超時時間
            
        Returns:
            命令執行結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.send_session_command(
            session_id=session_id,
            command=command,
            timeout_seconds=timeout
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to send command to session {session_id}: {response.error}")
            return {'success': False, 'error': response.error}
    
    async def terminate_session(self, session_id: int) -> bool:
        """
        終止會話
        
        Args:
            session_id: 會話ID
            
        Returns:
            是否成功終止
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.terminate_session(session_id)
        return response.success
    
    # 監聽器管理方法
    async def list_listeners(self) -> List[Dict[str, Any]]:
        """
        列出活動監聽器
        
        Returns:
            監聽器列表
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.list_listeners()
        if response.success:
            return response.data.get('listeners', [])
        else:
            self.logger.error(f"Failed to list listeners: {response.error}")
            return []
    
    async def start_listener(self, payload_type: str, lhost: str, lport: int,
                           additional_options: Optional[Dict[str, Any]] = None,
                           exit_on_session: bool = False) -> Dict[str, Any]:
        """
        啟動監聽器
        
        Args:
            payload_type: 載荷類型
            lhost: 監聽主機
            lport: 監聽端口
            additional_options: 額外選項
            exit_on_session: 會話建立後是否退出
            
        Returns:
            啟動結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.start_listener(
            payload_type=payload_type,
            lhost=lhost,
            lport=lport,
            additional_options=additional_options,
            exit_on_session=exit_on_session
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to start listener: {response.error}")
            return {'success': False, 'error': response.error}
    
    async def stop_job(self, job_id: int) -> bool:
        """
        停止後台任務
        
        Args:
            job_id: 任務ID
            
        Returns:
            是否成功停止
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.stop_job(job_id)
        return response.success
    
    # 輔助模組方法
    async def run_auxiliary(self, module_name: str, options: Dict[str, Any],
                           run_as_job: bool = False) -> Dict[str, Any]:
        """
        運行輔助模組
        
        Args:
            module_name: 模組名稱
            options: 模組選項
            run_as_job: 是否作為後台任務運行
            
        Returns:
            執行結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.run_auxiliary_module(
            module_name=module_name,
            options=options,
            run_as_job=run_as_job
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to run auxiliary module {module_name}: {response.error}")
            return {'success': False, 'error': response.error}
    
    async def run_post_module(self, module_name: str, session_id: int,
                             options: Optional[Dict[str, Any]] = None,
                             run_as_job: bool = False) -> Dict[str, Any]:
        """
        運行後滲透模組
        
        Args:
            module_name: 模組名稱
            session_id: 會話ID
            options: 模組選項
            run_as_job: 是否作為後台任務運行
            
        Returns:
            執行結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to Metasploit MCP")
        
        response = await self.client.run_post_module(
            module_name=module_name,
            session_id=session_id,
            options=options or {},
            run_as_job=run_as_job
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to run post module {module_name}: {response.error}")
            return {'success': False, 'error': response.error}


# 便利函數
async def create_metasploit_client(timeout: int = 30) -> MetasploitMCP:
    """
    創建並連接 Metasploit MCP 客戶端
    
    Args:
        timeout: 請求超時時間
        
    Returns:
        已連接的 MetasploitMCP 實例
    """
    client = MetasploitMCP(timeout)
    await client.connect()
    return client