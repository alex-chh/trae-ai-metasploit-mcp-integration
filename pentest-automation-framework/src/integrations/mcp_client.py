#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MCP 客戶端整合模組
MCP Client Integration Module

提供與 Metasploit 和 GitHub MCP 服務器的整合功能
"""

import asyncio
import json
import time
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from pathlib import Path

try:
    import httpx
except ImportError:
    httpx = None

from ..core.logger import get_logger


@dataclass
class MCPResponse:
    """
    MCP 響應數據類
    """
    success: bool
    data: Any = None
    error: Optional[str] = None
    execution_time: Optional[float] = None


class BaseMCPClient:
    """
    基礎 MCP 客戶端
    """
    
    def __init__(self, server_name: str, timeout: int = 30):
        """
        初始化 MCP 客戶端
        
        Args:
            server_name: MCP 服務器名稱
            timeout: 超時時間（秒）
        """
        self.server_name = server_name
        self.timeout = timeout
        self.logger = get_logger()
        self.session = None
        
        if httpx is None:
            raise ImportError("需要安裝 httpx: pip install httpx")
    
    async def __aenter__(self):
        """異步上下文管理器入口"""
        self.session = httpx.AsyncClient(timeout=self.timeout)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """異步上下文管理器出口"""
        if self.session:
            await self.session.aclose()
    
    async def call_tool(self, tool_name: str, args: Dict[str, Any]) -> MCPResponse:
        """
        調用 MCP 工具
        
        Args:
            tool_name: 工具名稱
            args: 工具參數
            
        Returns:
            MCP 響應
        """
        start_time = time.time()
        
        try:
            # 構建請求數據
            request_data = {
                "server_name": self.server_name,
                "tool_name": tool_name,
                "args": args
            }
            
            self.logger.debug(f"調用 MCP 工具: {self.server_name}.{tool_name}", {
                "args": args
            })
            
            # 這裡應該是實際的 MCP 調用邏輯
            # 由於我們在模擬環境中，這裡返回模擬響應
            response_data = await self._simulate_mcp_call(tool_name, args)
            
            execution_time = time.time() - start_time
            
            self.logger.info(f"MCP 工具調用成功: {tool_name}", {
                "execution_time": execution_time,
                "server": self.server_name
            })
            
            return MCPResponse(
                success=True,
                data=response_data,
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            error_msg = f"MCP 工具調用失敗: {str(e)}"
            
            self.logger.error(error_msg, {
                "tool_name": tool_name,
                "server": self.server_name,
                "execution_time": execution_time
            }, exc_info=True)
            
            return MCPResponse(
                success=False,
                error=error_msg,
                execution_time=execution_time
            )
    
    async def _simulate_mcp_call(self, tool_name: str, args: Dict[str, Any]) -> Any:
        """
        模擬 MCP 調用（實際實現中應該替換為真實的 MCP 通信）
        
        Args:
            tool_name: 工具名稱
            args: 工具參數
            
        Returns:
            模擬響應數據
        """
        # 模擬網絡延遲
        await asyncio.sleep(0.1)
        
        return {
            "tool": tool_name,
            "args": args,
            "timestamp": time.time(),
            "simulated": True
        }


class MetasploitMCPClient(BaseMCPClient):
    """
    Metasploit MCP 客戶端
    """
    
    def __init__(self, timeout: int = 30):
        super().__init__("mcp.config.usrlocalmcp.metasploit-1", timeout)
    
    async def list_exploits(self, search_term: str = "") -> MCPResponse:
        """
        列出可用的漏洞利用模組
        
        Args:
            search_term: 搜索關鍵詞
            
        Returns:
            漏洞利用模組列表
        """
        return await self.call_tool("list_exploits", {
            "search_term": search_term
        })
    
    async def list_payloads(self, platform: str = "", arch: str = "") -> MCPResponse:
        """
        列出可用的載荷
        
        Args:
            platform: 平台過濾
            arch: 架構過濾
            
        Returns:
            載荷列表
        """
        return await self.call_tool("list_payloads", {
            "platform": platform,
            "arch": arch
        })
    
    async def generate_payload(self, payload_type: str, format_type: str, 
                              options: Dict[str, Any], **kwargs) -> MCPResponse:
        """
        生成載荷
        
        Args:
            payload_type: 載荷類型
            format_type: 輸出格式
            options: 載荷選項
            **kwargs: 其他參數
            
        Returns:
            生成的載荷信息
        """
        args = {
            "payload_type": payload_type,
            "format_type": format_type,
            "options": options
        }
        args.update(kwargs)
        
        return await self.call_tool("generate_payload", args)
    
    async def run_exploit(self, module_name: str, options: Dict[str, Any],
                         payload_name: Optional[str] = None,
                         payload_options: Optional[Dict[str, Any]] = None,
                         **kwargs) -> MCPResponse:
        """
        運行漏洞利用模組
        
        Args:
            module_name: 模組名稱
            options: 模組選項
            payload_name: 載荷名稱
            payload_options: 載荷選項
            **kwargs: 其他參數
            
        Returns:
            執行結果
        """
        args = {
            "module_name": module_name,
            "options": options
        }
        
        if payload_name:
            args["payload_name"] = payload_name
        if payload_options:
            args["payload_options"] = payload_options
        
        args.update(kwargs)
        
        return await self.call_tool("run_exploit", args)
    
    async def run_auxiliary_module(self, module_name: str, options: Dict[str, Any],
                                  **kwargs) -> MCPResponse:
        """
        運行輔助模組
        
        Args:
            module_name: 模組名稱
            options: 模組選項
            **kwargs: 其他參數
            
        Returns:
            執行結果
        """
        args = {
            "module_name": module_name,
            "options": options
        }
        args.update(kwargs)
        
        return await self.call_tool("run_auxiliary_module", args)
    
    async def list_active_sessions(self) -> MCPResponse:
        """
        列出活動會話
        
        Returns:
            活動會話列表
        """
        return await self.call_tool("list_active_sessions", {})
    
    async def send_session_command(self, session_id: int, command: str,
                                  timeout_seconds: int = 60) -> MCPResponse:
        """
        向會話發送命令
        
        Args:
            session_id: 會話 ID
            command: 命令
            timeout_seconds: 超時時間
            
        Returns:
            命令執行結果
        """
        return await self.call_tool("send_session_command", {
            "session_id": session_id,
            "command": command,
            "timeout_seconds": timeout_seconds
        })
    
    async def start_listener(self, payload_type: str, lhost: str, lport: int,
                           **kwargs) -> MCPResponse:
        """
        啟動監聽器
        
        Args:
            payload_type: 載荷類型
            lhost: 監聽主機
            lport: 監聽端口
            **kwargs: 其他參數
            
        Returns:
            監聽器信息
        """
        args = {
            "payload_type": payload_type,
            "lhost": lhost,
            "lport": lport
        }
        args.update(kwargs)
        
        return await self.call_tool("start_listener", args)
    
    async def stop_job(self, job_id: int) -> MCPResponse:
        """
        停止作業
        
        Args:
            job_id: 作業 ID
            
        Returns:
            停止結果
        """
        return await self.call_tool("stop_job", {
            "job_id": job_id
        })
    
    async def terminate_session(self, session_id: int) -> MCPResponse:
        """
        終止會話
        
        Args:
            session_id: 會話 ID
            
        Returns:
            終止結果
        """
        return await self.call_tool("terminate_session", {
            "session_id": session_id
        })


class GitHubMCPClient(BaseMCPClient):
    """
    GitHub MCP 客戶端
    """
    
    def __init__(self, timeout: int = 30):
        super().__init__("mcp.config.usrlocalmcp.GitHub", timeout)
    
    async def create_repository(self, name: str, description: str = "",
                               private: bool = False, auto_init: bool = True) -> MCPResponse:
        """
        創建倉庫
        
        Args:
            name: 倉庫名稱
            description: 倉庫描述
            private: 是否私有
            auto_init: 是否自動初始化
            
        Returns:
            創建結果
        """
        return await self.call_tool("create_repository", {
            "name": name,
            "description": description,
            "private": private,
            "autoInit": auto_init
        })
    
    async def create_or_update_file(self, owner: str, repo: str, path: str,
                                   content: str, message: str, branch: str = "main",
                                   sha: Optional[str] = None) -> MCPResponse:
        """
        創建或更新文件
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            path: 文件路徑
            content: 文件內容
            message: 提交消息
            branch: 分支名稱
            sha: 文件 SHA（更新時需要）
            
        Returns:
            操作結果
        """
        args = {
            "owner": owner,
            "repo": repo,
            "path": path,
            "content": content,
            "message": message,
            "branch": branch
        }
        
        if sha:
            args["sha"] = sha
        
        return await self.call_tool("create_or_update_file", args)
    
    async def push_files(self, owner: str, repo: str, branch: str,
                        files: List[Dict[str, str]], message: str) -> MCPResponse:
        """
        推送多個文件
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            branch: 分支名稱
            files: 文件列表 [{"path": "...", "content": "..."}]
            message: 提交消息
            
        Returns:
            推送結果
        """
        return await self.call_tool("push_files", {
            "owner": owner,
            "repo": repo,
            "branch": branch,
            "files": files,
            "message": message
        })
    
    async def get_file_contents(self, owner: str, repo: str, path: str,
                               branch: Optional[str] = None) -> MCPResponse:
        """
        獲取文件內容
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            path: 文件路徑
            branch: 分支名稱
            
        Returns:
            文件內容
        """
        args = {
            "owner": owner,
            "repo": repo,
            "path": path
        }
        
        if branch:
            args["branch"] = branch
        
        return await self.call_tool("get_file_contents", args)
    
    async def create_issue(self, owner: str, repo: str, title: str,
                          body: str = "", **kwargs) -> MCPResponse:
        """
        創建問題
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            title: 問題標題
            body: 問題內容
            **kwargs: 其他參數
            
        Returns:
            創建結果
        """
        args = {
            "owner": owner,
            "repo": repo,
            "title": title,
            "body": body
        }
        args.update(kwargs)
        
        return await self.call_tool("create_issue", args)
    
    async def search_repositories(self, query: str, page: int = 1,
                                 per_page: int = 30) -> MCPResponse:
        """
        搜索倉庫
        
        Args:
            query: 搜索查詢
            page: 頁碼
            per_page: 每頁數量
            
        Returns:
            搜索結果
        """
        return await self.call_tool("search_repositories", {
            "query": query,
            "page": page,
            "perPage": per_page
        })


class MCPManager:
    """
    MCP 管理器
    
    統一管理所有 MCP 客戶端
    """
    
    def __init__(self):
        self.logger = get_logger()
        self.metasploit_client = None
        self.github_client = None
    
    async def __aenter__(self):
        """異步上下文管理器入口"""
        self.metasploit_client = MetasploitMCPClient()
        self.github_client = GitHubMCPClient()
        
        await self.metasploit_client.__aenter__()
        await self.github_client.__aenter__()
        
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """異步上下文管理器出口"""
        if self.metasploit_client:
            await self.metasploit_client.__aexit__(exc_type, exc_val, exc_tb)
        if self.github_client:
            await self.github_client.__aexit__(exc_type, exc_val, exc_tb)
    
    def get_metasploit_client(self) -> MetasploitMCPClient:
        """
        獲取 Metasploit 客戶端
        
        Returns:
            Metasploit MCP 客戶端
        """
        if self.metasploit_client is None:
            raise RuntimeError("MCP 管理器未初始化，請使用 async with 語句")
        return self.metasploit_client
    
    def get_github_client(self) -> GitHubMCPClient:
        """
        獲取 GitHub 客戶端
        
        Returns:
            GitHub MCP 客戶端
        """
        if self.github_client is None:
            raise RuntimeError("MCP 管理器未初始化，請使用 async with 語句")
        return self.github_client
    
    async def health_check(self) -> Dict[str, bool]:
        """
        健康檢查
        
        Returns:
            各客戶端的健康狀態
        """
        results = {}
        
        # 檢查 Metasploit 客戶端
        try:
            response = await self.metasploit_client.list_active_sessions()
            results['metasploit'] = response.success
        except Exception as e:
            self.logger.error(f"Metasploit 健康檢查失敗: {e}")
            results['metasploit'] = False
        
        # 檢查 GitHub 客戶端
        try:
            response = await self.github_client.search_repositories("test")
            results['github'] = response.success
        except Exception as e:
            self.logger.error(f"GitHub 健康檢查失敗: {e}")
            results['github'] = False
        
        return results