#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitHub MCP 整合模組
GitHub MCP Integration Module

提供與 GitHub MCP 服務器的整合功能
"""

import asyncio
import json
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from pathlib import Path

from .mcp_client import GitHubMCPClient, MCPResponse
from ..core.logger import get_logger


class GitHubMCP:
    """
    GitHub MCP 整合類
    
    提供高級 GitHub 操作接口
    """
    
    def __init__(self, config=None, timeout: int = 30):
        """
        初始化 GitHub MCP 客戶端
        
        Args:
            config: GitHub 配置對象
            timeout: 請求超時時間
        """
        # 如果提供了配置對象，使用其中的 timeout；否則使用默認值
        if config and hasattr(config, 'timeout'):
            timeout = config.timeout
        
        self.config = config
        self.client = GitHubMCPClient(timeout)
        self.logger = get_logger()
        self._connected = False
    
    async def __aenter__(self):
        """異步上下文管理器入口"""
        await self.client.__aenter__()
        self._connected = True
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """異步上下文管理器出口"""
        await self.client.__aexit__(exc_type, exc_val, exc_tb)
        self._connected = False
    
    async def connect(self) -> bool:
        """
        連接到 GitHub MCP 服務器
        
        Returns:
            連接是否成功
        """
        try:
            await self.client.__aenter__()
            self._connected = True
            self.logger.info("Successfully connected to GitHub MCP")
            return True
        except Exception as e:
            self.logger.error(f"Failed to connect to GitHub MCP: {e}")
            return False
    
    async def disconnect(self):
        """斷開與 GitHub MCP 服務器的連接"""
        if self._connected:
            await self.client.__aexit__(None, None, None)
            self._connected = False
            self.logger.info("Disconnected from GitHub MCP")
    
    async def cleanup(self):
        """清理 GitHub MCP 連接"""
        await self.disconnect()
    
    @property
    def is_connected(self) -> bool:
        """檢查是否已連接"""
        return self._connected
    
    # 倉庫管理方法
    async def create_repository(self, name: str, description: str = "", 
                               private: bool = False, auto_init: bool = True) -> Dict[str, Any]:
        """
        創建新倉庫
        
        Args:
            name: 倉庫名稱
            description: 倉庫描述
            private: 是否為私有倉庫
            auto_init: 是否自動初始化
            
        Returns:
            創建結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.create_repository(
            name=name,
            description=description,
            private=private,
            autoInit=auto_init
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to create repository {name}: {response.error}")
            return {'success': False, 'error': response.error}
    
    async def search_repositories(self, query: str, page: int = 1, 
                                 per_page: int = 30) -> List[Dict[str, Any]]:
        """
        搜索倉庫
        
        Args:
            query: 搜索查詢
            page: 頁碼
            per_page: 每頁結果數
            
        Returns:
            搜索結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.search_repositories(
            query=query,
            page=page,
            perPage=per_page
        )
        
        if response.success:
            return response.data.get('items', [])
        else:
            self.logger.error(f"Failed to search repositories: {response.error}")
            return []
    
    # 文件管理方法
    async def get_file_contents(self, owner: str, repo: str, path: str, 
                               branch: str = "main") -> Optional[str]:
        """
        獲取文件內容
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            path: 文件路徑
            branch: 分支名稱
            
        Returns:
            文件內容
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.get_file_contents(
            owner=owner,
            repo=repo,
            path=path,
            branch=branch
        )
        
        if response.success:
            return response.data.get('content', '')
        else:
            self.logger.error(f"Failed to get file contents: {response.error}")
            return None
    
    async def create_or_update_file(self, owner: str, repo: str, path: str,
                                   content: str, message: str, branch: str = "main",
                                   sha: Optional[str] = None) -> Dict[str, Any]:
        """
        創建或更新文件
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            path: 文件路徑
            content: 文件內容
            message: 提交消息
            branch: 分支名稱
            sha: 文件SHA（更新時需要）
            
        Returns:
            操作結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        params = {
            'owner': owner,
            'repo': repo,
            'path': path,
            'content': content,
            'message': message,
            'branch': branch
        }
        
        if sha:
            params['sha'] = sha
        
        response = await self.client.create_or_update_file(**params)
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to create/update file: {response.error}")
            return {'success': False, 'error': response.error}
    
    async def push_files(self, owner: str, repo: str, branch: str,
                        files: List[Dict[str, str]], message: str) -> Dict[str, Any]:
        """
        批量推送文件
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            branch: 分支名稱
            files: 文件列表 [{'path': '...', 'content': '...'}, ...]
            message: 提交消息
            
        Returns:
            推送結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.push_files(
            owner=owner,
            repo=repo,
            branch=branch,
            files=files,
            message=message
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to push files: {response.error}")
            return {'success': False, 'error': response.error}
    
    # Issue 管理方法
    async def create_issue(self, owner: str, repo: str, title: str, body: str = "",
                          assignees: Optional[List[str]] = None,
                          labels: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        創建 Issue
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            title: Issue 標題
            body: Issue 內容
            assignees: 指派人員
            labels: 標籤
            
        Returns:
            創建結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.create_issue(
            owner=owner,
            repo=repo,
            title=title,
            body=body,
            assignees=assignees or [],
            labels=labels or []
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to create issue: {response.error}")
            return {'success': False, 'error': response.error}
    
    async def list_issues(self, owner: str, repo: str, state: str = "open",
                         labels: Optional[List[str]] = None,
                         page: int = 1, per_page: int = 30) -> List[Dict[str, Any]]:
        """
        列出 Issues
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            state: Issue 狀態 (open/closed/all)
            labels: 標籤過濾
            page: 頁碼
            per_page: 每頁結果數
            
        Returns:
            Issue 列表
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.list_issues(
            owner=owner,
            repo=repo,
            state=state,
            labels=labels or [],
            page=page,
            per_page=per_page
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to list issues: {response.error}")
            return []
    
    # Pull Request 管理方法
    async def create_pull_request(self, owner: str, repo: str, title: str,
                                 head: str, base: str, body: str = "",
                                 draft: bool = False) -> Dict[str, Any]:
        """
        創建 Pull Request
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            title: PR 標題
            head: 源分支
            base: 目標分支
            body: PR 內容
            draft: 是否為草稿
            
        Returns:
            創建結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.create_pull_request(
            owner=owner,
            repo=repo,
            title=title,
            head=head,
            base=base,
            body=body,
            draft=draft
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to create pull request: {response.error}")
            return {'success': False, 'error': response.error}
    
    async def list_pull_requests(self, owner: str, repo: str, state: str = "open",
                                page: int = 1, per_page: int = 30) -> List[Dict[str, Any]]:
        """
        列出 Pull Requests
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            state: PR 狀態 (open/closed/all)
            page: 頁碼
            per_page: 每頁結果數
            
        Returns:
            PR 列表
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.list_pull_requests(
            owner=owner,
            repo=repo,
            state=state,
            per_page=per_page,
            page=page
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to list pull requests: {response.error}")
            return []
    
    # 分支管理方法
    async def create_branch(self, owner: str, repo: str, branch: str,
                           from_branch: str = "main") -> Dict[str, Any]:
        """
        創建分支
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            branch: 新分支名稱
            from_branch: 源分支
            
        Returns:
            創建結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.create_branch(
            owner=owner,
            repo=repo,
            branch=branch,
            from_branch=from_branch
        )
        
        if response.success:
            return response.data
        else:
            self.logger.error(f"Failed to create branch: {response.error}")
            return {'success': False, 'error': response.error}
    
    # 搜索方法
    async def search_code(self, query: str, page: int = 1, 
                         per_page: int = 30) -> List[Dict[str, Any]]:
        """
        搜索代碼
        
        Args:
            query: 搜索查詢
            page: 頁碼
            per_page: 每頁結果數
            
        Returns:
            搜索結果
        """
        if not self._connected:
            raise RuntimeError("Not connected to GitHub MCP")
        
        response = await self.client.search_code(
            q=query,
            page=page,
            per_page=per_page
        )
        
        if response.success:
            return response.data.get('items', [])
        else:
            self.logger.error(f"Failed to search code: {response.error}")
            return []
    
    # 便利方法
    async def upload_report(self, owner: str, repo: str, report_path: str,
                           report_content: str, branch: str = "main") -> Dict[str, Any]:
        """
        上傳滲透測試報告
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            report_path: 報告文件路徑
            report_content: 報告內容
            branch: 分支名稱
            
        Returns:
            上傳結果
        """
        timestamp = asyncio.get_event_loop().time()
        message = f"Upload penetration test report - {timestamp}"
        
        return await self.create_or_update_file(
            owner=owner,
            repo=repo,
            path=report_path,
            content=report_content,
            message=message,
            branch=branch
        )
    
    async def create_pentest_issue(self, owner: str, repo: str, 
                                  vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        為發現的漏洞創建 Issue
        
        Args:
            owner: 倉庫所有者
            repo: 倉庫名稱
            vulnerability: 漏洞信息
            
        Returns:
            創建結果
        """
        title = f"[Security] {vulnerability.get('name', 'Unknown Vulnerability')}"
        
        body = f"""
## 漏洞詳情

**類型**: {vulnerability.get('type', 'Unknown')}
**嚴重程度**: {vulnerability.get('severity', 'Unknown')}
**目標**: {vulnerability.get('target', 'Unknown')}
**端口**: {vulnerability.get('port', 'Unknown')}

## 描述

{vulnerability.get('description', 'No description available')}

## 建議修復方案

{vulnerability.get('remediation', 'No remediation available')}

## 發現時間

{vulnerability.get('timestamp', 'Unknown')}
"""
        
        labels = ['security', 'vulnerability']
        if vulnerability.get('severity'):
            labels.append(f"severity-{vulnerability['severity'].lower()}")
        
        return await self.create_issue(
            owner=owner,
            repo=repo,
            title=title,
            body=body,
            labels=labels
        )


# 便利函數
async def create_github_client(timeout: int = 30) -> GitHubMCP:
    """
    創建並連接 GitHub MCP 客戶端
    
    Args:
        timeout: 請求超時時間
        
    Returns:
        已連接的 GitHubMCP 實例
    """
    client = GitHubMCP(timeout)
    await client.connect()
    return client