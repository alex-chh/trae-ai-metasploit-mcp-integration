#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
漏洞掃描模組
Vulnerability Scanner Module

提供漏洞檢測和評估功能
"""

import asyncio
import json
import re
import time
import subprocess
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum
import xml.etree.ElementTree as ET

from ..core.logger import get_logger
from .network_scanner import HostInfo, PortInfo
from ..utils.progress_display import get_progress_manager, ProgressBar, SpinnerDisplay


class VulnerabilitySeverity(Enum):
    """
    漏洞嚴重程度
    """
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(Enum):
    """
    漏洞狀態
    """
    VULNERABLE = "vulnerable"
    NOT_VULNERABLE = "not_vulnerable"
    UNKNOWN = "unknown"
    ERROR = "error"


@dataclass
class VulnerabilityInfo:
    """
    漏洞信息
    """
    vuln_id: str
    name: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float] = None
    cve_ids: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    solution: Optional[str] = None
    exploit_available: bool = False
    metasploit_modules: List[str] = field(default_factory=list)
    nessus_plugins: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)


@dataclass
class VulnerabilityResult:
    """
    漏洞掃描結果
    """
    target_ip: str
    target_port: Optional[int] = None
    service: Optional[str] = None
    vulnerability: Optional[VulnerabilityInfo] = None
    status: VulnerabilityStatus = VulnerabilityStatus.UNKNOWN
    evidence: Optional[str] = None
    scan_time: float = field(default_factory=time.time)
    scanner_name: Optional[str] = None
    raw_output: Optional[str] = None
    confidence: Optional[int] = None
    false_positive: bool = False


@dataclass
class VulnerabilityScanReport:
    """
    漏洞掃描報告
    """
    scan_id: str
    target: str
    start_time: float
    end_time: Optional[float] = None
    duration: Optional[float] = None
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    info_count: int = 0
    results: List[VulnerabilityResult] = field(default_factory=list)
    scan_config: Optional[Dict[str, Any]] = None
    errors: List[str] = field(default_factory=list)


class VulnerabilityScanner:
    """
    漏洞掃描器
    
    整合多種漏洞掃描工具和技術
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        初始化漏洞掃描器
        
        Args:
            config: 掃描配置
        """
        self.config = config or {}
        self.logger = get_logger()
        
        # 默認配置
        self.default_config = {
            'nmap_path': 'nmap',
            'timeout': 600,
            'max_concurrent': 3,
            'script_timeout': 300,
            'vuln_databases': {
                'nmap_scripts': True,
                'custom_checks': True,
                'cve_database': True
            },
            'scan_profiles': {
                'quick': {
                    'scripts': ['vuln', 'safe'],
                    'timeout': 300
                },
                'comprehensive': {
                    'scripts': ['vuln', 'safe', 'intrusive'],
                    'timeout': 900
                },
                'web': {
                    'scripts': ['http-*', 'ssl-*'],
                    'timeout': 600
                },
                'database': {
                    'scripts': ['mysql-*', 'ms-sql-*', 'oracle-*'],
                    'timeout': 600
                }
            }
        }
        
        # 合併配置
        for key, value in self.default_config.items():
            if key not in self.config:
                self.config[key] = value
        
        # 初始化漏洞數據庫
        self.vulnerability_db = self._load_vulnerability_database()
    
    async def scan_vulnerabilities(self, target: str, 
                                 scan_profile: str = "comprehensive",
                                 host_info: Optional[HostInfo] = None,
                                 **kwargs) -> VulnerabilityScanReport:
        """
        掃描漏洞
        
        Args:
            target: 目標（IP 或域名）
            scan_profile: 掃描配置文件
            host_info: 主機信息（來自網絡掃描）
            **kwargs: 其他參數
            
        Returns:
            漏洞掃描報告
        """
        scan_id = f"vuln_scan_{int(time.time())}"
        start_time = time.time()
        progress_manager = get_progress_manager()
        spinner = None
        
        self.logger.info(f"開始漏洞掃描: {target}", {
            "scan_id": scan_id,
            "scan_profile": scan_profile,
            "target": target
        })
        
        try:
            # 創建進度指示器
            spinner = progress_manager.create_spinner(
                "vulnerability_scan", 
                f"正在執行漏洞掃描: {target} ({scan_profile} 模式)..."
            )
            spinner.start()
            
            # 獲取掃描配置
            spinner.update_message("獲取掃描配置...")
            profile_config = self.config['scan_profiles'].get(
                scan_profile, self.config['scan_profiles']['comprehensive']
            )
            
            # 執行不同類型的掃描
            all_results = []
            
            # 1. Nmap 腳本掃描
            if self.config['vuln_databases']['nmap_scripts']:
                spinner.update_message("執行 Nmap 腳本掃描...")
                nmap_results = await self._scan_with_nmap_scripts(
                    target, profile_config, host_info, spinner
                )
                all_results.extend(nmap_results)
            
            # 2. 自定義檢查
            if self.config['vuln_databases']['custom_checks']:
                spinner.update_message("執行自定義漏洞檢查...")
                custom_results = await self._scan_with_custom_checks(
                    target, host_info, spinner
                )
                all_results.extend(custom_results)
            
            # 3. CVE 數據庫檢查
            if self.config['vuln_databases']['cve_database'] and host_info:
                spinner.update_message("執行 CVE 數據庫檢查...")
                cve_results = await self._scan_with_cve_database(
                    target, host_info, spinner
                )
                all_results.extend(cve_results)
            
            # 計算統計信息
            spinner.update_message("分析掃描結果...")
            stats = self._calculate_statistics(all_results)
            
            end_time = time.time()
            duration = end_time - start_time
            
            report = VulnerabilityScanReport(
                scan_id=scan_id,
                target=target,
                start_time=start_time,
                end_time=end_time,
                duration=duration,
                total_vulnerabilities=len(all_results),
                critical_count=stats['critical'],
                high_count=stats['high'],
                medium_count=stats['medium'],
                low_count=stats['low'],
                info_count=stats['info'],
                results=all_results,
                scan_config=profile_config
            )
            
            # 停止進度指示器
            spinner.stop(f"✓ 漏洞掃描完成: 發現 {len(all_results)} 個漏洞 (嚴重: {stats['critical']}, 高: {stats['high']}, 中: {stats['medium']}, 低: {stats['low']})")
            
            self.logger.info(f"漏洞掃描完成: {target}", {
                "scan_id": scan_id,
                "duration": duration,
                "total_vulnerabilities": len(all_results),
                "critical": stats['critical'],
                "high": stats['high']
            })
            
            return report
            
        except Exception as e:
            if spinner:
                spinner.stop(f"✗ 漏洞掃描失敗: {str(e)}")
            
            end_time = time.time()
            duration = end_time - start_time
            
            error_msg = f"漏洞掃描失敗: {str(e)}"
            self.logger.error(error_msg, {
                "scan_id": scan_id,
                "target": target,
                "duration": duration
            }, exc_info=True)
            
            return VulnerabilityScanReport(
                scan_id=scan_id,
                target=target,
                start_time=start_time,
                end_time=end_time,
                duration=duration,
                errors=[error_msg]
            )
    
    async def _scan_with_nmap_scripts(self, target: str, 
                                    profile_config: Dict[str, Any],
                                    host_info: Optional[HostInfo] = None,
                                    spinner: Optional[SpinnerDisplay] = None) -> List[VulnerabilityResult]:
        """
        使用 Nmap 腳本掃描漏洞
        
        Args:
            target: 目標
            profile_config: 配置文件
            host_info: 主機信息
            
        Returns:
            漏洞結果列表
        """
        results = []
        
        try:
            # 構建 Nmap 命令
            command = [self.config['nmap_path']]
            
            # 添加腳本選項
            scripts = profile_config.get('scripts', ['vuln'])
            script_args = ','.join(scripts)
            command.extend(['--script', script_args])
            
            # 添加其他選項
            command.extend(['-sV', '-oX', '-'])  # 服務檢測和 XML 輸出
            
            # 如果有主機信息，只掃描開放的端口
            if host_info and host_info.ports:
                open_ports = [str(p.port) for p in host_info.ports if p.state == 'open']
                if open_ports:
                    command.extend(['-p', ','.join(open_ports)])
            
            command.append(target)
            
            # 執行掃描
            if spinner:
                spinner.update_message(f"執行 Nmap 腳本掃描: {' '.join(command[:3])}...")
            
            self.logger.debug(f"執行 Nmap 腳本掃描: {' '.join(command)}")
            
            process = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=profile_config.get('timeout', 600)
            )
            
            xml_output = stdout.decode('utf-8', errors='ignore')
            
            # 解析結果
            results = self._parse_nmap_vuln_output(xml_output, target)
            
        except asyncio.TimeoutError:
            self.logger.warning(f"Nmap 腳本掃描超時: {target}")
        except Exception as e:
            self.logger.error(f"Nmap 腳本掃描失敗: {e}")
        
        return results
    
    def _parse_nmap_vuln_output(self, xml_output: str, target: str) -> List[VulnerabilityResult]:
        """
        解析 Nmap 漏洞掃描輸出
        
        Args:
            xml_output: XML 輸出
            target: 目標
            
        Returns:
            漏洞結果列表
        """
        results = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host in root.findall('host'):
                # 獲取 IP 地址
                addr_elem = host.find('address[@addrtype="ipv4"]')
                if addr_elem is None:
                    continue
                
                host_ip = addr_elem.get('addr')
                
                # 解析端口和腳本結果
                ports = host.find('ports')
                if ports is not None:
                    for port in ports.findall('port'):
                        port_num = int(port.get('portid'))
                        
                        # 獲取服務信息
                        service_elem = port.find('service')
                        service_name = service_elem.get('name') if service_elem is not None else None
                        
                        # 解析腳本結果
                        script_results = port.findall('script')
                        for script in script_results:
                            script_id = script.get('id')
                            script_output = script.get('output', '')
                            
                            # 檢查是否為漏洞腳本
                            if self._is_vulnerability_script(script_id, script_output):
                                vuln_result = self._parse_script_vulnerability(
                                    script_id, script_output, host_ip, port_num, service_name
                                )
                                if vuln_result:
                                    results.append(vuln_result)
                
                # 解析主機級別的腳本結果
                hostscript = host.find('hostscript')
                if hostscript is not None:
                    for script in hostscript.findall('script'):
                        script_id = script.get('id')
                        script_output = script.get('output', '')
                        
                        if self._is_vulnerability_script(script_id, script_output):
                            vuln_result = self._parse_script_vulnerability(
                                script_id, script_output, host_ip, None, None
                            )
                            if vuln_result:
                                results.append(vuln_result)
        
        except ET.ParseError as e:
            self.logger.error(f"解析 Nmap XML 輸出失敗: {e}")
        except Exception as e:
            self.logger.error(f"處理 Nmap 漏洞掃描結果時發生錯誤: {e}")
        
        return results
    
    def _is_vulnerability_script(self, script_id: str, output: str) -> bool:
        """
        判斷是否為漏洞腳本
        
        Args:
            script_id: 腳本 ID
            output: 腳本輸出
            
        Returns:
            是否為漏洞腳本
        """
        # 漏洞相關的腳本 ID 模式
        vuln_patterns = [
            r'.*vuln.*',
            r'.*cve.*',
            r'.*exploit.*',
            r'.*backdoor.*',
            r'.*dos.*',
            r'.*injection.*'
        ]
        
        for pattern in vuln_patterns:
            if re.match(pattern, script_id, re.IGNORECASE):
                return True
        
        # 檢查輸出中的漏洞關鍵詞
        vuln_keywords = [
            'VULNERABLE', 'CVE-', 'EXPLOIT', 'BACKDOOR',
            'INJECTION', 'XSS', 'SQL', 'BUFFER OVERFLOW'
        ]
        
        output_upper = output.upper()
        for keyword in vuln_keywords:
            if keyword in output_upper:
                return True
        
        return False
    
    def _parse_script_vulnerability(self, script_id: str, output: str,
                                  host_ip: str, port: Optional[int],
                                  service: Optional[str]) -> Optional[VulnerabilityResult]:
        """
        解析腳本漏洞信息
        
        Args:
            script_id: 腳本 ID
            output: 腳本輸出
            host_ip: 主機 IP
            port: 端口號
            service: 服務名稱
            
        Returns:
            漏洞結果
        """
        try:
            # 提取 CVE 編號
            cve_pattern = r'CVE-\d{4}-\d{4,}'
            cve_matches = re.findall(cve_pattern, output)
            
            # 判斷漏洞狀態
            status = VulnerabilityStatus.UNKNOWN
            if 'VULNERABLE' in output.upper():
                status = VulnerabilityStatus.VULNERABLE
            elif 'NOT VULNERABLE' in output.upper() or 'SAFE' in output.upper():
                status = VulnerabilityStatus.NOT_VULNERABLE
            
            # 只報告確認的漏洞
            if status != VulnerabilityStatus.VULNERABLE:
                return None
            
            # 創建漏洞信息
            vuln_info = self._create_vulnerability_info(
                script_id, output, cve_matches
            )
            
            # 創建漏洞結果
            result = VulnerabilityResult(
                target_ip=host_ip,
                target_port=port,
                service=service,
                vulnerability=vuln_info,
                status=status,
                evidence=output,
                scanner_name=f"nmap-{script_id}",
                raw_output=output,
                confidence=self._calculate_confidence(script_id, output)
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"解析腳本漏洞失敗: {e}")
            return None
    
    def _create_vulnerability_info(self, script_id: str, output: str,
                                 cve_ids: List[str]) -> VulnerabilityInfo:
        """
        創建漏洞信息
        
        Args:
            script_id: 腳本 ID
            output: 腳本輸出
            cve_ids: CVE 編號列表
            
        Returns:
            漏洞信息
        """
        # 從數據庫查找漏洞信息
        vuln_info = self.vulnerability_db.get(script_id)
        
        if vuln_info:
            # 使用數據庫中的信息
            return VulnerabilityInfo(
                vuln_id=vuln_info['id'],
                name=vuln_info['name'],
                description=vuln_info['description'],
                severity=VulnerabilitySeverity(vuln_info['severity']),
                cvss_score=vuln_info.get('cvss_score'),
                cve_ids=cve_ids or vuln_info.get('cve_ids', []),
                cwe_ids=vuln_info.get('cwe_ids', []),
                references=vuln_info.get('references', []),
                solution=vuln_info.get('solution'),
                exploit_available=vuln_info.get('exploit_available', False),
                metasploit_modules=vuln_info.get('metasploit_modules', []),
                tags=vuln_info.get('tags', [])
            )
        else:
            # 創建基本漏洞信息
            severity = self._determine_severity(script_id, output)
            
            return VulnerabilityInfo(
                vuln_id=script_id,
                name=script_id.replace('-', ' ').title(),
                description=f"通過 {script_id} 腳本檢測到的漏洞",
                severity=severity,
                cve_ids=cve_ids,
                tags=[script_id]
            )
    
    def _determine_severity(self, script_id: str, output: str) -> VulnerabilitySeverity:
        """
        確定漏洞嚴重程度
        
        Args:
            script_id: 腳本 ID
            output: 腳本輸出
            
        Returns:
            漏洞嚴重程度
        """
        output_lower = output.lower()
        script_lower = script_id.lower()
        
        # 高危漏洞關鍵詞
        critical_keywords = ['rce', 'remote code execution', 'backdoor', 'root']
        high_keywords = ['exploit', 'buffer overflow', 'injection', 'bypass']
        medium_keywords = ['disclosure', 'enumeration', 'brute', 'weak']
        
        for keyword in critical_keywords:
            if keyword in output_lower or keyword in script_lower:
                return VulnerabilitySeverity.CRITICAL
        
        for keyword in high_keywords:
            if keyword in output_lower or keyword in script_lower:
                return VulnerabilitySeverity.HIGH
        
        for keyword in medium_keywords:
            if keyword in output_lower or keyword in script_lower:
                return VulnerabilitySeverity.MEDIUM
        
        return VulnerabilitySeverity.LOW
    
    def _calculate_confidence(self, script_id: str, output: str) -> int:
        """
        計算置信度
        
        Args:
            script_id: 腳本 ID
            output: 腳本輸出
            
        Returns:
            置信度 (0-100)
        """
        confidence = 50  # 基礎置信度
        
        # 根據腳本類型調整
        if 'vuln' in script_id:
            confidence += 20
        
        # 根據輸出內容調整
        if 'VULNERABLE' in output.upper():
            confidence += 20
        
        if re.search(r'CVE-\d{4}-\d{4,}', output):
            confidence += 15
        
        if 'exploit' in output.lower():
            confidence += 10
        
        return min(confidence, 100)
    
    async def _scan_with_custom_checks(self, target: str,
                                     host_info: Optional[HostInfo] = None,
                                     spinner: Optional[SpinnerDisplay] = None) -> List[VulnerabilityResult]:
        """
        使用自定義檢查掃描漏洞
        
        Args:
            target: 目標
            host_info: 主機信息
            
        Returns:
            漏洞結果列表
        """
        results = []
        
        try:
            # 實現自定義漏洞檢查邏輯
            # 這裡可以添加特定的漏洞檢查方法
            
            # 示例：檢查常見的弱密碼
            if host_info and host_info.ports:
                for port in host_info.ports:
                    if port.state == 'open' and port.service:
                        if spinner:
                            spinner.update_message(f"檢查 {port.service}:{port.port} 弱憑證...")
                        weak_cred_result = await self._check_weak_credentials(
                            target, port.port, port.service
                        )
                        if weak_cred_result:
                            results.append(weak_cred_result)
            
        except Exception as e:
            self.logger.error(f"自定義漏洞檢查失敗: {e}")
        
        return results
    
    async def _check_weak_credentials(self, target: str, port: int,
                                    service: str) -> Optional[VulnerabilityResult]:
        """
        檢查弱憑證
        
        Args:
            target: 目標
            port: 端口
            service: 服務
            
        Returns:
            漏洞結果
        """
        # 實現弱憑證檢查邏輯
        # 這裡只是示例，實際實現需要根據具體服務
        
        common_services = ['ssh', 'ftp', 'telnet', 'mysql', 'mssql']
        
        if service.lower() in common_services:
            # 創建弱憑證漏洞信息
            vuln_info = VulnerabilityInfo(
                vuln_id="weak-credentials",
                name="Weak Credentials",
                description=f"{service} 服務可能使用弱憑證",
                severity=VulnerabilitySeverity.MEDIUM,
                solution="使用強密碼並啟用多因素認證"
            )
            
            return VulnerabilityResult(
                target_ip=target,
                target_port=port,
                service=service,
                vulnerability=vuln_info,
                status=VulnerabilityStatus.UNKNOWN,
                scanner_name="custom-weak-creds",
                confidence=30
            )
        
        return None
    
    async def _scan_with_cve_database(self, target: str,
                                     host_info: HostInfo,
                                     spinner: Optional[SpinnerDisplay] = None) -> List[VulnerabilityResult]:
        """
        使用 CVE 數據庫掃描漏洞
        
        Args:
            target: 目標
            host_info: 主機信息
            
        Returns:
            漏洞結果列表
        """
        results = []
        
        try:
            # 根據服務版本信息查找已知漏洞
            for port in host_info.ports:
                if port.state == 'open' and port.product and port.version:
                    if spinner:
                        spinner.update_message(f"查找 {port.product} {port.version} CVE...")
                    cve_results = await self._lookup_cve_for_service(
                        target, port, port.product, port.version
                    )
                    results.extend(cve_results)
        
        except Exception as e:
            self.logger.error(f"CVE 數據庫掃描失敗: {e}")
        
        return results
    
    async def _lookup_cve_for_service(self, target: str, port: PortInfo,
                                     product: str, version: str) -> List[VulnerabilityResult]:
        """
        為服務查找 CVE
        
        Args:
            target: 目標
            port: 端口信息
            product: 產品名稱
            version: 版本號
            
        Returns:
            漏洞結果列表
        """
        # 實現 CVE 查找邏輯
        # 這裡需要連接到 CVE 數據庫或 API
        
        # 示例實現
        results = []
        
        # 模擬查找已知漏洞
        known_vulns = {
            'apache': {
                '2.4.49': ['CVE-2021-41773', 'CVE-2021-42013'],
                '2.4.50': ['CVE-2021-44790']
            },
            'openssh': {
                '7.4': ['CVE-2018-15473'],
                '8.2': ['CVE-2020-15778']
            }
        }
        
        product_lower = product.lower()
        for known_product, versions in known_vulns.items():
            if known_product in product_lower:
                for known_version, cves in versions.items():
                    if version.startswith(known_version):
                        for cve in cves:
                            vuln_info = VulnerabilityInfo(
                                vuln_id=cve,
                                name=f"{product} {version} 漏洞",
                                description=f"{product} {version} 存在已知漏洞 {cve}",
                                severity=VulnerabilitySeverity.HIGH,
                                cve_ids=[cve]
                            )
                            
                            result = VulnerabilityResult(
                                target_ip=target,
                                target_port=port.port,
                                service=port.service,
                                vulnerability=vuln_info,
                                status=VulnerabilityStatus.VULNERABLE,
                                scanner_name="cve-database",
                                confidence=80
                            )
                            
                            results.append(result)
        
        return results
    
    def _calculate_statistics(self, results: List[VulnerabilityResult]) -> Dict[str, int]:
        """
        計算漏洞統計信息
        
        Args:
            results: 漏洞結果列表
            
        Returns:
            統計信息
        """
        stats = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0
        }
        
        for result in results:
            if result.vulnerability and result.status == VulnerabilityStatus.VULNERABLE:
                severity = result.vulnerability.severity.value
                if severity in stats:
                    stats[severity] += 1
        
        return stats
    
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """
        加載漏洞數據庫
        
        Returns:
            漏洞數據庫
        """
        # 實現漏洞數據庫加載邏輯
        # 這裡可以從文件、數據庫或 API 加載
        
        # 示例數據庫
        return {
            'smb-vuln-ms17-010': {
                'id': 'MS17-010',
                'name': 'EternalBlue SMB Vulnerability',
                'description': 'Microsoft SMB 服務器遠程代碼執行漏洞',
                'severity': 'critical',
                'cvss_score': 9.3,
                'cve_ids': ['CVE-2017-0144', 'CVE-2017-0145'],
                'cwe_ids': ['CWE-119'],
                'solution': '安裝 Microsoft 安全更新 MS17-010',
                'exploit_available': True,
                'metasploit_modules': ['exploit/windows/smb/ms17_010_eternalblue'],
                'references': [
                    'https://docs.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-010'
                ]
            },
            'http-vuln-cve2017-5638': {
                'id': 'CVE-2017-5638',
                'name': 'Apache Struts2 Remote Code Execution',
                'description': 'Apache Struts2 遠程代碼執行漏洞',
                'severity': 'critical',
                'cvss_score': 9.8,
                'cve_ids': ['CVE-2017-5638'],
                'solution': '升級到 Struts 2.3.32 或 2.5.10.1',
                'exploit_available': True,
                'metasploit_modules': ['exploit/multi/http/struts2_content_type_ognl']
            }
        }
    
    def export_report(self, report: VulnerabilityScanReport,
                     output_path: str, format_type: str = "json"):
        """
        導出漏洞掃描報告
        
        Args:
            report: 掃描報告
            output_path: 輸出路徑
            format_type: 格式類型
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        if format_type.lower() == "json":
            self._export_json_report(report, output_path)
        elif format_type.lower() == "html":
            self._export_html_report(report, output_path)
        elif format_type.lower() == "csv":
            self._export_csv_report(report, output_path)
        else:
            raise ValueError(f"不支持的格式: {format_type}")
        
        self.logger.info(f"漏洞掃描報告已導出: {output_path}")
    
    def _export_json_report(self, report: VulnerabilityScanReport, output_path: Path):
        """
        導出 JSON 格式報告
        """
        data = {
            'scan_info': {
                'scan_id': report.scan_id,
                'target': report.target,
                'start_time': report.start_time,
                'end_time': report.end_time,
                'duration': report.duration
            },
            'statistics': {
                'total_vulnerabilities': report.total_vulnerabilities,
                'critical': report.critical_count,
                'high': report.high_count,
                'medium': report.medium_count,
                'low': report.low_count,
                'info': report.info_count
            },
            'vulnerabilities': [],
            'errors': report.errors
        }
        
        for result in report.results:
            vuln_data = {
                'target_ip': result.target_ip,
                'target_port': result.target_port,
                'service': result.service,
                'status': result.status.value,
                'scanner': result.scanner_name,
                'confidence': result.confidence,
                'scan_time': result.scan_time
            }
            
            if result.vulnerability:
                vuln = result.vulnerability
                vuln_data['vulnerability'] = {
                    'id': vuln.vuln_id,
                    'name': vuln.name,
                    'description': vuln.description,
                    'severity': vuln.severity.value,
                    'cvss_score': vuln.cvss_score,
                    'cve_ids': vuln.cve_ids,
                    'cwe_ids': vuln.cwe_ids,
                    'solution': vuln.solution,
                    'exploit_available': vuln.exploit_available,
                    'metasploit_modules': vuln.metasploit_modules,
                    'references': vuln.references
                }
            
            if result.evidence:
                vuln_data['evidence'] = result.evidence
            
            data['vulnerabilities'].append(vuln_data)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    def _export_html_report(self, report: VulnerabilityScanReport, output_path: Path):
        """
        導出 HTML 格式報告
        """
        html_template = """
<!DOCTYPE html>
<html>
<head>
    <title>漏洞掃描報告</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f0f0f0; padding: 20px; border-radius: 5px; }
        .stats { display: flex; gap: 20px; margin: 20px 0; }
        .stat-box { padding: 15px; border-radius: 5px; text-align: center; }
        .critical { background: #ffebee; color: #c62828; }
        .high { background: #fff3e0; color: #ef6c00; }
        .medium { background: #fff8e1; color: #f57f17; }
        .low { background: #f3e5f5; color: #7b1fa2; }
        .vuln-item { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .vuln-header { font-weight: bold; margin-bottom: 10px; }
        .evidence { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 3px; font-family: monospace; }
    </style>
</head>
<body>
    <div class="header">
        <h1>漏洞掃描報告</h1>
        <p><strong>目標:</strong> {target}</p>
        <p><strong>掃描時間:</strong> {scan_time}</p>
        <p><strong>持續時間:</strong> {duration:.2f} 秒</p>
    </div>
    
    <div class="stats">
        <div class="stat-box critical">
            <h3>{critical}</h3>
            <p>嚴重</p>
        </div>
        <div class="stat-box high">
            <h3>{high}</h3>
            <p>高危</p>
        </div>
        <div class="stat-box medium">
            <h3>{medium}</h3>
            <p>中危</p>
        </div>
        <div class="stat-box low">
            <h3>{low}</h3>
            <p>低危</p>
        </div>
    </div>
    
    <h2>漏洞詳情</h2>
    {vulnerabilities}
</body>
</html>
        """
        
        # 生成漏洞列表 HTML
        vuln_html = ""
        for result in report.results:
            if result.vulnerability and result.status == VulnerabilityStatus.VULNERABLE:
                vuln = result.vulnerability
                severity_class = vuln.severity.value
                
                vuln_item = f"""
                <div class="vuln-item {severity_class}">
                    <div class="vuln-header">{vuln.name} ({vuln.severity.value.upper()})</div>
                    <p><strong>目標:</strong> {result.target_ip}:{result.target_port or 'N/A'}</p>
                    <p><strong>服務:</strong> {result.service or 'N/A'}</p>
                    <p><strong>描述:</strong> {vuln.description}</p>
                    {f'<p><strong>CVE:</strong> {', '.join(vuln.cve_ids)}</p>' if vuln.cve_ids else ''}
                    {f'<p><strong>解決方案:</strong> {vuln.solution}</p>' if vuln.solution else ''}
                    {f'<div class="evidence"><strong>證據:</strong><br>{result.evidence}</div>' if result.evidence else ''}
                </div>
                """
                vuln_html += vuln_item
        
        # 填充模板
        html_content = html_template.format(
            target=report.target,
            scan_time=time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(report.start_time)),
            duration=report.duration or 0,
            critical=report.critical_count,
            high=report.high_count,
            medium=report.medium_count,
            low=report.low_count,
            vulnerabilities=vuln_html
        )
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
    
    def _export_csv_report(self, report: VulnerabilityScanReport, output_path: Path):
        """
        導出 CSV 格式報告
        """
        import csv
        
        with open(output_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # 寫入標題
            writer.writerow([
                'Target IP', 'Port', 'Service', 'Vulnerability ID',
                'Vulnerability Name', 'Severity', 'Status', 'CVE IDs',
                'CVSS Score', 'Solution', 'Scanner', 'Confidence'
            ])
            
            # 寫入數據
            for result in report.results:
                if result.vulnerability:
                    vuln = result.vulnerability
                    writer.writerow([
                        result.target_ip,
                        result.target_port or '',
                        result.service or '',
                        vuln.vuln_id,
                        vuln.name,
                        vuln.severity.value,
                        result.status.value,
                        ', '.join(vuln.cve_ids),
                        vuln.cvss_score or '',
                        vuln.solution or '',
                        result.scanner_name or '',
                        result.confidence or ''
                    ])