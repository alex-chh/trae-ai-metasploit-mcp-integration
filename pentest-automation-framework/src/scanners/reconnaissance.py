#!/usr/bin/env python3
"""
偵察模組 - 目標發現和初始偵察功能
實現目標識別、域名解析、子域名發現、WHOIS查詢等功能
"""

import asyncio
import socket
import subprocess
import json
import re
import time
from typing import List, Dict, Optional, Set, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum
import ipaddress
import dns.resolver
import requests
from urllib.parse import urlparse

from ..utils.logger import get_logger
from ..utils.progress_display import get_progress_manager, ProgressBar

logger = get_logger(__name__)

class ReconType(Enum):
    """偵察類型枚舉"""
    DOMAIN_ENUM = "domain_enumeration"
    SUBDOMAIN_DISCOVERY = "subdomain_discovery"
    DNS_ENUMERATION = "dns_enumeration"
    WHOIS_LOOKUP = "whois_lookup"
    PORT_DISCOVERY = "port_discovery"
    SERVICE_DETECTION = "service_detection"
    WEB_ENUMERATION = "web_enumeration"
    OSINT_GATHERING = "osint_gathering"

@dataclass
class DomainInfo:
    """域名信息數據結構"""
    domain: str
    ip_addresses: List[str] = field(default_factory=list)
    subdomains: List[str] = field(default_factory=list)
    mx_records: List[str] = field(default_factory=list)
    ns_records: List[str] = field(default_factory=list)
    txt_records: List[str] = field(default_factory=list)
    whois_info: Dict = field(default_factory=dict)
    web_technologies: List[str] = field(default_factory=list)
    open_ports: List[int] = field(default_factory=list)
    services: Dict[int, str] = field(default_factory=dict)

@dataclass
class ReconResult:
    """偵察結果數據結構"""
    target: str
    recon_type: ReconType
    timestamp: float
    success: bool
    data: Dict
    error_message: Optional[str] = None
    duration: float = 0.0

class ReconnaissanceScanner:
    """偵察掃描器類"""
    
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.timeout = self.config.get('timeout', 30)
        self.max_concurrent = self.config.get('max_concurrent', 10)
        self.wordlists_path = Path(self.config.get('wordlists_path', 'wordlists'))
        self.user_agent = self.config.get('user_agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
        
        # 初始化DNS解析器
        self.dns_resolver = dns.resolver.Resolver()
        self.dns_resolver.timeout = 5
        self.dns_resolver.lifetime = 10
        
        # 子域名字典
        self.subdomain_wordlist = self._load_subdomain_wordlist()
        
        logger.info("偵察掃描器初始化完成")
    
    def _load_subdomain_wordlist(self) -> List[str]:
        """加載子域名字典"""
        default_subdomains = [
            'www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging', 'api',
            'blog', 'shop', 'forum', 'support', 'help', 'docs', 'cdn',
            'static', 'media', 'images', 'assets', 'js', 'css', 'files',
            'download', 'upload', 'backup', 'old', 'new', 'beta', 'alpha',
            'demo', 'sandbox', 'vpn', 'remote', 'secure', 'ssl', 'tls',
            'mx', 'mx1', 'mx2', 'ns', 'ns1', 'ns2', 'dns', 'pop', 'imap',
            'smtp', 'webmail', 'email', 'portal', 'gateway', 'proxy',
            'load-balancer', 'lb', 'cluster', 'node1', 'node2', 'server',
            'db', 'database', 'mysql', 'postgres', 'redis', 'mongo',
            'elastic', 'search', 'log', 'logs', 'monitor', 'metrics'
        ]
        
        wordlist_file = self.wordlists_path / 'subdomains.txt'
        if wordlist_file.exists():
            try:
                with open(wordlist_file, 'r', encoding='utf-8') as f:
                    custom_subdomains = [line.strip() for line in f if line.strip()]
                return list(set(default_subdomains + custom_subdomains))
            except Exception as e:
                logger.warning(f"無法加載自定義子域名字典: {e}")
        
        return default_subdomains
    
    async def perform_reconnaissance(self, target: str, recon_types: List[ReconType] = None) -> List[ReconResult]:
        """執行完整偵察"""
        if recon_types is None:
            recon_types = list(ReconType)
        
        logger.info(f"開始對目標 {target} 進行偵察")
        results = []
        
        progress_manager = get_progress_manager()
        progress_bar = ProgressBar(
            total=len(recon_types),
            description=f"偵察 {target}",
            unit="項目"
        )
        
        with progress_manager.progress(progress_bar):
            for recon_type in recon_types:
                try:
                    result = await self._perform_single_recon(target, recon_type)
                    results.append(result)
                    progress_bar.update(1)
                except Exception as e:
                    logger.error(f"偵察類型 {recon_type.value} 失敗: {e}")
                    results.append(ReconResult(
                        target=target,
                        recon_type=recon_type,
                        timestamp=time.time(),
                        success=False,
                        data={},
                        error_message=str(e)
                    ))
                    progress_bar.update(1)
        
        logger.info(f"偵察完成，共獲得 {len(results)} 個結果")
        return results
    
    async def _perform_single_recon(self, target: str, recon_type: ReconType) -> ReconResult:
        """執行單個偵察任務"""
        start_time = time.time()
        
        try:
            if recon_type == ReconType.DOMAIN_ENUM:
                data = await self._domain_enumeration(target)
            elif recon_type == ReconType.SUBDOMAIN_DISCOVERY:
                data = await self._subdomain_discovery(target)
            elif recon_type == ReconType.DNS_ENUMERATION:
                data = await self._dns_enumeration(target)
            elif recon_type == ReconType.WHOIS_LOOKUP:
                data = await self._whois_lookup(target)
            elif recon_type == ReconType.PORT_DISCOVERY:
                data = await self._port_discovery(target)
            elif recon_type == ReconType.SERVICE_DETECTION:
                data = await self._service_detection(target)
            elif recon_type == ReconType.WEB_ENUMERATION:
                data = await self._web_enumeration(target)
            elif recon_type == ReconType.OSINT_GATHERING:
                data = await self._osint_gathering(target)
            else:
                raise ValueError(f"不支持的偵察類型: {recon_type}")
            
            duration = time.time() - start_time
            return ReconResult(
                target=target,
                recon_type=recon_type,
                timestamp=start_time,
                success=True,
                data=data,
                duration=duration
            )
        
        except Exception as e:
            duration = time.time() - start_time
            return ReconResult(
                target=target,
                recon_type=recon_type,
                timestamp=start_time,
                success=False,
                data={},
                error_message=str(e),
                duration=duration
            )
    
    async def _domain_enumeration(self, target: str) -> Dict:
        """域名枚舉"""
        logger.info(f"執行域名枚舉: {target}")
        
        domain_info = {
            'domain': target,
            'is_valid_domain': False,
            'ip_addresses': [],
            'reverse_dns': {},
            'domain_age': None,
            'registrar': None
        }
        
        # 驗證域名格式
        if self._is_valid_domain(target):
            domain_info['is_valid_domain'] = True
            
            # 解析IP地址
            try:
                answers = self.dns_resolver.resolve(target, 'A')
                domain_info['ip_addresses'] = [str(answer) for answer in answers]
                
                # 反向DNS查詢
                for ip in domain_info['ip_addresses']:
                    try:
                        reverse = socket.gethostbyaddr(ip)
                        domain_info['reverse_dns'][ip] = reverse[0]
                    except:
                        domain_info['reverse_dns'][ip] = None
            except Exception as e:
                logger.warning(f"域名解析失敗: {e}")
        
        return domain_info
    
    async def _subdomain_discovery(self, target: str) -> Dict:
        """子域名發現"""
        logger.info(f"執行子域名發現: {target}")
        
        subdomains = {
            'found_subdomains': [],
            'active_subdomains': [],
            'total_tested': 0,
            'methods_used': ['dns_bruteforce', 'certificate_transparency']
        }
        
        # DNS暴力破解
        dns_subdomains = await self._dns_bruteforce_subdomains(target)
        subdomains['found_subdomains'].extend(dns_subdomains)
        subdomains['total_tested'] = len(self.subdomain_wordlist)
        
        # 證書透明度查詢
        ct_subdomains = await self._certificate_transparency_search(target)
        subdomains['found_subdomains'].extend(ct_subdomains)
        
        # 去重並驗證活躍子域名
        unique_subdomains = list(set(subdomains['found_subdomains']))
        subdomains['found_subdomains'] = unique_subdomains
        
        # 驗證子域名是否活躍
        for subdomain in unique_subdomains:
            if await self._is_subdomain_active(subdomain):
                subdomains['active_subdomains'].append(subdomain)
        
        return subdomains
    
    async def _dns_bruteforce_subdomains(self, domain: str) -> List[str]:
        """DNS暴力破解子域名"""
        found_subdomains = []
        
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        async def check_subdomain(subdomain_prefix: str):
            async with semaphore:
                subdomain = f"{subdomain_prefix}.{domain}"
                try:
                    answers = self.dns_resolver.resolve(subdomain, 'A')
                    if answers:
                        found_subdomains.append(subdomain)
                        logger.debug(f"發現子域名: {subdomain}")
                except:
                    pass
        
        tasks = [check_subdomain(prefix) for prefix in self.subdomain_wordlist]
        await asyncio.gather(*tasks, return_exceptions=True)
        
        return found_subdomains
    
    async def _certificate_transparency_search(self, domain: str) -> List[str]:
        """證書透明度搜索"""
        subdomains = []
        
        try:
            # 使用crt.sh API
            url = f"https://crt.sh/?q=%.{domain}&output=json"
            response = requests.get(url, timeout=self.timeout)
            
            if response.status_code == 200:
                certificates = response.json()
                for cert in certificates:
                    name_value = cert.get('name_value', '')
                    # 解析證書中的域名
                    for line in name_value.split('\n'):
                        line = line.strip()
                        if line.endswith(f'.{domain}') and '*' not in line:
                            subdomains.append(line)
        
        except Exception as e:
            logger.warning(f"證書透明度搜索失敗: {e}")
        
        return list(set(subdomains))
    
    async def _is_subdomain_active(self, subdomain: str) -> bool:
        """檢查子域名是否活躍"""
        try:
            answers = self.dns_resolver.resolve(subdomain, 'A')
            return len(answers) > 0
        except:
            return False
    
    async def _dns_enumeration(self, target: str) -> Dict:
        """DNS枚舉"""
        logger.info(f"執行DNS枚舉: {target}")
        
        dns_info = {
            'a_records': [],
            'aaaa_records': [],
            'mx_records': [],
            'ns_records': [],
            'txt_records': [],
            'cname_records': [],
            'soa_record': None,
            'ptr_records': []
        }
        
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'CNAME', 'SOA']
        
        for record_type in record_types:
            try:
                answers = self.dns_resolver.resolve(target, record_type)
                records = [str(answer) for answer in answers]
                dns_info[f'{record_type.lower()}_records'] = records
            except Exception as e:
                logger.debug(f"DNS記錄類型 {record_type} 查詢失敗: {e}")
        
        return dns_info
    
    async def _whois_lookup(self, target: str) -> Dict:
        """WHOIS查詢"""
        logger.info(f"執行WHOIS查詢: {target}")
        
        whois_info = {
            'domain': target,
            'registrar': None,
            'creation_date': None,
            'expiration_date': None,
            'name_servers': [],
            'status': [],
            'raw_whois': ''
        }
        
        try:
            # 使用whois命令
            process = await asyncio.create_subprocess_exec(
                'whois', target,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=self.timeout
            )
            
            if process.returncode == 0:
                raw_whois = stdout.decode('utf-8', errors='ignore')
                whois_info['raw_whois'] = raw_whois
                
                # 解析WHOIS信息
                whois_info.update(self._parse_whois_data(raw_whois))
        
        except Exception as e:
            logger.warning(f"WHOIS查詢失敗: {e}")
        
        return whois_info
    
    def _parse_whois_data(self, whois_data: str) -> Dict:
        """解析WHOIS數據"""
        parsed = {}
        
        # 簡單的正則表達式解析
        patterns = {
            'registrar': r'Registrar:\s*(.+)',
            'creation_date': r'Creation Date:\s*(.+)',
            'expiration_date': r'Registry Expiry Date:\s*(.+)',
        }
        
        for key, pattern in patterns.items():
            match = re.search(pattern, whois_data, re.IGNORECASE)
            if match:
                parsed[key] = match.group(1).strip()
        
        return parsed
    
    async def _port_discovery(self, target: str) -> Dict:
        """端口發現"""
        logger.info(f"執行端口發現: {target}")
        
        # 常見端口列表
        common_ports = [
            21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 993, 995,
            1723, 3306, 3389, 5432, 5900, 6379, 8080, 8443, 9200, 27017
        ]
        
        open_ports = []
        port_info = {}
        
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        async def check_port(port: int):
            async with semaphore:
                try:
                    reader, writer = await asyncio.wait_for(
                        asyncio.open_connection(target, port),
                        timeout=3
                    )
                    writer.close()
                    await writer.wait_closed()
                    open_ports.append(port)
                    logger.debug(f"發現開放端口: {target}:{port}")
                except:
                    pass
        
        tasks = [check_port(port) for port in common_ports]
        await asyncio.gather(*tasks, return_exceptions=True)
        
        return {
            'open_ports': sorted(open_ports),
            'total_scanned': len(common_ports),
            'port_details': port_info
        }
    
    async def _service_detection(self, target: str) -> Dict:
        """服務檢測"""
        logger.info(f"執行服務檢測: {target}")
        
        # 這裡可以集成nmap或其他工具進行服務檢測
        # 暫時返回基本信息
        return {
            'services': {},
            'os_detection': None,
            'version_detection': {}
        }
    
    async def _web_enumeration(self, target: str) -> Dict:
        """Web枚舉"""
        logger.info(f"執行Web枚舉: {target}")
        
        web_info = {
            'http_status': None,
            'https_status': None,
            'server_header': None,
            'technologies': [],
            'directories': [],
            'files': []
        }
        
        # 檢查HTTP和HTTPS
        for protocol in ['http', 'https']:
            url = f"{protocol}://{target}"
            try:
                response = requests.get(
                    url, 
                    timeout=self.timeout,
                    headers={'User-Agent': self.user_agent},
                    verify=False
                )
                
                if protocol == 'http':
                    web_info['http_status'] = response.status_code
                else:
                    web_info['https_status'] = response.status_code
                
                # 獲取服務器信息
                if 'server' in response.headers:
                    web_info['server_header'] = response.headers['server']
                
                # 技術檢測
                web_info['technologies'].extend(
                    self._detect_web_technologies(response)
                )
            
            except Exception as e:
                logger.debug(f"{protocol.upper()} 連接失敗: {e}")
        
        return web_info
    
    def _detect_web_technologies(self, response) -> List[str]:
        """檢測Web技術"""
        technologies = []
        
        # 檢查響應頭
        headers = response.headers
        
        if 'x-powered-by' in headers:
            technologies.append(f"X-Powered-By: {headers['x-powered-by']}")
        
        if 'server' in headers:
            server = headers['server'].lower()
            if 'apache' in server:
                technologies.append('Apache')
            elif 'nginx' in server:
                technologies.append('Nginx')
            elif 'iis' in server:
                technologies.append('IIS')
        
        # 檢查響應內容
        content = response.text.lower()
        
        if 'wordpress' in content:
            technologies.append('WordPress')
        if 'drupal' in content:
            technologies.append('Drupal')
        if 'joomla' in content:
            technologies.append('Joomla')
        
        return technologies
    
    async def _osint_gathering(self, target: str) -> Dict:
        """OSINT信息收集"""
        logger.info(f"執行OSINT信息收集: {target}")
        
        osint_info = {
            'shodan_results': {},
            'social_media': {},
            'breach_data': {},
            'public_records': {}
        }
        
        # 這裡可以集成各種OSINT工具和API
        # 暫時返回空結果
        return osint_info
    
    def _is_valid_domain(self, domain: str) -> bool:
        """驗證域名格式"""
        domain_pattern = re.compile(
            r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+'  # 子域名
            r'[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$'  # 頂級域名
        )
        return bool(domain_pattern.match(domain))
    
    def generate_domain_info(self, recon_results: List[ReconResult]) -> DomainInfo:
        """生成域名信息摘要"""
        if not recon_results:
            return DomainInfo(domain="unknown")
        
        target = recon_results[0].target
        domain_info = DomainInfo(domain=target)
        
        for result in recon_results:
            if not result.success:
                continue
            
            data = result.data
            
            if result.recon_type == ReconType.DOMAIN_ENUM:
                domain_info.ip_addresses.extend(data.get('ip_addresses', []))
            
            elif result.recon_type == ReconType.SUBDOMAIN_DISCOVERY:
                domain_info.subdomains.extend(data.get('active_subdomains', []))
            
            elif result.recon_type == ReconType.DNS_ENUMERATION:
                domain_info.mx_records.extend(data.get('mx_records', []))
                domain_info.ns_records.extend(data.get('ns_records', []))
                domain_info.txt_records.extend(data.get('txt_records', []))
            
            elif result.recon_type == ReconType.WHOIS_LOOKUP:
                domain_info.whois_info = data
            
            elif result.recon_type == ReconType.PORT_DISCOVERY:
                domain_info.open_ports.extend(data.get('open_ports', []))
            
            elif result.recon_type == ReconType.WEB_ENUMERATION:
                domain_info.web_technologies.extend(data.get('technologies', []))
        
        # 去重
        domain_info.ip_addresses = list(set(domain_info.ip_addresses))
        domain_info.subdomains = list(set(domain_info.subdomains))
        domain_info.mx_records = list(set(domain_info.mx_records))
        domain_info.ns_records = list(set(domain_info.ns_records))
        domain_info.txt_records = list(set(domain_info.txt_records))
        domain_info.web_technologies = list(set(domain_info.web_technologies))
        domain_info.open_ports = sorted(list(set(domain_info.open_ports)))
        
        return domain_info
    
    def save_results(self, results: List[ReconResult], output_file: Path):
        """保存偵察結果"""
        output_data = {
            'timestamp': time.time(),
            'total_results': len(results),
            'successful_results': len([r for r in results if r.success]),
            'results': []
        }
        
        for result in results:
            output_data['results'].append({
                'target': result.target,
                'recon_type': result.recon_type.value,
                'timestamp': result.timestamp,
                'success': result.success,
                'data': result.data,
                'error_message': result.error_message,
                'duration': result.duration
            })
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(output_data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"偵察結果已保存到: {output_file}")