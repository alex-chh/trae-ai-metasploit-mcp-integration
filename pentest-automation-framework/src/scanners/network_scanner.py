#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
網絡掃描模組
Network Scanner Module

提供網絡發現和端口掃描功能
"""

import asyncio
import ipaddress
import socket
import subprocess
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass, field
from pathlib import Path
import json
import time
import re

from ..core.logger import get_logger
from ..utils.progress_display import get_progress_manager, ProgressBar, SpinnerDisplay


@dataclass
class PortInfo:
    """
    端口信息
    """
    port: int
    protocol: str
    state: str
    service: Optional[str] = None
    version: Optional[str] = None
    product: Optional[str] = None
    extra_info: Optional[str] = None
    confidence: Optional[int] = None


@dataclass
class HostInfo:
    """
    主機信息
    """
    ip: str
    hostname: Optional[str] = None
    mac_address: Optional[str] = None
    vendor: Optional[str] = None
    os_info: Optional[Dict[str, Any]] = None
    ports: List[PortInfo] = field(default_factory=list)
    status: str = "unknown"
    response_time: Optional[float] = None
    last_seen: Optional[float] = None


@dataclass
class ScanResult:
    """
    掃描結果
    """
    scan_id: str
    target: str
    scan_type: str
    start_time: float
    end_time: Optional[float] = None
    duration: Optional[float] = None
    hosts: List[HostInfo] = field(default_factory=list)
    total_hosts: int = 0
    alive_hosts: int = 0
    total_ports: int = 0
    open_ports: int = 0
    scan_command: Optional[str] = None
    raw_output: Optional[str] = None
    errors: List[str] = field(default_factory=list)


class NetworkScanner:
    """
    網絡掃描器
    
    提供多種網絡掃描功能
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        初始化網絡掃描器
        
        Args:
            config: 掃描配置
        """
        self.config = config or {}
        self.logger = get_logger()
        
        # 默認配置
        self.default_config = {
            'nmap_path': 'nmap',
            'timeout': 300,
            'max_concurrent': 5,
            'default_ports': '1-1000',
            'scan_options': {
                'quick': '-T4 -p 21,22,23,25,53,80,110,111,135,139,143,443,993,995,1723,3306,3389,5432,5900,8080',
                'comprehensive': '-T4 -A -sV -sC',
                'stealth': '-T2 -sS -f',
                'udp': '-sU --top-ports 1000',
                'os_detection': '-O',
                'service_detection': '-sV',
                'script_scan': '-sC'
            }
        }
        
        # 合併配置
        for key, value in self.default_config.items():
            if key not in self.config:
                self.config[key] = value
    
    async def scan_network(self, target: str, scan_type: str = "comprehensive",
                          ports: Optional[str] = None, **kwargs) -> ScanResult:
        """
        掃描網絡
        
        Args:
            target: 目標（IP、域名或 CIDR）
            scan_type: 掃描類型
            ports: 端口範圍
            **kwargs: 其他參數
            
        Returns:
            掃描結果
        """
        scan_id = f"scan_{int(time.time())}"
        start_time = time.time()
        progress_manager = get_progress_manager()
        spinner = None
        
        self.logger.info(f"開始網絡掃描: {target}", {
            "scan_id": scan_id,
            "scan_type": scan_type,
            "target": target
        })
        
        try:
            # 創建進度指示器
            spinner = progress_manager.create_spinner(
                "network_scan", 
                f"正在掃描 {target} ({scan_type} 模式)..."
            )
            spinner.start()
            
            # 驗證目標
            spinner.update_message(f"驗證掃描目標...")
            validated_target = self._validate_target(target)
            
            # 構建掃描命令
            spinner.update_message(f"構建掃描命令...")
            command = self._build_nmap_command(
                validated_target, scan_type, ports, **kwargs
            )
            
            # 執行掃描
            spinner.update_message(f"執行網絡掃描 {target}...")
            raw_output, errors = await self._execute_nmap(command)
            
            # 解析結果
            spinner.update_message(f"解析掃描結果...")
            hosts = self._parse_nmap_output(raw_output)
            
            # 計算統計信息
            total_hosts = len(hosts)
            alive_hosts = len([h for h in hosts if h.status == "up"])
            total_ports = sum(len(h.ports) for h in hosts)
            open_ports = sum(len([p for p in h.ports if p.state == "open"]) for h in hosts)
            
            end_time = time.time()
            duration = end_time - start_time
            
            result = ScanResult(
                scan_id=scan_id,
                target=target,
                scan_type=scan_type,
                start_time=start_time,
                end_time=end_time,
                duration=duration,
                hosts=hosts,
                total_hosts=total_hosts,
                alive_hosts=alive_hosts,
                total_ports=total_ports,
                open_ports=open_ports,
                scan_command=" ".join(command),
                raw_output=raw_output,
                errors=errors
            )
            
            # 停止進度指示器
            if spinner:
                spinner.stop(f"✓ 網絡掃描完成: {target} (發現 {alive_hosts} 個活動主機, {open_ports} 個開放端口)")
            
            self.logger.info(f"網絡掃描完成: {target}", {
                "scan_id": scan_id,
                "duration": duration,
                "alive_hosts": alive_hosts,
                "open_ports": open_ports
            })
            
            return result
            
        except Exception as e:
            end_time = time.time()
            duration = end_time - start_time
            
            error_msg = f"網絡掃描失敗: {str(e)}"
            
            # 停止進度指示器
            if spinner:
                spinner.stop(f"✗ 網絡掃描失敗: {str(e)}")
            
            self.logger.error(error_msg, {
                "scan_id": scan_id,
                "target": target,
                "duration": duration
            }, exc_info=True)
            
            return ScanResult(
                scan_id=scan_id,
                target=target,
                scan_type=scan_type,
                start_time=start_time,
                end_time=end_time,
                duration=duration,
                errors=[error_msg]
            )
    
    def _validate_target(self, target: str) -> str:
        """
        驗證掃描目標
        
        Args:
            target: 目標字符串
            
        Returns:
            驗證後的目標
            
        Raises:
            ValueError: 目標格式無效
        """
        target = target.strip()
        
        # 檢查是否為 IP 地址
        try:
            ipaddress.ip_address(target)
            return target
        except ValueError:
            pass
        
        # 檢查是否為 CIDR 網段
        try:
            ipaddress.ip_network(target, strict=False)
            return target
        except ValueError:
            pass
        
        # 檢查是否為域名
        if re.match(r'^[a-zA-Z0-9.-]+$', target):
            return target
        
        # 檢查是否為 IP 範圍
        if '-' in target or ',' in target:
            return target
        
        raise ValueError(f"無效的掃描目標: {target}")
    
    def _build_nmap_command(self, target: str, scan_type: str,
                           ports: Optional[str] = None, **kwargs) -> List[str]:
        """
        構建 nmap 命令
        
        Args:
            target: 目標
            scan_type: 掃描類型
            ports: 端口範圍
            **kwargs: 其他參數
            
        Returns:
            命令列表
        """
        command = [self.config['nmap_path']]
        
        # 添加基本選項
        command.extend(['-oX', '-'])  # XML 輸出到標準輸出
        
        # 添加掃描類型選項
        scan_options = self.config['scan_options'].get(scan_type, '')
        if scan_options:
            if isinstance(scan_options, str):
                command.extend(scan_options.split())
            elif isinstance(scan_options, list):
                # 確保列表中的每個項目都是字符串，並正確處理
                for option in scan_options:
                    if isinstance(option, str):
                        # 將字符串選項分割並添加到命令中
                        option_parts = option.split()
                        command.extend(option_parts)
                    else:
                        command.append(str(option))
            else:
                command.append(str(scan_options))
        
        # 添加端口範圍
        if ports:
            command.extend(['-p', ports])
        elif not self._has_port_option(scan_options):
            command.extend(['-p', self.config['default_ports']])
        
        # 添加其他選項
        if kwargs.get('timing'):
            command.extend(['-T', str(kwargs['timing'])])
        
        if kwargs.get('no_ping'):
            command.append('-Pn')
        
        if kwargs.get('fragment'):
            command.append('-f')
        
        if kwargs.get('decoy'):
            command.extend(['-D', str(kwargs['decoy'])])
        
        if kwargs.get('source_port'):
            command.extend(['--source-port', str(kwargs['source_port'])])
        
        # 添加目標
        command.append(target)
        
        return command
    
    def _has_port_option(self, scan_options) -> bool:
        """
        檢查掃描選項中是否包含端口相關選項
        
        Args:
            scan_options: 掃描選項（字符串或列表）
            
        Returns:
            是否包含端口選項
        """
        port_indicators = ['-p', '--top-ports', '--port-ratio', '-F']
        
        if isinstance(scan_options, str):
            return any(indicator in scan_options for indicator in port_indicators)
        elif isinstance(scan_options, list):
            scan_str = ' '.join(str(option) for option in scan_options)
            return any(indicator in scan_str for indicator in port_indicators)
        
        return False
    
    async def _execute_nmap(self, command: List[str]) -> Tuple[str, List[str]]:
        """
        執行 nmap 命令
        
        Args:
            command: 命令列表
            
        Returns:
            (標準輸出, 錯誤列表)
        """
        # 確保所有命令元素都是字符串
        command_str = [str(item) for item in command]
        self.logger.debug(f"執行 nmap 命令: {' '.join(command_str)}")
        
        try:
            process = await asyncio.create_subprocess_exec(
                *command_str,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=self.config['timeout']
            )
            
            stdout_text = stdout.decode('utf-8', errors='ignore')
            stderr_text = stderr.decode('utf-8', errors='ignore')
            
            errors = []
            if process.returncode != 0:
                errors.append(f"nmap 退出碼: {process.returncode}")
            
            if stderr_text.strip():
                errors.append(f"nmap 錯誤: {stderr_text.strip()}")
            
            return stdout_text, errors
            
        except asyncio.TimeoutError:
            raise Exception(f"nmap 執行超時 ({self.config['timeout']}秒)")
        except FileNotFoundError:
            raise Exception(f"找不到 nmap 程序: {self.config['nmap_path']}")
        except Exception as e:
            raise Exception(f"執行 nmap 失敗: {str(e)}")
    
    def _parse_nmap_output(self, xml_output: str) -> List[HostInfo]:
        """
        解析 nmap XML 輸出
        
        Args:
            xml_output: XML 輸出
            
        Returns:
            主機信息列表
        """
        hosts = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host_elem in root.findall('host'):
                host_info = self._parse_host_element(host_elem)
                if host_info:
                    hosts.append(host_info)
                    
        except ET.ParseError as e:
            self.logger.error(f"解析 nmap XML 輸出失敗: {e}")
        except Exception as e:
            self.logger.error(f"處理 nmap 輸出時發生錯誤: {e}")
        
        return hosts
    
    def _parse_host_element(self, host_elem) -> Optional[HostInfo]:
        """
        解析主機元素
        
        Args:
            host_elem: 主機 XML 元素
            
        Returns:
            主機信息
        """
        try:
            # 獲取狀態
            status_elem = host_elem.find('status')
            if status_elem is None:
                return None
            
            status = status_elem.get('state', 'unknown')
            
            # 獲取 IP 地址
            address_elem = host_elem.find('address[@addrtype="ipv4"]')
            if address_elem is None:
                address_elem = host_elem.find('address[@addrtype="ipv6"]')
            
            if address_elem is None:
                return None
            
            ip = address_elem.get('addr')
            
            # 創建主機信息
            host_info = HostInfo(
                ip=ip,
                status=status,
                last_seen=time.time()
            )
            
            # 獲取主機名
            hostnames_elem = host_elem.find('hostnames')
            if hostnames_elem is not None:
                hostname_elem = hostnames_elem.find('hostname')
                if hostname_elem is not None:
                    host_info.hostname = hostname_elem.get('name')
            
            # 獲取 MAC 地址
            mac_elem = host_elem.find('address[@addrtype="mac"]')
            if mac_elem is not None:
                host_info.mac_address = mac_elem.get('addr')
                host_info.vendor = mac_elem.get('vendor')
            
            # 獲取操作系統信息
            os_elem = host_elem.find('os')
            if os_elem is not None:
                host_info.os_info = self._parse_os_element(os_elem)
            
            # 獲取端口信息
            ports_elem = host_elem.find('ports')
            if ports_elem is not None:
                host_info.ports = self._parse_ports_element(ports_elem)
            
            # 計算響應時間
            times_elem = host_elem.find('times')
            if times_elem is not None:
                rtt = times_elem.get('rttvar')
                if rtt:
                    try:
                        host_info.response_time = float(rtt) / 1000  # 轉換為秒
                    except ValueError:
                        pass
            
            return host_info
            
        except Exception as e:
            self.logger.error(f"解析主機元素失敗: {e}")
            return None
    
    def _parse_os_element(self, os_elem) -> Dict[str, Any]:
        """
        解析操作系統元素
        
        Args:
            os_elem: 操作系統 XML 元素
            
        Returns:
            操作系統信息
        """
        os_info = {}
        
        # 獲取操作系統匹配
        osmatch_elems = os_elem.findall('osmatch')
        if osmatch_elems:
            matches = []
            for match in osmatch_elems:
                match_info = {
                    'name': match.get('name'),
                    'accuracy': int(match.get('accuracy', 0))
                }
                
                # 獲取操作系統類別
                osclass_elems = match.findall('osclass')
                if osclass_elems:
                    classes = []
                    for osclass in osclass_elems:
                        class_info = {
                            'type': osclass.get('type'),
                            'vendor': osclass.get('vendor'),
                            'osfamily': osclass.get('osfamily'),
                            'osgen': osclass.get('osgen'),
                            'accuracy': int(osclass.get('accuracy', 0))
                        }
                        classes.append(class_info)
                    match_info['classes'] = classes
                
                matches.append(match_info)
            
            os_info['matches'] = matches
        
        return os_info
    
    def _parse_ports_element(self, ports_elem) -> List[PortInfo]:
        """
        解析端口元素
        
        Args:
            ports_elem: 端口 XML 元素
            
        Returns:
            端口信息列表
        """
        ports = []
        
        for port_elem in ports_elem.findall('port'):
            try:
                port_num = int(port_elem.get('portid'))
                protocol = port_elem.get('protocol')
                
                # 獲取狀態
                state_elem = port_elem.find('state')
                if state_elem is None:
                    continue
                
                state = state_elem.get('state')
                
                port_info = PortInfo(
                    port=port_num,
                    protocol=protocol,
                    state=state
                )
                
                # 獲取服務信息
                service_elem = port_elem.find('service')
                if service_elem is not None:
                    port_info.service = service_elem.get('name')
                    port_info.version = service_elem.get('version')
                    port_info.product = service_elem.get('product')
                    port_info.extra_info = service_elem.get('extrainfo')
                    
                    conf = service_elem.get('conf')
                    if conf:
                        try:
                            port_info.confidence = int(conf)
                        except ValueError:
                            pass
                
                ports.append(port_info)
                
            except (ValueError, TypeError) as e:
                self.logger.warning(f"解析端口信息失敗: {e}")
                continue
        
        return ports
    
    async def ping_sweep(self, network: str) -> List[str]:
        """
        Ping 掃描
        
        Args:
            network: 網絡範圍
            
        Returns:
            活動主機列表
        """
        progress_manager = get_progress_manager()
        spinner = None
        
        self.logger.info(f"開始 Ping 掃描: {network}")
        
        command = [
            self.config['nmap_path'],
            '-sn',  # Ping 掃描
            '-oX', '-',  # XML 輸出
            network
        ]
        
        try:
            # 創建進度指示器
            spinner = progress_manager.create_spinner(
                "ping_sweep", 
                f"正在執行 Ping 掃描: {network}..."
            )
            spinner.start()
            
            raw_output, errors = await self._execute_nmap(command)
            
            spinner.update_message(f"解析 Ping 掃描結果...")
            hosts = self._parse_nmap_output(raw_output)
            
            alive_hosts = [host.ip for host in hosts if host.status == "up"]
            
            spinner.stop(f"✓ Ping 掃描完成，發現 {len(alive_hosts)} 個活動主機")
            
            self.logger.info(f"Ping 掃描完成，發現 {len(alive_hosts)} 個活動主機")
            
            return alive_hosts
            
        except Exception as e:
            if spinner:
                spinner.stop(f"✗ Ping 掃描失敗: {str(e)}")
            
            self.logger.error(f"Ping 掃描失敗: {e}")
            return []
    
    async def port_scan(self, target: str, ports: str = "1-1000") -> List[PortInfo]:
        """
        端口掃描
        
        Args:
            target: 目標主機
            ports: 端口範圍
            
        Returns:
            開放端口列表
        """
        progress_manager = get_progress_manager()
        spinner = None
        
        self.logger.info(f"開始端口掃描: {target}:{ports}")
        
        try:
            # 創建進度指示器
            spinner = progress_manager.create_spinner(
                "port_scan", 
                f"正在掃描端口: {target}:{ports}..."
            )
            spinner.start()
            
            result = await self.scan_network(target, "quick", ports)
            
            if result.hosts:
                open_ports = [port for port in result.hosts[0].ports if port.state == "open"]
                
                if spinner:
                    spinner.stop(f"✓ 端口掃描完成，發現 {len(open_ports)} 個開放端口")
                
                self.logger.info(f"端口掃描完成，發現 {len(open_ports)} 個開放端口")
                return open_ports
            
            if spinner:
                spinner.stop(f"✓ 端口掃描完成，未發現開放端口")
            
            return []
            
        except Exception as e:
            if spinner:
                spinner.stop(f"✗ 端口掃描失敗: {str(e)}")
            
            self.logger.error(f"端口掃描失敗: {e}")
            return []
    
    def export_results(self, result: ScanResult, output_path: str, format_type: str = "json"):
        """
        導出掃描結果
        
        Args:
            result: 掃描結果
            output_path: 輸出路徑
            format_type: 格式類型 (json, xml, csv)
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        if format_type.lower() == "json":
            self._export_json(result, output_path)
        elif format_type.lower() == "xml":
            self._export_xml(result, output_path)
        elif format_type.lower() == "csv":
            self._export_csv(result, output_path)
        else:
            raise ValueError(f"不支持的格式: {format_type}")
        
        self.logger.info(f"掃描結果已導出: {output_path}")
    
    def _export_json(self, result: ScanResult, output_path: Path):
        """
        導出為 JSON 格式
        """
        data = {
            'scan_info': {
                'scan_id': result.scan_id,
                'target': result.target,
                'scan_type': result.scan_type,
                'start_time': result.start_time,
                'end_time': result.end_time,
                'duration': result.duration,
                'scan_command': result.scan_command
            },
            'statistics': {
                'total_hosts': result.total_hosts,
                'alive_hosts': result.alive_hosts,
                'total_ports': result.total_ports,
                'open_ports': result.open_ports
            },
            'hosts': [],
            'errors': result.errors
        }
        
        for host in result.hosts:
            host_data = {
                'ip': host.ip,
                'hostname': host.hostname,
                'mac_address': host.mac_address,
                'vendor': host.vendor,
                'status': host.status,
                'response_time': host.response_time,
                'os_info': host.os_info,
                'ports': []
            }
            
            for port in host.ports:
                port_data = {
                    'port': port.port,
                    'protocol': port.protocol,
                    'state': port.state,
                    'service': port.service,
                    'version': port.version,
                    'product': port.product,
                    'extra_info': port.extra_info,
                    'confidence': port.confidence
                }
                host_data['ports'].append(port_data)
            
            data['hosts'].append(host_data)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    def _export_xml(self, result: ScanResult, output_path: Path):
        """
        導出為 XML 格式
        """
        if result.raw_output:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(result.raw_output)
    
    def _export_csv(self, result: ScanResult, output_path: Path):
        """
        導出為 CSV 格式
        """
        import csv
        
        with open(output_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # 寫入標題
            writer.writerow([
                'IP', 'Hostname', 'Status', 'Port', 'Protocol',
                'State', 'Service', 'Version', 'Product'
            ])
            
            # 寫入數據
            for host in result.hosts:
                if host.ports:
                    for port in host.ports:
                        writer.writerow([
                            host.ip,
                            host.hostname or '',
                            host.status,
                            port.port,
                            port.protocol,
                            port.state,
                            port.service or '',
                            port.version or '',
                            port.product or ''
                        ])
                else:
                    writer.writerow([
                        host.ip,
                        host.hostname or '',
                        host.status,
                        '', '', '', '', '', ''
                    ])